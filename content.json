{"pages":[],"posts":[{"title":"并查集","text":"并查集 并查集并查集是使用树的形式来处理集合，涉及的方法包括： 初始化 查询 合并 并查集会将相互相连的节点组织成一个树状结构，算法代码如下： 1234567891011121314151617181920212223242526private int[] p;//初始化//初始化时每个元素都是单独的，他们都指向本身private void init(){ for (int i=0;i&lt;n;i++){ p[i] = i; }}//合并集合//合并集合就是分别找到s和p的最顶部元素，然后将s的最顶部元素指向调整为p的最顶部元素，举例如下：//两个树：1-&gt;2-&gt;3与4-&gt;5-&gt;6//输入s为1，p为4//首先找到1的祖先(3)，然后找到4的祖先(6)//然后将3指向6，最终得到树：1-&gt;2-&gt;3-&gt;6&lt;-5&lt;-4private void union(int s,int p){ int sub = find(s); int par = find(f); p[sub] = father;}//查找最顶部的祖先元素//例如树为：1-&gt;2-&gt;3//输入1，返回的是3private int find(int n){ if (p[n]==n) return n; return find(p[n]);} 升级版find()函数 12345678//该函数主要是在递归找到祖先节点后并不是直接返回，而是多个一个赋值操作，这一步会将其所有的子孙节点的指向全部修改为指向祖先节点//例如1-&gt;2-&gt;3-&gt;4//查找到4后会将1、2、3的指向全部设置为4private int find(int n){ if (p[n]==n) return n; p[n]=find(p[n]); return p[n];} 如果想要查看两个节点是否在同一集合内，只需要分别调用find()方法判断是否相等即可: 1find(n1)==find(n2)","link":"/2023/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"二分查找","text":"二分查找 二分查找二分查找表示将一个列表分成两份，根据条件排除其中不符合要求的一份，然后对符合要求的那份再进行二分查找。最简单的二分查找就是在一个数组中找到指定数的索引下标，但二分查找有很多的更加复杂的应用。 题目特征：能否使用二分取决于是否具有决策单调性，即考虑整个数轴，左边一半满足条件，右边不满足；或者左边一半不满足，右边满足。 袋子中最少数目的球题目描述给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 可以选择nums中任意一个袋子，将其中的球分到两个新袋子中，比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 最终返回的是数组中的最大值 ，要求通过分配使这个最大值尽可能小。 链接：https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag 分析我们假设分配后数组最大值为y，则： y肯定是数组nums的最大值和1之间的一个数，因为划分后最大球数肯定会变小。 每次划分都会使袋子的数量+1 可以通过袋子的数量判断y的合理性，比如y为3，现在有一个袋子球数为11，则需要划分为3、3、3、2，袋子数为4，操作次数为3。将数组nums中所有的数都进行这样的划分，累加所有的操作次数，与maxOperations比较即可判断y是否符合条件 如果y符合条件，则表示通过不超过maxOperations次操作可以使数组最大值为y，此时就可以排除大于y的结果值。对于小于y结果我们还不知道是否成立，所以可以在（1，y-1）区间内再次选择一个y进行验证 如果y不符合条件，则可以排除小于y的结果，说明结果在（y+1,max(nums)）区间内，则在此区间选择一个y进行验证 当我们最终左右区间值是一个数时表示这个y就是答案 根据上述分析，本题符合决策单调性，可以二分 代码123456789101112131415161718192021222324252627class Solution { public int minimumSize(int[] nums, int maxOperations) { //初始区间 int left = 1, right = Arrays.stream(nums).max().getAsInt(); int ans = 0; //结束条件 while (left &lt;= right) { //选取区间的中间值为y int y = (left + right) / 2; long ops = 0; //遍历nums，计算操作数 for (int x : nums) { //(x - 1) / y表示划分的袋子数-1 ops += (x - 1) / y; } if (ops &lt;= maxOperations) {//符合条件 ans = y; right = y - 1; } else {//不符合条件 left = y + 1; } } return ans; }}","link":"/2023/05/09/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"七大原则","text":"设计模式中的七大原则。 1. 开闭原则对扩展开放，对修改关闭。 2. 单一职责原则一个类只负责一项职责。如果A类负责两个不同的职责（职责1、职责2），当职责1发生变化而改变A时，可能会对职责2造成影响。 3. 里氏代换原则所有引用基类的方法必须能透明地使用起子类的对象。使用继承的时候，父类会对子类进行约束。并且如果父类中的方法发生改变的时候，可能会对所有的子类造成影响。 4. 接口隔离原则依赖最小接口。不应该依赖不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。可以将接口拆分为独立的几个接口，每个类只需要依赖所需要的接口即可。 5. 合成复用原则尽量使用合成/聚合，而不是通过继承达到复用的目的继承的耦合度更高。 6. 迪米特法则减少类之间没必要的依赖。一个软件实体应该尽可能少的与其他实体发生作用，降低耦合性。 7. 依赖倒转原则依赖于抽象，不能依赖于具体实现。尽可能的依赖抽象层次更高的接口或类，这样会更加稳定。","link":"/2023/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"},{"title":"","text":"[[七大原则]]； 1. 创建型模式 用来创建实例 [[单例模式]]； [[工厂模式]]； [[原型模式]]； [[建造者模式]]； 2. 结构型模式 用于为现有对象扩展功能 [[适配器模式]]； [[装饰者模式]]； [[代理模式]]； [[外观模式]]； [[桥接模式]]； [[组合模式]]； [[享元模式]]； 3. 关系型模式 主要描述不同类之间的交互关系 [[策略模式]]； [[模板模式]]； [[观察者模式]]； [[迭代器模式]]； [[责任链模式]]； [[命令模式]]； [[状态模式]]； [[备忘录模式]]； [[访问者模式]]； [[中介者模式]]；","link":"/2024/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%9B%AE%E5%BD%95/"},{"title":"Arch 初始化配置","text":"Arch 环境配置 安装过程参考：安装教程 桌面安装桌面引导12$ sudo pacman -S xorg gdm$ systemctl enable gdm gnome桌面基础桌面123$ sudo pacman -S gnome gnome-tweaks gnome-browser-connector# 中文字体$ sudo pacman -S noto-fonts 删除无用项1$ sudo pacman -R 安装输入法1234$ sudo pacman -S ibus ibus-rime# 配置ibus-rime$ ibus-setup#然后在系统设置中输入法添加rime即可 编程环境Go123$ sudo pacman -Sy go# golangexport PATH=&quot;$PATH:$HOME/go/bin&quot; 配置镜像12# 设置阿里镜像$ go env -w GOPROXY=https://mirrors.aliyun.com/golang/ Javaarch默认安装了jre，正常安装jdk时也会顺带安装jre，可以安装一个默认版和一个稳定版 1$ sudo pacman -Sy jdk-openjdk 配置maven镜像阿里镜像 Rust使用rustup进行安装，另外pacman提供的被改动过，会随着arch进行更新，建议安装官方原版 官网安装rustup 1234567$ vim .zshrc# 添加# 用于更新 toolchainexport RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;# 用于更新 rustupexport RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 配置镜像中科大镜像 Elixir123456$ sudo pacman -S elixir$ vim .zshrc# 添加# elixir hexexport HEX_MIRROR=&quot;https://hexpm.upyun.com&quot;export HEX_CDN=&quot;https://hexpm.upyun.com&quot; 验证 1$ iex -v .Net123$ sudo pacman -S dotnet-sdk# asp.net core运行时$ sudo pacman -S aspnet-runtime 验证 1$ dotnet --version Python1$ sudo pacman -S python python-pip 配置镜像北外镜像 Anaconda1$ yay -S anaconda 激活anaconda环境 1$ source /opt/anaconda/bin/activate root 关闭anaconda环境 1$ source /opt/anaconda/bin/deactivate root Miniconda1$ yay -S miniconda 激活miniconda环境 123$ source /opt/miniconda/etc/profile.d/conda.sh# 如果是zsh的话后面接zsh$ conda init zsh Ruby1234567891011121314# 安装ruby版本管理工具$ yay -S rbenv ruby-build # 查看版本$ rbenv install --list# 下载$ rbenv install 3.2.2# 设置全局ruby版本$ rbenv global 3.2.2# 设置shell使用ruby，根据提示完成即可$ rbenv shell$ vim .zshrc# rubyeval &quot;$(rbenv init - zsh)&quot;export RUBY_BUILD_MIRROR_URL=https://cache.ruby-china.com 配置镜像北外镜像 PHP12sudo pacman -S php composeryay -S php-pear Node.js1$ sudo pacman -S nodejs 配置镜像阿里镜像 12$ sudo npm config set disturl http://npmmirror.com --global$ sudo npm config set registry http://registry.npmmirror.com --global 软件通用软件1$ yay -S jetbrains-toolbox visual-studio-code-bin clash-verge 包含如下软件： jetbrains-toolbox vscode clash-verge 命令行（zsh）oh-my-zsh工具github网址 1234$ sudo pacman -S zsh oh-my-zsh-git$ chsh -s $(which zsh)# 安装 oh-my-zsh，接下来按照自己的喜好更改~/.zshrc即可$ sh /usr/share/oh-my-zsh/tools/install.sh Docker12345678# 安装$ sudo pacman -S docker# 启动$ sudo systemctl start docker# 开机启动$ sudo systemctl enable docker# 状态$ sudo systemctl status docker 权限 12345678# 查看目前已有的group$ groups# 若没有docker组,就新建一个docker组$ sudo groupadd docker# 将当前用户加入docker组中$ sudo gpasswd -a ${USER} docker# 刷新用户组$ newgrp docker MinIOdocker 安装及启动123456789docker run -d\\ -p 9000:9000 \\ -p 9001:9001 \\ --name minio \\ --hostname minio \\ -v /mnt/docker/minio/data:/data \\ -e &quot;MINIO_ROOT_USER=zcy&quot; \\ -e &quot;MINIO_ROOT_PASSWORD=123456789&quot; \\ minio/minio:RELEASE.2023-09-23T03-47-50Z server /data --console-address &quot;:9001&quot; 下载12# 下载$ sudo pacman -S minio minio-client minio启动1$ minio server ~/minio --console-address :9001 minio-client启动使用mcli而非msc 1$ mcli ls ~/minio/test Minikube12345678$ sudo pacman -S minikube# 启动，提前启动docker（或其他虚拟化工具），miniokube会自动寻找当前虚拟化工具，然后拉取镜像$ minikube start --image-mirror-country=cn $ minikube dashboard$ vim .zshrc# 添加# minikube 命令简化alias kubectl=&quot;minikube kubectl --&quot; PostgreSQLdocker安装12345678docker run -d \\ --name postgresql \\ -p 5432:5432 \\ -e POSTGRES_PASSWORD=123456 \\ -e PGDATA=/var/lib/postgresql/data/pgdata \\ -v /mnt/docker/postgresql/data:/var/lib/postgresql/data \\ # -c wal_level=logical 是日志权限，同步时需要用到 postgres:15.4 -c wal_level=logical 本机安装12345678910111213141516# 安装$ sudo pacman -S postgresql# 初始化$ sudo -u postgres –i initdb -D '/var/lib/postgres/data'# 默认会创建postgres用户，密码为空，这里设置密码$ passwd postgres# 开机启动$ systemctl enable postgresql$ systemctl start postgresql# 配置远程访问$ sudo vim /var/lib/postgres/data# 在IPv4 local那里复制一行改为0.0.0.0/0# host all all 0.0.0.0/0 trust$ sudo vim /var/lib/postgres/data/postgresql.conf#设置 listen_addresses = ‘*’$ systemctl restart postgresql MySQLdocker 安装123456docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\ -v /mnt/docker/mysql/data:/var/lib/mysql \\ mysql:8.0 本机安装12345678910111213141516# 安装$ sudo pacman -S mysql# 初始化，会在末尾输出密码，这里是e#gK%hB3o.el$ sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql# 开机启动$ systemctl enable mysqld# 启动$ systemctl start mysqld# 默认会创建root用户，密码为随机生成，现在设置密码# 连接mysql$ mysql -uroot -p# 修改密码$ ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY '123456';# 退出重启$ exit$ systemctl restart mysqld 外部访问12345mysql -u root -p&gt; use mysql;&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; &gt; flush privileges;&gt; quit; Redisdocker 安装12345docker run -d \\ --name redis \\ -p 6379:6379 \\ -v /mnt/docker/redis/data:/data \\ redis:7.2.2 本机安装123456$ sudo pacman -S redis# 设置开机启动$ systemctl enable redis# 查看状态$ systemctl status redis$ systemctl start redis 设置密码及远程访问1$ sudo vim /etc/redis/redis.conf 修改如下： 123456# 注释bind，或改成自己的ip地址# bind 127.0.0.1 -::1# yes 改为 noprotected-mode no# 去掉注释，设置自己的密码requirepass 123456 Mongodbdocker安装简易版： 1234567891011121314151617$ docker run -itd \\-p 27017:27017 \\--name mongodb \\-v /mnt/docker/mongodb/data:/data/db \\mongo:7 mongod --replSet rs0 $ docker exec -it mongodb /bin/bash$ mongosh$ rs.initiate()$ use admin$ db.createUser({ user: 'mongodb', // 用户名 pwd: '123456', // 密码 roles:[{ role: 'root', // 使用超级用户角色 db: 'admin' // 指定数据库 }]}) 使用keyfile： 12345678910111213141516171819202122$ mkdir -p ~/config/mongodb$ openssl rand -base64 666 &gt; ~/config/mongodb/keyfile$ sudo chown 999 ~/config/mongodb/keyfile$ chmod 600 ~/config/mongodb/keyfile$ docker run -itd \\-p 27017:27017 \\--name mongodb \\-v /mnt/docker/mongodb/data:/data/db \\-v ~/config/mongodb/:/opt/keyfile/ \\mongo:7 mongod --auth --keyFile /opt/keyfile/keyfile --replSet rs0 $ docker exec -it mongodb /bin/bash$ mongosh$ rs.initiate ()$ use admin$ db.createUser({ user: 'mongodb', // 用户名 pwd: '123456', // 密码 roles:[{ role: 'root', // 使用超级用户角色 db: 'admin' // 指定数据库 }]}) 本机安装1234$ yay -S mongodb-bin$ sudo systemctl start mongodb$ sudo systemctl status mongodb$ sudo systemctl enable mongodb 创建用户 123456789101112$ mongosh# 创建用户use admindb.createUser({ user: 'mongodb', // 用户名 pwd: '123456', // 密码 roles:[{ role: 'root', // 使用超级用户角色 db: 'admin' // 指定数据库 }]}) 重启 1$ sudo systemctl restart mongodb 远程访问进入 /etc/mongodb.conf 文件修改如下内容： 12345678net: bindIp: 127.0.0.1# 改为net: bindIp: 0.0.0.0 # 添加security: authorization: enabled 卸载1$ sudo pacman -Rns mongodb-bin Elasticsearch123456789101112131415161718$ docker pull elasticsearch:8.8.1$ docker pull kibana:8.8.1# 验证网址（需要输帐号密码）：https://localhost:9200/$ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d elasticsearch:8.8.1$ docker exec -it elasticsearch /bin/bash$ elasticsearch-reset-password --username elastic -i#生成的token保存起来用来进入kibana$ elasticsearch-create-enrollment-token -s kibana --url &quot;https://localhost:9200&quot;$ docker run -d --name kibana --link elasticsearch:elasticsearch -p 5601:5601 kibana:8.8.1#进入 http://localhost:5601/ 即可$ docker run --name=logstash \\ --restart=always --privileged=true --net host \\ -d docker.elastic.co/logstash/logstash:8.8.1$ docker pull docker.elastic.co/logstash/logstash:8.8.1$ docker run --rm -it -v ~/settings/:/usr/share/logstash/config/ docker.elastic.co/logstash/logstash:8.8.1 安装IK分词器123456789101112$ docker exec -it elasticsearch /bin/bash# 方法1：(可能超时)$ elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v8.8.1/elasticsearch-analysis-ik-8.8.1.zip#方法二：下载https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v8.8.1/elasticsearch-analysis-ik-8.8.1.zip$ mkdir plugins/ik# 瞎子后拷贝到ik目录中$ docker cp ./elasticsearch-analysis-ik-8.8.1.zip elasticsearch:/usr/share/elasticsearch/plugins/ik/# 进入 plugins/ik/ 执行$ unzip elasticsearch-analysis-ik-8.8.1.zip$ docker restart elasticsearch 驱动docker部署 es 在使用其它语言的驱动时会需要http_ca.crt文件 1$ docker cp elasticsearch:/usr/share/elasticsearch/config/certs/http_ca.crt . RabbitMQdocker安装1docker run -d -p 15672:15672 -p 5672:5672 --hostname rabbitmq --name rabbitmq -e RABBITMQ_DEFAULT_USER=zcy -e RABBITMQ_DEFAULT_PASS=123456 rabbitmq:3-management","link":"/2023/03/01/linux/arch/arch%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"Fedora 初始化配置","text":"fedora 操作系统安装后相关环境配置 国内镜像北外镜像按照北外 fedora | 镜像站使用帮助 | 北京外国语大学开源软件镜像站 | BFSU Open Source Mirror 中的内容创建文件然后使用如下命令使用创建的文件覆盖 /etc/yum.repos.d/ 目录下的文件 12345678910# 首先进行备份[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora.repo ./backup/[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora-modular.repo ./backup/[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora-updates.repo ./backup/[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora-updates-modular.repo ./backup/# 覆盖软件源[zcy@fedora temp]$ sudo cp -f ./fedora.repo /etc/yum.repos.d/fedora.repo [zcy@fedora temp]$ sudo cp -f ./fedora-modular.repo /etc/yum.repos.d/fedora-modular.repo [zcy@fedora temp]$ sudo cp -f ./fedora-updates.repo /etc/yum.repos.d/fedora-updates.repo[zcy@fedora temp]$ sudo cp -f ./fedora-updates-modular.repo /etc/yum.repos.d/fedora-updates-modular.repo 语言环境Java安装过程fedora默认自带新版的java，但是headless版本（最小java运行时），下面安装openjdk： 123456# 安装$ sudo dnf install java$ sudo dnf install java-17-openjdk-devel# 验证$ java --version$ jps Pythonfedora默认自带新版的Python Golang通过 dnf 命令安装 golang 1234$ sudo dnf install golang# 配置国内代理，否则使用go get会卡住$ go env -w GOPROXY=https://goproxy.cn,direct 不需要配置 GOROOT 和 GOPATH 环境变量，默认 GOPATH 为 *～/go/*，GOROOT 自动被设置为 /usr/lib/golang Rust安装过程1234# 获取管理工具并执行$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh# 验证是否安装成功$ rustc --version 更新过程1$ rustup update Dotnet安装过程fedora软件库中自带dotnet，直接安装即可 1$ sudo dnf install dotnet Elixirelixir基于erlang虚拟机，所以需要顺便安装erlang环境 123456789101112# 安装elixir和erlang$ sudo dnf install elixir erlang# erlang版本$ erl -version# elixir版本$ iex -v# 配置镜像$ vim .bashrc# elixir hexexport HEX_MIRROR=&quot;https://hexpm.upyun.com&quot;export HEX_CDN=&quot;https://hexpm.upyun.com&quot; Ruby123456789101112131415161718# 安装ruby版本管理工具$ sudo dnf install rbenv -y# 查看可用ruby版本$ rbenv install --list# 根据需要进行安装$ rbenv install 3.1.2# 设置当前使用版本$ rbenv global 3.1.2# 配置gem（ruby包管理器）镜像$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/# 应该只有 gems.ruby-china.com$ gem sources -l#替换 Bundler$ bundle config mirror.https://rubygems.org https://gems.ruby-china.com#安装rails$ gem install rails# 建议使用rails new xxx先创建个项目，会下载一些必要的依赖，之后再使用RubyMine创建项目 Nodejs12345678# 安装nodejs$ sudo dnf install nodejs# 查看版本node -v# 配置淘宝镜像源$ npm config set registry https://registry.npm.taobao.org$ npm config set disturl https://npm.taobao.org/dist 如果想要删除淘宝镜像执行如下语句： 123#删除镜像npm config delete registrynpm config delete disturl 软件安装Docker安装过程1234567891011121314151617181920212223$ sudo dnf update# 配置依赖库$ sudo dnf config-manager \\ --add-repo \\ https://download.docker.com/linux/fedora/docker-ce.repo# 安装最新版 docker 引擎$ sudo dnf install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 启动 docker$ sudo systemctl start docker# 查看 docker 版本$ docker -v# 配置阿里云镜像加速$ sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://nnjl45n3.mirror.aliyuncs.com&quot;]}EOF$ sudo systemctl daemon-reload$ sudo systemctl restart docker PostgreSQL安装过程在 fedora 中的 OS AppStream 存储库默认的存储库中就包含了 postgresql14，建议使用该方式安装 postgresq，另外也可以自己引入存储库下载 123456# 重置并启动module流$ sudo dnf module reset postgresql -y# 安装postgresql$ sudo dnf install vim postgresql-server postgresql# 初始化，数据和日志文件夹默认在 /var/lib/pgsql/ 目录下$ sudo postgresql-setup --initdb 远程访问首先配置防火墙 1234$ sudo firewall-cmd --add-service=postgresql --permanentsuccess$ sudo firewall-cmd --reloadsuccess 需要修改两个配置文件 12345678910111213141516171819202122# 第一个配置文件$ sudo vim /var/lib/pgsql/data/postgresql.conf# 修改内容如下#listen_addresses = 'localhost' # what IP address(es) to listen on;# 将监听地址设置为您的服务器 IP 地址或所有接口或特定 IP 地址/子网的“ * ”。listen_addresses = '*'# 第二个配置文件$ sudo vim /var/lib/pgsql/data/pg_hba.conf# # local DATABASE USER METHOD [OPTIONS]# host DATABASE USER ADDRESS METHOD [OPTIONS]# hostssl DATABASE USER ADDRESS METHOD [OPTIONS]# hostnossl DATABASE USER ADDRESS METHOD [OPTIONS]# hostgssenc DATABASE USER ADDRESS METHOD [OPTIONS]# hostnogssenc DATABASE USER ADDRESS METHOD [OPTIONS]# 0.0.0.0/0代表任何地点的连接，也可以设置为信任的子网，如：10.10.10.0/24host all all 0.0.0.0/0 md5# 更改完毕后重启`postgresql`$ sudo systemctl restart postgresql 配置密码postgresql 默认用户名为Postgres，没有密码。通过以下命令修改密码： 1234[xxx@fedora ~]$ sudo su - postgres# 将123456设置为postgresql的密码[postgres@fedora ~]$ psql -c &quot;alter user postgres with password '123456'&quot;ALTER ROLE MySQL安装过程1234567#fedora存储库中自带mysql社区版$ sudo dnf install community-mysql-server#启动服务$ sudo systemctl start mysqld.service$ sudo systemctl status mysqld.service#开机启动$ sudo systemctl enable mysqld.service 远程访问123#配置防火墙sudo firewall-cmd --add-service=mysql --permanentsudo firewall-cmd --reload 配置密码其他方式可能在安装mysql时会生成一个随机密码，但通不过本方式默认密码为空 12345mysql -u root -p&gt; use mysql;&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; &gt; flush privileges;&gt; quit; Redis安装过程12345678# 安装$ sudo dnf install redis# 启动$ systemctl statrt redis# 设置开机启动，redis默认开机不会启动$ systemctl enable redis# 查看状态$ systemctl status redis 远程访问123456#注释bind，或改成自己的ip地址#bind 127.0.0.1 -::1# yes -&gt; noprotected-mode no# 去掉注释，设置自己的密码requirepass 123456 Mongodb安装过程fedora 默认不包含 mongodb 软件包，所以需要主动引入，建立 /etc/yum.repos.d/mongodb.repo 文件并填充如下内容： 1234567# 这里使用阿里云镜像[mongodb-org]name = MongoDB Repositorybaseurl = https://mirrors.aliyun.com/mongodb/yum/redhat/8Server/mongodb-org/5.0/x86_64/gpgcheck = 1 enabled = 1 gpgkey = https://www.mongodb.org/static/pgp/server-5.0.asc 添加完软件源后下载 mongodb，由于 fedora 移除了platform-python 所以此时使用 sudo dnf install mongodb-org 命令下载 5.0 以上版本的 mongodb 时会报错，正确的方式是单个组件下载： 1$ sudo dnf install mongodb-org-server mongodb-org-shell mongodb-database-tools mongodb-org-mongos 下载完成后需要重启电脑才会生效 远程访问进入 /etc/mongod.conf 文件修改如下内容： 12345net: bindIp: 127.0.0.1# 改为net: bindIp: 0.0.0.0 设置用户名和密码mongodb 默认没有安全认证，不需要用户名密码即可连接和操作 mongodb。用户名密码创建过程如下： 进入 mongodb 执行以下语句 12345678910use admindb.createUser({ user: 'username', // 用户名（自定义） pwd: 'password', // 密码（自定义） roles:[{ role: 'root', // 使用超级用户角色 db: 'admin' // 指定数据库 }]}) 进入 /etc/mongod.conf 添加如下内容： 12security: authorization: enabled 重启 mongodb 1$ sudo service mongod restart 设置用户组默认情况下使用docker命令必须通过sudo，如果想直接使用命令执行如下操作 123sudo groupadd dockersudo usermod -aG docker 用户名newgrp docker Neo4j安装过程docker单节点fedora包中没有neo4j，所以使用docker安装，便于更新版本 123456789101112131415# 拉取镜像$ docker pull neo4j# 查看镜像是否拉取成功$ docker images# 启动容器# -d表示容器后台运行，--name指定容器名字，-p端口号映射，-v挂载数据卷，-e设置环境变量（登录neo4j的用户名和密码）$ docker run -d --name neo4j \\ -p 7474:7474 -p 7687:7687 \\ -v /opt/neo4j/data:/data \\ -v /opt/neo4j/logs:/logs \\ -v /opt/neo4j/conf:/var/lib/neo4j/conf \\ -v /opt/neo4j/import:/var/lib/neo4j/import \\ --env NEO4J_AUTH=neo4j/123456 neo4j# 查看启动日志$ docker logs -f neo4j 日志提示容器启动成功后，访问如下连接进入neo4j的控制台 http://192.168.2.113:7474/ http://localhost:7474/ Elasticsearch安装过程123456789101112131415# 导入rpm源$ vim /etc/yum.repos.d/elasticsearch.repo#添加如下内容[elasticsearch]name=Elasticsearch repository for 8.x packagesbaseurl=https://artifacts.elastic.co/packages/8.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=0autorefresh=1type=rpm-md# 更新$ sudo dnf upgrade -refresh# 安装 elasticsearch$ sudo dnf install --enablerepo=elasticsearch elasticsearch MinIO安装过程单节点docker部署12345678$ docker run -d\\ -p 9000:9000 \\ -p 9001:9001 \\ --name minio \\ -v /opt/minio/data:/data \\ -e &quot;MINIO_ROOT_USER=zcy&quot; \\ -e &quot;MINIO_ROOT_PASSWORD=123456789&quot; \\ quay.io/minio/minio server /data --console-address &quot;:9001&quot; anacondaanaconda集成了很多python库，并且内置python环境 安装过程1234567891011121314151617181920# 首先去官网下载安装包，下载后是一个.sh文件# 执行该安装文件$ bash Anaconda3-2022.05-Linux-x86_64.sh# 1.点击回车# 2.按q跳过阅读# 3.目录选择默认目录，会安装到当前用户的主目录# 4.初始化选择no，后面手动配置# 配置环境变量$ vim .bash_profile# 加入如下配置#anacondaexport PATH=:$PATH:/home/zcy/anaconda3/bin$ source .bash_profile# 验证$ conda --version$ pip --version# 创建自己的环境# -n后接自定义的环境名# python=python版本号$ conda create -n 喜欢的名字 python=3.9.12 配置镜像1234567891011121314151617181920212223# 若没有.condarc文件，则运行命令生成配置文件# conda config --set show_channel_urls yes# 配置北外镜像源$ vim .condarc#输入如下内容channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.bfsu.edu.cn/anaconda/cloud simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud$ conda clean -i# 查看镜像源$ conda config --show-sources","link":"/2022/06/25/linux/fedora/feaora%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"},{"title":"Fedora 包管理器","text":"fedora 使用 yum 的升级版 dnf 作为包管理器 常用命令存储库保存存储库的文件夹路径如下： /etc/yum.repos.d 该文件夹内部包含了很多以 .repo 为后缀的文件，这里每个文件就是一个存储库，yum/dnf 会根据这些存储库来查找软件包 存储库操作添加存储库1sudo dnf config-manager -add-repo https://download.docker.com/linux/fedora/docker-ce.repo 安装路径系统默认下载的软件都会防止到 /usr 目录下通过 dnf 命令安装的软件包也是如此，与dnf/yum命令相关的路径如下： 路径 作用 /usr/bin 软件包的可执行文件，用户可以在其他位置通过命令行直接调用该目录下的可执行文件 /usr/lib dnf/yum 命令下载的软件包会安装到此处 /etc/alternatives 会在该目录生成一些软连接，但最终指向的都是*/usr/lib*下的软件包 以安装java-1.8-openjdk为例，调用dnf install命令安装完成后，后 /usr/bin 目录会出现一个名为 java 的可执行文件，真正的软件包会被安装到 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.352.b08-2.fc35.x86_64/jre/ 位置，另外 /etc/alternatives 中也会出现很多个openjdk的软连接，但最终都会指向 /user/lib 中的软件包位置。","link":"/2022/07/07/linux/fedora/fedora%20%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"Ubuntu 初始化配置","text":"ubuntu 操作系统安装后相关环境配置 国内镜像网络包12#网络工具包：ipconfigsudo apt install net-tools 阿里云镜像1234567891011# 在打开的文本中，添加阿里源deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse 语言环境Java安装过程123sudo apt install openjdk-版本号-jdk#查看版本号java -version 软件安装Docker安装过程12345678910111213141516171819202122sudo apt update#必要依赖sudo apt install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release#获取密钥curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gp#依赖源echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt update#安装sudo apt install docker-ce docker-ce-cli containerd.io#开机启动sudo systemctl enable docker#启动dockersudo systemctl start docker MySQL安装过程12345sudo apt install mysql-server#进入mysql，如果无法进入，则进行自定义密码mysql -u root -p#查看版本号select version(); 自定义密码1234567891011121314151617sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf#在文件中[mysql]下方添加skip -grant-tables#重启服务sudo systemctl restart mysql.service#自定义密码过程mysql -u root -puse mysql;update user set authentication_string='' where user='root';update user set plugin='mysql_native_password' where user='root';flush privilegesALTER user 'root'@'localhost' IDENTIFIED BY '123456';quitsudo systemctl enable mysql.service#开机启动sudo systemctl enable mysql.service 配置远程访问123456789101112#mysql配置文件/etc/mysql/mysql.conf.d/mysqld.cnf#注释 bind-address 127.0.0.1#重启服务sudo systemctl restart mysql.service#如果还无法连接则执行以下操作mysql -u root -p#结果中 user为root host为localhostselect user,host from user;#修改访问权限update user set host = '%' where user = 'root';select host from user where user = 'root'; Redis安装过程123456sudo apt updatesudo apt install redis-server#server版本redis-server --version#clli版本redis-cli -v 配置远程访问12#配置 Redis 远程访问vim /etc/redis/redis.conf 在文件夹中执行以下步骤 bind 127.0.0.1 ::1改为bind 0.0.0.0 查找protected-mode yes 把yes改为no （可选）将requirepass foobared取消注释，将foobared替换成自己的密码 MongoDB安装过程1234567891011121314151617181920sudo apt update#获取密钥wget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add -#必要依赖apt-get install gnupgsudo apt-get install libssl1.1#添加依赖源echo &quot;deb [ arch=amd64,arm64 ] http://mirrors.tuna.tsinghua.edu.cn/mongodb/apt/ubuntu focal/mongodb-org/5.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.listecho &quot;deb http://security.ubuntu.com/ubuntu impish-security main&quot; | sudo tee /etc/apt/sources.list.d/impish-security.list#更新sudo apt update#安装sudo apt-get install -y mongodb-org#开机启动sudo systemctl enable mongodb.service#启动sudo systemctl start mongodb.service#或sudo mongod -dbpath=/data/mongodb --logpath=/data/mongodb.log 远程访问1234#mongodb配置文件sudo vim /etc/mongod.conf#修改127.0.0.1 -&gt; 0.0.0.0 ElasticSearchdocker安装es过程12345678910111213141516171819202122232425262728docker pull elasticsearch:7.10.1docker pull kibana:7.10.1mkdir -p /data/elasticsearch/configmkdir -p /data/elasticsearch/datamkdir -p /data/elasticsearch/datachmod -R 777 /data/elasticsearch/echo &quot;http.host: 0.0.0.0&quot; &gt; /data/elasticsearch/config/elasticsearch.yml#启动es#访问 ip:9200docker run --name=&quot;elasticsearch&quot; -p 9200:9200 -p 9300:9300 \\ -e &quot;discovery.type=single-node&quot; \\ -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \\ -v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /data/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /data/elasticsearch/config/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.10.1#启动kibana#访问 ip:5601docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.1.5:9200 -p 5601:5601 -d kibana:7.10.1#之后启动使用docker start es容器iddocker start kibana容器id","link":"/2022/05/29/linux/ubuntu/Ubuntu%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"},{"title":"Ubuntu 包管理器","text":"ubuntu 是基于 debian 的发行版，使用 apt 作为包管理器 依赖源Ubuntu中仓库有两个位置： /etc/apt/sources.list：该文件内部存储源数据 123deb http://security.ubuntu.com/ubuntu jammy-security multiverse# deb-src http://security.ubuntu.com/ubuntu jammy-security universedeb http://security.ubuntu.com/ubuntu jammy-security multiverse */etc/apt/sources.list.d/*：该文件夹包含多个文件，每个文件名字可以是任意的，内如包含其软件源 1deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stable 在这两个位置就可以对软件源进行管理，修改后更新 1sudo apt update 密钥查看密钥1$ apt-key 添加密钥123sudo apt-key add 密钥值#举例wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - 删除密钥123456$ sudo apt-key del 密钥后8位#举例$ sudo apt-key del &quot;3820 03C2 C8B7 B4AB 813E 915B 14E4 9429 73C6 2A1B&quot;$ sudo apt-key del &quot;73C62A1B&quot;#删除后更新$ sudo apt update","link":"/2022/05/29/linux/ubuntu/Ubuntu%20%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"Siege","text":"Linux 中压力测试工具包包 网站压力测试工具包 Siege","link":"/2022/11/28/linux/%E5%B7%A5%E5%85%B7%E5%8C%85/Siege/"},{"title":"Linux 常用命令","text":"Linux 的常用命令介绍 Linux 常用命令文本操作写入文件1tee 文件 内容 选项 说明 -a 追加文件 文件管理创建文件夹1mkdir [options] 目录 选项 说明 -p 创建多级目录 打包解压1tar [options] 文件名.tar.gz 源文件 选项 说明 -x --extract 解压文件 -c --create 打包/压缩文件 -v --verbose 可视化，显示详细的tar处理的文件信息的过程 -f --file 要操作的文件名，该选项必须放在最后面 -C --directory=DIR 解压文件的目标路径，不写默认是当前目录 举例： 1234#打包/压缩tar -czvf xxx.tar.gz 源文件#解压tar -xzvf xxx.tar.gz -C 目标路径 网络命令下载文件1wget [options] [url] 选项 说明 -V –version 显示软件版本号然后退出 -O 指定保存的文件名字 第三方库ssh1ssh-keygen [options] 选项 说明 -t 指定密钥类型，默认为rsa -f 指定生成密钥的存储位置，目录不存在会自动创建，默认为*~/.ssh/id_rsa*","link":"/2022/12/01/linux/%E9%80%9A%E7%94%A8/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"WebRTC入门","text":"WebRTC入门 WebRTC简介WebRTC（全称 Web Real-Time Communication），即网页实时通信。 是一个支持网页浏览器进行实时语音对话或视频对话的技术方案。从前端技术开发的视角来看，是一组可调用的API标准。这个技术可以使很多不同的应用，如视频会议、文件传输、聊天和桌面共享等都不需要额外的插件。 媒体协商（SDP）：两个用户在连接之前相互确定并交换双方支持的音视频格式的过程就是媒体协商。SDP 是描述信息的一种格式，其格式组成可自行查找了解； 网络协商（candidate）：两个用户在 NAT 后交换各自的网络信息的过程就是网络协商。candidate 也是一种描述信息的一种格式，其格式组成可自行查找了解。 信令服务器：传递双方信息的服务器就是信令服务器，此服务其实就是 web 服务，其职责也不止传输媒体格式以及网络信息，还可传输业务信息。其传输信息的协议可是 HTTP 或 Socket 等。 STUN：STUN 是一种网络协议，其目的是进行 NAT 穿越。 TURN：TURN 是 STUN 协议的扩展协议，其目的是如果 STUN 在无法打通的情况下，能够正常进行连接，其原理是通过一个中继服务器进行数据转发，此服务器需要拥有独立的公网 IP。 ICE：ICE（Interactive Connectivity Establishment），是一种用于实现网络连接的技术框架，用于在对等连接（如实时通信、P2P 文件共享等）中解决 NAT（Network Address Translation）和防火墙等网络障碍的问题。 ICE 是一种框架，可以通过使用多种技术（如 STUN、TURN、NAT 透明性检测等）来搜索可用的网络路径，并选择最优的路径建立连接，从而解决了 NAT 和防火墙等网络障碍的问题。 连接流程WebRTC 链接建立流程包括： 创建 PeerConnection 并添加本地媒体流 通过信令服务器交 SDP 信息 通过ICE服务器交换 Candidate 信息 假设两个客户端为A和B，其整体流程为： 用户 A 和用户 B 都需要先连接到信令服务器； 用户 A 和用户 B 都创建一个 PeerConnection（此时 WebRTC 会自动向 STUN/TURN 服务获取 candidate 信息, WebRTC 内置了 ICE）； 用户 A 将本地音视频流添加到 PeerConnection 中（通过 getUserMedia 获取音视频流）； 用户 A 作为发起方创建 offer（offer 中包含了 SDP 信息），并将获取的本地 SDP 信息添加到 PeerConnection 中（setLocalDescription），然后再通过信令服务器转发给用户 B; 用户 B 接收到用户 A 的 offer 后，将其添加到 PeerConnection 中（setRemoteDescription）； 用户 B 将本地音视频流添加到 PeerConnection 中（通过 getUserMedia 获取音视频流）； 用户 B 创建一个 Answer，并添加到 PeerConnection 中（setLocalDescription）; 用户 B 通过信令服务器将 answer 转发给用户 A； 用户 A 接收到 answer 后将其添加到 PeerConnection 中； 用户 A 和 用户 B 都接收到了 candidate 信息后，都通过信令服务器转发给对方并添加到 PeerConnection 中（addIceCandidate）； 媒体信息和网络信息交换完毕后，WebRTC 开始尝试建立 P2P 连接； 建立成功后，双方就可以通过 onTrack 获取数据并渲染到页面上。 常用API GetUserMedia()：用于访问用户媒体输入设备的媒体流，可以通过传入 constraints 来指定需要的流信息，具体参考 MDN： 12// 获取音频和视频navigator.mediaDevices.getUserMedia({ audio: true, video: true }) RTCPeerConnection：RTCPeerConnection 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。 123456789101112131415let PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;let peer = new PeerConnection(iceServers);// iceServers 值为{ iceServers: [ { url: &quot;stun:stun.l.google.com:19302&quot;}, // stun服务器地址 {// turn服务器地址 url: &quot;turn:***&quot;, username: ***, // 用户名 credential: *** // 密码 } ]} addTrack：向要传输给对方的轨道集合中添加一个新的 MediaStreamTrack 1stream.getTracks().forEach((track) =&gt; peer.addTrack(track, stream)); createOffer：创建offer信息 createAnswer：创建answer信息 setLocalDescription：修改与连接关联的本地描述，此描述指定连接的本地端的连接属性，包括媒体格式。 setRemoteDescription：修改与连接关联的远程描述，此描述指定连接的远程端的连接属性，包括媒体格式。 addIceCandidate：向 RTCPeerConnection 的远程描述中添加一个新的远程候选者，描述连接的远程端的状态。 一对一连接部署 STUN/TURN 服务器 coturn 是 TURN 和 STUN Server 的免费开源实现。 TURN 服务器是 VoIP 媒体流量 NAT 遍历服务器和网关。 1docker run -d -p 3478:3478 -p 3478:3478/udp -p 5349:5349 -p 5349:5349/udp -p 49152-65535:49152-65535/udp coturn/coturn 信令服务器 信令服务器用于帮助多个客户端之间交换数据，协助建立连接，一般使用WebSocket实现客户端和服务端的通信，可以自定义逻辑，例如房间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const WebSocket = require(&quot;ws&quot;); const WebSocketServer = WebSocket.Server; const wss = new WebSocketServer({ port: 3001, });// 生成唯一ID function createId() { let e = () =&gt; Math.floor((1 + Math.random()) * 65536) .toString(16) .substring(1); return `${e()}${e()}-${e()}-${e()}-${e()}-${e()}${e()}`;}// 存储连接的客户端 const people = {};wss.on(&quot;connection&quot;, function (ws) { ws.on(&quot;message&quot;, function (message) { message = message.toString(); message = JSON.parse(message); switch (message.type) { case &quot;connect&quot;: // 将连接的客户端存储起来 const sessionId = createId(); people[sessionId] = { sessionId, ws, }; ws.send( JSON.stringify({ type: &quot;connect&quot;, data: sessionId, }) ); break; case &quot;call&quot;: // 将 sdp 发给接收端，sessionId 为 接收端的 id const sdp = message.data.sdp; const sId = message.data.sessionId; if (people[sId]) { people[sId].ws.send( JSON.stringify({ type: &quot;call&quot;, data: sdp, }) ); } break; case &quot;answer&quot;: // 接收端将 sdp 发给发起端，sessionId 为 发起端的 id const answerSDP = message.data.sdp; const recevId = message.data.sessionId; if (people[recevId]) { people[recevId].ws.send( JSON.stringify({ type: &quot;answer&quot;, data: answerSDP, }) ); } break; case &quot;getAllClients&quot;: ws.send( JSON.stringify({ type: &quot;getAllClients&quot;, data: Object.keys(people), }) ); break; } });}); 客户端 客户端的代码就主要使用浏览器的 WebRTC API，以及 WebSocket API，主要就是建立连接和设置媒体流的过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;WebRTC Example&lt;/title&gt; &lt;script src=&quot;./ws.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;WebRTC Example&lt;/h1&gt; &lt;video width=&quot;200&quot; height=&quot;200&quot; id=&quot;localVideo&quot; autoplay&gt;&lt;/video&gt; &lt;video id=&quot;remoteVideo&quot; autoplay&gt;&lt;/video&gt; &lt;br /&gt; &lt;button id=&quot;callButton&quot;&gt;Call&lt;/button&gt; &lt;script&gt; const peer = new RTCPeerConnection(); const ws = new WSS(&quot;ws://127.0.0.1:3001&quot;); ws.send({ type: 'connect' }) let localVideoElement = document.querySelector('#localVideo'); let remoteVideoElement = document.querySelector('#remoteVideo'); let callButton = document.querySelector(&quot;#callButton&quot;); // 获取本地音视频数据并将其添加到 peer 中 navigator.mediaDevices.getUserMedia({ audio: true, video: true }).then(stream =&gt; { // 将音视频设置到页面上 localVideoElement.srcObject = stream // 将音视频添加到 peer 中 stream.getTracks().forEach((track) =&gt; peer.addTrack(track, stream)); }) // 发起端点击call时创建offer并发送给接收端 callButton.onclick = () =&gt; { peer.createOffer().then(async offer =&gt; { await peer.setLocalDescription(offer) ws.send({ type: 'call', data: { sessionId: 'B', // 为了方便，这里写死 sdp: offer.sdp } }) }) } // 发起端收到answer sdp ws.subscribe('answer', async (data) =&gt; { const sdp = data.data await peer.setRemoteDescription({ type: 'answer', sdp }) }) // 接收端收到 offer sdp ws.subscribe('call', async (data) =&gt; { const sdp = data.data await peer.setRemoteDescription({ type: 'offer', sdp })- // 接收端创建answer并发送给发起端 peer.createAnswer().then(async answer =&gt; { await peer.setLocalDescription(answer) ws.send({ type: 'answer', data: { sdp:answer.sdp, sessionId: 'A' // 为了方便，这里写死 } }) }) }) peer.ontrack = (event) =&gt; { remoteVideo.srcObject = event.streams[0] } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2024/05/14/%E5%89%8D%E7%AB%AF/WebRTC/WebRTC%E5%85%A5%E9%97%A8/"},{"title":"Docker 常用命令","text":"Docker命令记录 Docker 常用命令镜像命令查看本地镜像1$ docker images [OPTIONS] [REPOSITORY[:TAG]] 选项： **-a :**列出本地所有的镜像，含中间映像层； **–digests :**显示镜像的摘要信息； **-q :**只显示镜像ID； 举例： 1$ docker images 搜索镜像1$ docker search 关键字 拉取镜像1$ docker pull [OPTIONS] NAME[:TAG|@DIGEST] 选项： **-a :**拉取所有name和tag匹配的镜像； **–disable-content-trust :**忽略镜像的校验，默认开启； 举例： 1$ docker pull kibana:7.10.1 删除镜像1$ docker rmi [OPTIONS] IMAGE [IMAGE...] 选项： **-f :**强制删除； **–disable-content-trust :**忽略镜像的校验，默认开启； 举例： 123$ docker rmi -f runoob/ubuntu:v4# 删除全部 none 镜像$ docker rmi $(docker images -f &quot;dangling=true&quot; -q) 容器命令创建并运行容器1$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 选项： -P：随机端口映射； -p/–publish：指定端口映射，格式为：主机端口:容器端口； -i：交互模式运行； d：后台运行容器，并返回容器ID； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； -e：设置环境变量； **–name=”xx”**： 为容器指定一个名称； –volume , -v： 绑定一个卷，主机目录:容器目录； –net/–network：指定容器连接到的网络； -h/–hostname：容器自己使用的主机名。如果未指定，则默认为容器的 ID； –dns： DNS 服务器的 IP 地址。要指定多个 DNS 服务器，请使用多个--dns标志。如果容器无法到达您指定的任何 IP 地址，8.8.8.8则会添加 Google 的公共 DNS 服务器，以便您的容器可以解析互联网域； 举例： 1234567$ docker run --name=&quot;elasticsearch&quot; -p 9200:9200 -p 9300:9300 \\ -e &quot;discovery.type=single-node&quot; \\ -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \\ -v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /data/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /data/elasticsearch/config/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.10.1 容器交互1docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 选项 说明 查看容器状态打印容器运行日志网络命令查看网络1$ docker network ls 创建网络1$ docker network create 网络名 删除网络1$ docker network rm 网络名 连接网络1$ docker network connect 网络名 容器名 断开网络1$ docker network disconnect 网络名 容器名 举例： 12# 创建覆盖网络$ docker network create -d overlay my-overlay 查看网络详细配置1$ docker network inspect 文件命令复制文件12docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH 说明： 无论是从主机复制到文件还是文件复制到主机，已存在的同名文件都会被覆盖； 举例： 1234# 容器-&gt;主机docker cp hadoop-test:root/.ssh/authorized_keys ./authorized_keys1# 主机-&gt;容器docker cp authorized_keys1 hadoop-test:root/.ssh/authorized_keys 其他命令获取版本1$ docker version","link":"/2022/05/29/%E5%B7%A5%E5%85%B7/Docker/Docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Docker 数据存储","text":"Docker网络模型及容器间通信 Docker 数据存储","link":"/2022/11/25/%E5%B7%A5%E5%85%B7/Docker/Docker%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"title":"Docker 网络概述","text":"Docker网络模型及容器间通信 Docker 网络概述docker网络模型如下： bridge：默认模式，当应用程序运行在独立容器中时通常使用该模式； host：直接使用宿主机的网络； none：该模式关闭了容器的网络功能； overlay：跨主机通信、集群； ipvlan：IPvlan 网络使用户可以完全控制 IPv4 和 IPv6 寻址； macvlan：会为每个容器分配一个 mac 地址，看起来像是直接连接到物理网络的网络接口； 桥接网络(bridge) 在计算机网络中，桥接网络指的是在网段之间转发流量的链路层设备，可以是硬件也可以是软件 在 docker 中，桥接网络使用软件桥接，允许连接到同一网桥网络的容器进行通信，同时与未连接到该网桥的容器相互隔离。 桥接网络适用于在同一 docker 守护进程主机上运行的容器。当启动 docker 时，会自动创建一个默认的桥接网络（名为 bridge），如果没有特别指定，那么新的容器会连接到它。 容器间通信创建容器时通过 –net/network 指定网络模型，若不指定默认为 bridge。无论使用哪个网络，在容器内都是透明的，从容器的角度看，它有一个带有ip地址的网络接口、一个网关、一个路由表、DNS 服务和其他网络细节（假设容器没有使用none网络驱动程序）。 默认情况下， Docker 守护进程有效地充当每个容器的 DHCP 服务器，会为每个连接到网络的容器分配一个 ip 地址（从网络池中分配）。 DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。 连接在默认的网络 bridge 上的容器之间可以通过ip地址进行相互通信，但无法通过名称进行通信，如果希望通过名称或别名进行通信，有如下方案： 使用 –link 参数（已废弃）； 进入容器手动修改 /etc/host 文件，比较麻烦； 用户自定义网桥（推荐方法），用户自定义的 bridge 自动提供了容器间的DNS解析功能，容器间可以通过容器名或别名进行通信； 自定义桥接网络 创建网络命令：docker network create 网络名 用户自定义的桥接网络优于默认的 bridge 网络。拥有如下功能： 提供容器之间的DNS解析：在用户自定义的桥接网络上，容器可以通过名称或别名相互解析； 提供更好的隔离：只有连接到同一网络的容器才能进行通信； 容器可以动态附加和离开：在容器的生命周期内，您可以动态地将其连接到用户定义的网络或断开连接； 暴露端口：连接到同一个用户定义的桥接网络的容器有效地相互暴露所有端口； 网络模式选择 多个容器在同一台docker主机上通信时，定义 bridge 网络是最佳选择； 容器网络不应该与主机隔离，容器的其他方面应该与主机隔离的情况下 host 模式最好； 当需要在不同的 docker 上运行容器并进行通信或当多个应用使用 swarm 服务协同工作时，overlay 最合适； 从虚拟机设置全职或需要容器看起来像网络上的物理主机时，macvlan 模式最好，每个主机都有一个唯一的 mac 地址； 第三方网络插件允许将 Docker 与专用网络堆栈集成； 网络配置信息使用命令可以查看网络的配置，以默认桥接网络bridge为例，查看配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ docker network inspect bridge[ { # 名字 &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;ff4c6b2700aceb81417565647918e117363b814bb33a984b1a2ea02f6b0deec3&quot;, &quot;Created&quot;: &quot;2022-11-19T23:56:28.748935833+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, # 网络模式 &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: { &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ { &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; } ] }, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: { &quot;Network&quot;: &quot;&quot; }, &quot;ConfigOnly&quot;: false, # 当前在本网络中正在运行的容器，容器不启动不会出现在这里 &quot;Containers&quot;: { &quot;1de88e922725a581ba95c2834058e6de0dfef4ca073310a2da4ddf7432c82b09&quot;: { &quot;Name&quot;: &quot;minio&quot;, &quot;EndpointID&quot;: &quot;9c0c5b02d933030a10238b531f108b9a52d885d65a181bb89bd8ac72e07aa0c2&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; } }, &quot;Options&quot;: { &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; }, &quot;Labels&quot;: {} }] 每个网络还有一个默认的子网掩码和网关","link":"/2022/11/19/%E5%B7%A5%E5%85%B7/Docker/Docker%20%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"title":"Dockerfile 概述","text":"Dockerfile指令 Dockerfile 概述Dockerfile 是用来构建镜像的一种方式，Dockerfile 文件中可以包含用户在命令行上调用和组合镜像的所有命令，内部命令的格式如下： 1指令 参数 指令不区分大小写 例如： 1RUN echo hello 指令参考FROMFROM指令用来初始化一个基础镜像，一个Dockerfile必须由FROM指令开始，指定的镜像可以是任何有效的镜像（本地或公共存储库均可）。FROM指令可以在一个Dockerfile中出现多次，每条FROM指令会开启一个新的构建阶段，上个阶段构建的镜像的ID会被输出。 123FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;] 选项： –platform：用来指定镜像的平台，比如linux/amd64、 linux/arm64或windows/amd64，如果不声明默认使用请求的目标平台； As name：为新的构建阶段指定名称，后面的其他命令可通过该名称引用本阶段构建的镜像； tag/digest：tag和digest是可选的，如果省略默认tag为latest； 举例： 1 ARG声明一个变量，可以在Dockerfile中的其他位置引用。 1ARG &lt;name&gt;[=&lt;default value&gt;] 说明： ARG可以声明在任意位置； 在 ARG指令定义之前，对变量的任何使用都会导致空字符串，定义后后面的赋值会覆盖前面的； 举例： 123456ARG param1# 设置默认值ARG param2=someuser# 使用变量RUN echo $user 预定义ARGDocker 有一组预定义的ARG变量，可以在Dockerfile中没有相应ARG指令的情况下使用这些变量： HTTP_PROXY http_proxy HTTPS_PROXY https_proxy FTP_PROXY ftp_proxy NO_PROXY no_proxy ALL_PROXY all_proxy ENV设置环境变量 1ENV &lt;key&gt;=&lt;value&gt; ... 说明： 设置的环境变量在后续的所有构建阶段中生效； 可以省略=； 举例： 1234567ENV MY_NAME=&quot;John Doe&quot;ENV MY_DOG=Rex\\ The\\ Dog# 省略=号（此时只能声明一个环境变量）ENV MY_CAT fluffy# 设置多个ENV MY_NAME=&quot;John Doe&quot; MY_DOG=Rex\\ The\\ Dog \\ MY_CAT=fluffy RUN在当前镜像层上执行任意命令 123RUN &lt;command&gt;# exec格式RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] 说明： 使用\\运行多行命令； 选项： exec格式的中的参数不掉用shell，不会进行变量替换； RUN指令的缓存默认不会在下一次构建期间自动失效，如果希望失效需要在执行时使用--no-cache参数 1$ docker build --no-cache 指令的缓存RUN可以由指令ADD和COPY指令使之失效； 举例： 12345678# sh格式RUN /bin/bash -c 'source $HOME/.bashrc; \\echo $HOME'# 用;合并RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'# exec格式RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;] CMD为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束，可以被docker run命令行参数中指定要运行的程序覆盖 123456# exec 格式CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] # 作为 ENTRYPOINT 的默认参数CMD [&quot;param1&quot;,&quot;param2&quot;]# shell 格式CMD command param1 param2 说明： 一个Dockerfile中只能有一条CMD指令，如果列出多个，则只有最后一个会生效； ENTRYPOINT1234# exec格式（推荐）ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# shell格式ENTRYPOINT command param1 param2 LABEL将标签元数据加入到镜像中。 1LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... 举例： 12345678LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;LABEL com.example.label-with-value=&quot;foo&quot;LABEL version=&quot;1.0&quot;# 使用\\表示多行LABEL description=&quot;This text illustrates \\that label-values can span multiple lines.&quot;# 一行内指定多个labelLABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3&quot; EXPOSE指定容器运行是监听的网络端口 1EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] 说明： EXPOSE实际上并不发布或映射端口，知识作为构建镜像的人和运行容器的人之间的一种文档，真正发布哪些端口要在运行容器时确定； 选项： protocol：可以指定是TCP还是UDP，不指定默认是TCP； 举例： 1EXPOSE 80/tcp 以运行时发布和映射端口为准 1$ docker run -p 81:81/tcp ADD用于将src位置下的文件、目录、远程文件的URL复制到镜像文件系统中的dest位置 12ADD [--chown=&lt;user&gt;:&lt;group&gt;] [--checksum=&lt;checksum&gt;] &lt;src&gt;... &lt;dest&gt;ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 说明： 如果容器根文件系统不包含/etc/passwd或 /etc/group文件，并且标志中使用了用户名或组名--chown ，则构建操作将失败ADD。 如果&lt;src&gt;是可识别的压缩格式（identity, gzip, bzip2 或 xz)）的本地tar文件，则会将其解压为目录，来自url的资源不会被解压缩； 如果&lt;src&gt;是目录，则复制目录的全部内容，包括文件系统元数据。 选项： –chown：仅在用于构建linux容器的Dockerfile上支持，表示指定文件的所有权，如果不填默认为都为0； src：相对于构建目录的目录、文件，也可以是一个网络上的url。可以包含通配符，可以指定多个src； dest：镜像的文件系统中的位置，可以是绝对路径或相于WORKDIR的相对路径； 举例： 1234567# ?会被匹配为任意单个字符ADD hom?.txt /mydir/# 指定所有权ADD --chown=55:mygroup files* /somedir/ADD --chown=bin files* /somedir/ADD --chown=1 files* /somedir/ADD --chown=10:11 files* /somedir/ ADD –Linktodo COPY从&lt;src&gt;路径处复制文件到容器的文件系统的&lt;dest&gt;位置 12COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 具体参照ADD指令，区别如下： COPY不支持url资源； ADD可以自动解压压缩文件； COPY –link参照 ADD --link VOLUME创建挂载点 1VOLUME [&quot;/data&quot;] 说明： 在Windows上的目的地必须满足以下条件之一： 一个不存在的或空的目录； C盘以外的位置； 因为不能保证主机上的目录在所有镜像中都可用，所以VOLUME指令不支持指定host-dir 参数。您必须在创建或运行容器时指定挂载点。 WORKDIRWORKDIR用来为RUN、CMD、ENTRYPOINT、COPY 、 ADD指令设置工作目录 1WORKDIR 路径 说明： 如果未指定WORKDIR默认位置为 / ； 如果路径不存在则会自动创建； 如果设置了多个WORKDIR则后一条是相对于上一条的相对路径 1234WORKDIR /aWORKDIR b# 输出/a/bRUN pwd WORKDIR可以使用前面设置的ENV 123ENV DIRPATH=/pathWORKDIR $DIRPATH/$DIRNAMERUN pwd USER指定用户名（或UID）和可选的用户组（或group）用作当前阶段剩余部分的默认用户和组。指定的用户用于RUN指令，并在运行时运行相关ENTRYPOINT和CMD命令。 12USER &lt;user&gt;[:&lt;group&gt;]USER &lt;UID&gt;[:&lt;GID&gt;] 说明： 为用户指定组时，用户将只有指定的组成员资格。任何其他已配置的组成员身份都将被忽略；","link":"/2022/11/29/%E5%B7%A5%E5%85%B7/Docker/Dockerfile%20%E6%A6%82%E8%BF%B0/"},{"title":"Elasticsearch EQL","text":"EQL表示事件查询语言，在索引上添加了事件信息（时间戳和事件类型字段），主要用于处理文档之间的事件关系，例如根据日志信息查询一个用户，该用户先进行了注册，然后又进行了登录。 用于在数据之间建立关系，类似SQL 1234567GET 索引名/_eql/search{ &quot;query&quot;:&quot;&quot;&quot; //这里写EQL &quot;&quot;&quot;}","link":"/2024/07/14/%E5%B7%A5%E5%85%B7/Elasticsearch/Elasticsearch%20EQL/"},{"title":"Elasticsearch SQL","text":"Elasticsearch支持将SQL语言，底层会将其翻译成DSL。 使用_sql表示执行SQL操作，?后接参数，主要包括： format：返回结果集的格式 translate：展示翻译后的DSL语句123456789GET _sql?format=txt{ &quot;query&quot;:&quot;&quot;&quot; SELECT * FROM &quot;索引名&quot; WHERE 条件 &quot;&quot;&quot;}","link":"/2024/07/14/%E5%B7%A5%E5%85%B7/Elasticsearch/Elasticsearch%20SQL/"},{"title":"Elasticsearch 搜索","text":"Elasticsearch中的条件查询和聚合查询。 分词操作123456GET _analyze{ // 指定分词器 &quot;analyzer&quot;:&quot;分词器&quot;, &quot;text&quot;:[&quot;文本&quot;]} 条件搜索1. 全量搜索1GET 索引名/_search 2. 无条件查询 match_all：无条件查询123456{ &quot;query&quot;: { &quot;match_all&quot;: { } }} 3. 范围查询 range：对数值类型进行范围查询； gt：&gt;； lt：&lt;； gte：&gt;=； lte：&lt;=；12345678910{ &quot;query&quot;: { &quot;range&quot;: { &quot;age&quot;: { &quot;gte&quot;: 20, &quot;lt&quot;:40 } } }} 4. 短语匹配 match_phrase：也会分词，但查询时文档中词的顺序需要与短语中词的顺序一致1234567891011{ &quot;query&quot;: { &quot;match_phrase&quot;: { &quot;title&quot;: { &quot;query&quot;: &quot;Elasticsearch 中文&quot;, // 指定关键词之间最大距离不能超过2 &quot;slop&quot;: 2 } } }} 5. 分词搜索 match：会先分词，然后匹配查询123456789GET 索引名/_search{ &quot;query&quot;:{ &quot;match&quot;:{ # 条件 name:&quot;张三&quot; } }} 6. 精确匹配 term：不会进行分词12345678GET 索引名/_search{ &quot;query&quot;:{ &quot;term&quot;:{ name:&quot;张三&quot; } }} terms：是 term 查询的扩展，允许一次性检索多个精确值（或逻辑）。12345678GET 索引名/_search{ &quot;query&quot;:{ &quot;terms&quot;:{ name:[&quot;张三&quot;,&quot;李四&quot;] } }} 7. 指定返回字段 _source：指定返回的字段1234567GET 索引名/_search{ &quot;_source&quot;:[&quot;name&quot;,&quot;age&quot;], &quot;query&quot;:{ //... }} 8. 多条件拼接 bool：拼接多个条件； should：or； must：and； must_not：not； 123456789101112131415161718GET 索引名/_search{ &quot;_source&quot;:[&quot;name&quot;,&quot;age&quot;], &quot;query&quot;:{ &quot;bool&quot;:{ &quot;must&quot;: { &quot;match&quot;: { &quot;age&quot;: 10 }}, &quot;must_not&quot;: { &quot;match&quot;: { &quot;name&quot;: &quot;王五&quot; }}, &quot;should&quot;:{ &quot;match&quot;:{ &quot;name&quot;:&quot;张三&quot; }, &quot;match&quot;:{ &quot;name&quot;:&quot;李四&quot; } } } }} 9. 结果排序 sort：使用指定字段排序 desc：降序 asc：升序12345678910111213GET 索引名/_search{ &quot;query&quot;:{ //... }, &quot;sort&quot;:[ { &quot;age&quot;:{ &quot;order&quot;:&quot;desc&quot; } } ]} 10. 分页查询 from：从第几条开始； size：返回文档数量；12345678GET 索引名/_search{ &quot;query&quot;:{ //... }, &quot;from&quot;:0, &quot;size&quot;:10} 聚合操作 aggs：声明聚合操作 terms：分组12345678910GET 索引名/_search{ &quot;aggs&quot;:{ &quot;自定义名称&quot;:{ &quot;terms&quot;:&quot;age&quot; } }, // 不返回数据，只会返回聚合结果 &quot;size&quot;:0} sum：求和 avg：平均值123456789101112131415161718GET 索引名/_search{ &quot;aggs&quot;:{ &quot;自定义名称&quot;:{ &quot;terms&quot;:&quot;age&quot; }， // 嵌套聚合方法 &quot;aggs&quot;:{ &quot;自定义名称&quot;:{ // 指定聚合操作 &quot;sum&quot;:{ // 指定字段 &quot;field&quot;:&quot;age&quot; } } } },} top_hits：只定前几名123456789101112131415GET 索引名/_search{ &quot;aggs&quot;:{ &quot;自定义名称&quot;:{ &quot;top_hits&quot;:{ // 添加排序（可选） &quot;sort&quot;:[ //... ] // 前三名 &quot;size&quot;:3 } }， },}","link":"/2024/07/14/%E5%B7%A5%E5%85%B7/Elasticsearch/Elasticsearch%20%E6%90%9C%E7%B4%A2/"},{"title":"Elasticsearch 概念","text":"Elasticsearch 的基本概念 1. 数据库结构 索引（Index）：对应表（Table） 文档（Document）：对应行（Column） 字段（Field）：对应列（Row） 映射（Mapping）：对应表结构（Schema），是索引的约束 2. 分片（Shards）Elasticsearch中可以将索引划分为多个分片，每个分片是一个独立的Luence索引，分片可以放在集群中任意节点上，Elasticsearch 支持分布式查询，分片的位置由主节点管理 分片的数目在创建索引时确定，之后无法更改 一个节点失效后会等待一段时间，然后再重新创建分片和副本，可以修改delayed_timeout修改等待时间 2.1. 写流程 客户端请求集群节点（任意）作为协调节点 协调节点将请求转发到指定节点 写入主分片 更新副本 副本保存后，返回写入成功可选项： 一致性：可以写入分片后直接返回，之后再更新副本 超时时间：没有足够副本可能会等待，可以设置超时时间 2.2. 读流程 客户端请求集群节点（任意）作为协调节点 协调节点通过负载均衡策略将请求转发到具体的的分片和副本 返回结果 2.3. 更新流程 更新分片 更新副本 3. 副本（Replicas）Elasticsearch中可以为索引指定副本，提高可用性，副本也是按分片来保存的，例如一个索引有三个分片，那么他的每个分片都会有对应的副本，的位置由主节点指定 副本的数目在索引创建后也可以更改 分片和该分片的副本不会存在同一机器上 4. 分析器用于分词，Elasticsearch提供了标准分词器，按空格分词，也可以指定其他分析器 5. 并发冲突当多个用户对同一文档更新时可能导致更新被覆盖，Elasticsearch使用乐观锁， 老版本中，每个文档有一个_version版本号，新版本中，增加了_seq_no和_primary_term，其作用为： _version：记录文档版本，只有当前文档的更新，该字段才会累加； _seq_no：记录索引版本，只要索引中的文档有更新，就会累加该字段值； _primary_term：记录分片版本，针对故障导致的主分片重启或主分片切换，每发生一次自增1；","link":"/2023/10/18/%E5%B7%A5%E5%85%B7/Elasticsearch/Elasticsearch%20%E6%A6%82%E5%BF%B5/"},{"title":"Elasticsearch 文档","text":"Elasticsearch文档操作以及批量操作。 概念1. 评分机制查询文档时，每个文档都会根据计算公式计算_score字段，表示得分，分数高的排名越靠前 文档操作1. 保存文档Elasticsearch中创建和更新文档的接口是一样的，如果指定了_id并且该文档已存在，那么就会更新文档数据 创建或更新12345PUT 索引名/_doc/唯一标识{ &quot;id&quot;:1, &quot;name&quot;:&quot;tom&quot;} 使用POST可以不指定_id，会创建文档并自动生成_id； 如果指定_id，那么和PUT一样；12345POST 索引名/_doc[/唯一标识]{ &quot;id&quot;:1, &quot;name&quot;:&quot;tom&quot;} 2. 批量保存批量保存或修改 1234567PUT /_bulk{&quot;index&quot;{&quot;_index&quot;:&quot;索引名&quot;,&quot;_id&quot;:&quot;唯一标识&quot;}}# 文档内容{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:11}{&quot;index&quot;{&quot;_index&quot;:&quot;索引名&quot;,&quot;_id&quot;:&quot;唯一标识&quot;}}{&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:12}//重复上面两行... 3. 删除文档1DELETE 索引名/_doc/唯一标识 4. 批量删除1234POST /_bulk{&quot;delete&quot;:{&quot;_index&quot;:&quot;索引名&quot;,&quot;_id&quot;:&quot;唯一标识&quot;}}{&quot;delete&quot;:{&quot;_index&quot;:&quot;索引名&quot;,&quot;_id&quot;:&quot;唯一标识&quot;}}//... 5. 查询文档根据_id查询数据 1GET 索引名/_doc/唯一标识","link":"/2024/07/14/%E5%B7%A5%E5%85%B7/Elasticsearch/Elasticsearch%20%E6%96%87%E6%A1%A3/"},{"title":"Elasticsearch 索引","text":"Elasticsearch索引操作和索引模板。 概念1. 倒排索引正向索引：主键-&gt;数据-&gt;字段，通过主键查询索引，然后找到数据条目，最后找到需要的字段倒排索引：单词-&gt;文档，使用单词找到对应文档，适合快速全文搜索 1.1. 搜索流程 词条：索引中最小的存储单元，指通过分词得到的关键词 词典：词条的集合，底层一般使用B+树、哈希表存储 倒排表：索引和文档的对应关系 1.2. 索引底层Elasticsearch中的倒排索引被写入磁盘后时不可变的，有以下优点： 不需要锁：因为不会更新索引 索引的缓存和其他缓存（如filter）会一直有效 写入大的倒排索引时允许被压缩不可变会导致在更新时需要重新构建整个索引，因此Elasticsearch使用补充索引的方式更新文档， 索引被分为多个段（Segment），新的段保存较新的数据， 没过固定时间（1s）就会将段刷写（flush）到系统缓冲区，再由系统缓冲区刷写到硬盘（定时30min或translog大于512mb），刷写到系统缓冲区的数据才能被检索 为防止当段太多，后台会定期进行段合并 添加或更新时会生成新的补充索引来表示最新的数据 删除时使用删除标记为表示删除 每个倒排索引都会被轮流查询到，从最早的开始查询完后再对结果进行合并 为防止数据丢失，数据再写入内存后会被写入Translog中然后持久化，等段写入磁盘时再清空 索引操作1. 创建索引索引创建后就不允许修改 12345678PUT 索引名称#索引的配置（可选）{ # 设置别名 &quot;aliases&quot;:{ &quot;别名&quot;:{} }} 2. 查询索引查询指定索引 1GET 索引名称 查询数据库中所有索引 1GET _cat/indices 判断索引是否存在 1HEAD 索引名称 3. 删除索引1DELETE 索引名称 模板操作1. 创建模板可以将索引配置创建为一个模板，便于创建索引时使用 12345678910111213PUT _template/模板名{ // 生效索引前缀 &quot;index_patterns&quot;:{ &quot;xxx&quot; }, &quot;settings&quot;:{ // 索引配置 }, &quot;mappings&quot;:{ // 数据映射配置 }} 2. 搜索模板1GET _template/模板名 3. 删除模板1DELETE _template/模板名","link":"/2024/07/14/%E5%B7%A5%E5%85%B7/Elasticsearch/Elasticsearch%20%E7%B4%A2%E5%BC%95/"},{"title":"Kubernetes 架构及概念","text":"kubernetes 使用主从结构管理集群，本章介绍主从节点上的相关组件及概念 Kubernetes 架构Kubernetes 的架构图如下所示 由图中可以看出，Kubernetes 主要由 一系列组件组成，其中核心组件包括etcd、apiserver、controller manager、scheduler、kubelet、Container runtime 和 kube-proxy。节点分为 Master和 Node，他们的组件各不相同，Master主要用于对集群进行管理，而 Node用来部署服务。 MasterMaster负责管理整个集群，协调集群中的所有活动，例如调度应用、维护应用所需的状态、应用扩展以及推出新的更新。 Apiserverapiserver 是 Kubernetes 中向外提供的接口，任何资源的操作都需要以 apiserver 作为入口。此外 apiserver 还提供了认证、授权、访问控制、API注册和发现的机制 Etcdetcd 是一个用来存储键值对形式数据的分布式数据库。在 Kubernetes 中 etcd 一般以集群的形式被部署，用于向 Kubernetes 提供键值对数据的存储服务。Kubernetes 会通过它保存整个集群的状态信息。 Controller Managercontroller manager 用于管理集群中的各种控制器，这些控制器的功能包括维护集群的状态，比如故障检测、自动扩展、滚动更新等。这些控制器包括 节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应。 任务控制器（Job controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成。 端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）。 服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌。 node controller（节点控制器）节点控制器（node controller）是管理节点的Master组件，用来控制Node，它有如下作用： 在注册时为Node分配CIDR格式的地址空间 使节点控制器的内部列表与可用机器列表保持最新 检测Node的健康状态，当有Node不健康时会根据当前不健康Node所占的百分比来对Node进行驱逐（转移到健康节点） schedulerscheduler 负责资源的调度，按照配置文件中设定的调度策略将 Pod 调度到相应的机器上。 NodeNode是Kubernetes中的工作节点（一台虚拟机或物理机），以前也被称为minion。Node的目的就是保证对其上运行的Pod进行管理，每个Node拥有运行Pod的必要服务并由Master进行管理。Node的组件包括 kube-proxy 和 Container runtime。 Node状态Node的状态信息包括： Addresses：取决于云提供商和主机配置 选项 说明 HostName 包含主机名，可以通过kubelet 中 --hostname-override参数覆盖 ExternalIP 可以被集群外部路由到的IP InternalIP 只能在集群内部路由的节点IP Condition：描述所有Running节点的状态 Node状态 说明 OutOfDisk True代表节点上没有足够空间来增加新的Pod，反之为False Ready True：节点是健康的并且准备号接收PodFalse：节点不健康且不接收PodUnKnown：节点控制器在过去40秒内没收到Node的状态报告 MemoryPressure True代表节点内存过低，反之为False DiskPressure True代表节点磁盘容量低，反之为False Capacity：描述Node上的可用资源：CPU、内存、可容纳的最大Pod数 Info：Node的基础信息，如内核版本、Kubernetes版本、Docker版本等 Node会定期与Master的apiserver进行通信发送状态报告，如果Node发送的状态中的condition为Unknown或长时间没有发送状态报告，那么节点控制器就会将该Node上的所有Pod标记并计划将这些被标记Pod再分配到其他Node上。在1.5版本之前的Kubernetes中会将这些Pod直接删除，如果此时Node与apiserver无法进行通信，那么会等可以通信时再删除。 Node组件kube-proxykube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 kube-proxy是一个分布式的代理服务器，部署在每个Node节点上，为集群提供负载均衡和服务发现的能力。思考一下，在Kubernetes集群中，一个微服务可能部署在多个Pod上，那么用户访问时究竟要访问哪个呢？此时 kube-proxy就充当了负载均衡器的职责，一个Service API对象会对应着一个集群内部的有效虚拟ip，集群内可以通过这个虚拟ip来访问一个服务，这个过程中kube-proxy会为 Service 提供内部的服务发现和负载均衡。 Container runtimeContainer runtime 是负责运行容器的软件。 kubeletkubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理。 Node容量节点的容量（CPU数量和内存数量）是节点对象的一部分。通常，节点在创建节点对象时注册并通知其容量。 Master-Node通信Node-&gt;Master集群中的Node想要访问Master节点只有一个接口，就是apiserver。在进行通信时保证安全的连接到apiserver，所以一需要为Node配置证书。 Master-&gt;NodeMaster连接Node有两种方式： 从apiserver到kubelet：默认不需要证书 从apiserver到Node、Pod、Service：默认使用HTTP连接，不需要证书，如果需要安全证书可以使用HTTPS连接。 Kubernetes 概念Kubernetes 是一个分布式系统拥有一套自己的设计理念，下面将分别对 Kubernetes 的设计原则和核心概念进行介绍 API设计原则 Kubernetes 中 API 的设计都是声明式的，即通过配置文件的方式而不是命令式，这样尽可能的隐藏了实现细节，更便于用户的使用。 在Kubernetes中API可以分为高层API和底层API，高层API以业务角度出发，针对系统调度管理容器的操作意图为基础而设计，底层API根据高层API的需要而设计，目的是更好的被高层API所使用，提高复用性。在设计API的过程中Kubernetes尽量避免没有提供新功能的简单封装，因为这回增加系统的依赖。 由于网络因素是不可控制的，所以Kubernetes中的API是不依赖网络的。由于Kubernetes维护的是一个居群，所以保证集群的全局状态同步时非常困难的，所以Kubernetes的API也不能依赖全局状态。","link":"/2022/05/10/%E5%B7%A5%E5%85%B7/Kubernetes/Kubernetes%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%A6%82%E5%BF%B5/"},{"title":"Kubernetes 核心技术","text":"Kubernetes 提供了一系列核心组件并通过API对象来管理集群，本章介绍开发过程中直接使用到的组件的相关概念 API对象Kubernetes中的任何管理操作都是使用API进行的。Kubernetes引入的每一个新技术都会新引入对应的API对象。配置文件和控制都与API对象密切相关，常用的API对象如下所示： API功能 API对象 作用 副本控制器 RC 保证集群中有指定数量的Pod副本 副本集 RS 新一代的RC，功能RC，支持集合匹配 部署 Deployment 用来新建或升级一个服务 服务 Service 配合kube-proxy完成服务发现和负载均衡功能 任务 Job 用来控制单Pod或多Pod的批处理任务的执行 存储卷 Volume 和Docker的Volume类似，只不过作用范围是一个Pod，用于这个Pod内的文件目录挂载 节点 Node 所有Pod运行所在的工作主机 命名空间 Namespace 提供虚拟隔离作用 API对象的三大属性每个API对象都有3大属性： 元数据（metadata）：metadata是用来标记API对象的，每个API对象都至少有3个元数据，除此之外还可以使用标签（labels）来表示和匹配不同对象： Namespace：Namespace用于将集群资源划分为多个Namespace分配指定的资源，在本Namespace中声明的Pod必须遵守和Namespace一样的资源限制。相同的Namespace中的对象将具有相同的访问控制策略。大多数Kubernetes资源（Pod、services、replication controllers等）都在某些Namespace中，但Namespace资源本身并不在Namespace中。而低级别资源（如Node和persistentVolumes）不在任何Namespace中。Events是一个例外：它们可能有也可能没有Namespace，具体取决于Events的对象。 Name：在一个Namespace内Name是唯一的。 UID：在Kubernetes集群中每个对象的UID是唯一的。 规范（spec）：spec描述了用户期望Kubernetes集群中的分布式系统达到的理想状态，例如期望每个Pod的副本数为3；Kubernetes中所有的配置都是通过API对象的spec设置的。 状态（status）：status描述了当前系统的状态，例如期望Pod副本数为3，而当前Pod副本数为2，那么之后就会启动新的Pod争取达到3个副本。 LabelsLabels是一对Key/Value形式的键值对，一般用来标记一组有共同特点的API对象，声明在对象的metadata部分。可以在创建API对象时声明，也可以在后期随时修改。每个API对象可拥有多个Label，但Label的key必须是唯一的。Labels的书写格式如下： key由前缀和名称组成，之间用/分隔。其中前缀是可选的，如果选择使用前缀，那么必须是DNS子域，通过.划分，不能超过253个字符。名称的书写格式与value一样。 value最多63个字符，以[a-z0-9A-Z]带有虚线（-）、下划线（_）、点（.）组成，并且开头和结尾必须是字母或数字。 Labels Selector通过标签选择器（Labels Selectors），客户端/用户能方便辨识出一组对象。标签选择器是kubernetes中核心的组成部分。当前支持两种标签选择器： equality-based（基于相等）：通过=，==和!=三种运算符判断相等性，=和==含义相同 12env = production #所有存在key为env，且value为production的资源env != production #所有存在key为env，且value不为production的资源 + 所有不存在key为env的资源 set-based（基于集合）：in ， notin 和 exists(仅针对于key符号)判断标签，逗号（,）代表and。 1234env in (production, test) #所有key为env，且value为production或test的资源env notin (production, test) #所有key为env，且value不为production和test的资源 + 所有不包含key为env的资源env #所有存在一个key为env的资源!env #所有不存在key为env的资源 set-based和equality-based可以结合使用，例如： 1env = pro,partition in (A,B) 配置文件中API对象的引用也是有标签选择器来指定其他资源的集合。 Volume Docker中的Volume是将磁盘中的一个目录和容器内的目录形成一个映射关系，达到挂载文件夹的效果，没有明确的声生命周期。而Kubernetes的Volume是具有生命周期的（与Pod相同），所以Volume会比Pod中的任何容器运行的都持久，当pod内的容器被重新启动时也能保留数据，当Pod被删除时Volume也会消失。 在Kubernetes使用Volume需要指定Volume的类型和内容。Volume支持很多类型，不同类型就是指将不同位置的文件夹路径挂载到Kubernetes，比如本机、云上、分布式文件系统等。下面介绍Volume中常用的Volume类型 emptyDir当Pod被分配到Node上时，emptyDir会被创建，当Pod被从Node上删除时，emptyDir也被同时删除，所以一般用于缓存。 hostPathhostPath应用于将Node的文件系统挂载到Pod上，一般当Pod需要用到本机文件时使用。 PodPod是Kubernetes用来管理和部署的最小基本单位，一个Pod代表集群上一个正在运行的进程，其内可包含一个或多个容器 Pod内运行一个容器：可以把pod当作是一个容器，但Kubernetes管理的仍是Pod而不是容器。 Pod内运行多个容器：多个容器需要一起工作，他们之间可以共享资源，网络（IP地址和端口）和存储（一组共享存储volumes），推荐只在多容器紧密耦合的情况中使用。 ServiceService通过selector和一组Pod产生关联。Kubernetes在创建Service时endpoint controller会根据Service关联到的Pod的IP信息生成一个与Service同名的Endpoint对象。如果没有指定selector，则创建Service时不会自动生成Endpoints对象，需要通过手动构造Endpoints或EndpointSlice。Endpoints的信息存储在etcd中，用来记录一个service对应的所有pod的访问地址。 DeploymentDeployment为Pod和RS提供声明式更新。只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会自动将 Pod 和ReplicaSet 的实际状态改变到您的目标状态。 JobJob是用来在Kubernetes中进行批处理任务的API对象。任务标志完成后就退出，不会用不停止的运行下去。根据指定的策略不同，完成条件也不同，比如有一个Pod执行成功就标志完成或者N个任务全部完成再退出。 StatefulSets在具有以下特点时使用StatefulSets： 稳定性，唯一的网络标识符。 稳定性，持久化存储。 有序的部署和扩展。 有序的删除和终止。 有序的自动滚动更新。 Replication Controller，RCRC跨多个Node节点监视多个Pod，其作用如下： RC用来确保集群中Pod的副本数，如果Pod过多，则RC会终止额外的Pod，如果Pod过少，则RC会创建新的Pod，使Pod副本数一直处在指定的范围内。 RC会替换由于某些原因而被删除或终止的Pod。 Replica Set，RSRS时RC的升级版，它们之间的唯一区别是RS强化了对选择器的支持，RS可以使用equality-based和set-based两种方式，而RC只能使用set-based方式。RS可以独立使用，但主要与Deployment配合使用。Deployment会对ReplicaSet对象进行管理。","link":"/2022/05/15/%E5%B7%A5%E5%85%B7/Kubernetes/Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"title":"Kubernetes 部署","text":"Kubernetes部署方式 Minikube部署安装过程Minikube用于部署单节点K8s集群，需要先安装完docker 123456789101112131415161718192021# 安装 minikube，使用rpm包安装$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm$ sudo rpm -Uvh minikube-latest.x86_64.rpm# 验证安装$ minikube version# 安装 kubectl$ minikube kubectl# 启动，可以自己指定版本，镜像国家cn默认从阿里云拉取镜像$ minikube start --kubernetes-version=v1.23.3 --image-mirror-country='cn'# $ minikube kubectl -- get pods -A# 设置别名$ vim .bashrc# 在文件末尾添加：alias kubectl=&quot;minikube kubectl&quot;$ source .bashrc# 验证$ kubectl get nodes# 配置命令补全$ sudo dnf install bash-completion$ source /usr/share/bash-completion/bash_completion$ source &lt;(kubectl completion bash) 接下来就可以使用kubectl命令进行操作了","link":"/2022/09/17/%E5%B7%A5%E5%85%B7/Kubernetes/Kubernetes%E9%83%A8%E7%BD%B2/"},{"title":"Kubernetes 配置及命令","text":"使用 kubernetes 时主要通过命令和配置文件的方式描述核心组件操作 API 对象的目标状态，本篇介绍核心技术中各个组件的不同配置方式 kubectl工具支持三种对象管理方式： 命令式对象管理：使用一条条指令操作对象 命令式对象配置：通过命令配置和配置文件操作对象 声明式对象配置：通过apply命令和配置文件操作对象 命令式对象管理使用kubectl命令行工具提供的指令对对象进行管理，语法格式如下： 1kubectl [command] [type] [name] [flags] command：执行的操作 type：对象的类型 name：指定对象的名称，大小写敏感 flags：额外的参数 说明： 为节省位置，后文列出的命令都省略了kubectl。 常用对象 对象分类 对象名称 缩写 对象作用 集群级别对象 nodes no 集群组成部分 namespaces ns 隔离Pod pod对象 pods po 装载容器 pod对象控制器 replicationcontrollers rc 控制pod对象 replicasets rs 控制pod对象 deployments deploy 控制pod对象 daemonsets ds 控制pod对象 jobs 控制pod对象 cronjobs cj 控制pod对象 horizontalpodautoscalers hpa 控制pod对象 statefulsets sts 控制pod对象 服务发现对象 services svc 统一pod对外接口 ingress ing 统一pod对外接口 存储对象 volumeattachments 存储 persistentvolumes pv 存储 persistentvolumeclaims pvc 存储 配置对象 configmaps cm 配置 secrets 配置 常用指令 命令分类 命令 命令作用 基本命令 create 创建对象 edit 编辑对象 get 获取对象 patch 更新对象 delete 删除对象 explain 展示对象文档 运行和调试 run 在集群中运行一个指定的镜像 expose 暴露对象为Service describe 显示对象内部信息 logs 输出容器在 pod 中的日志 attach 进入运行中的容器 exec 执行容器中的一个命令 cp 在Pod内外复制文件 rollout 管理对象的发布 scale 扩(缩)容Pod的数量 autoscale 自动调整Pod的数量 高级命令 apply 通过文件对对象进行配置 label 更新对象上的标签 其他命令 cluster-info 显示集群信息 version 显示当前Server和Client的版本 api-versions 查看apiVersion 命令式对象配置命令式对象配置是使用配置文件和命令想结合的方式管理对象。操作步骤如下： 首先编写配置文件，配置文件内包含对对象的声明和约束 使用命令执行配置文件进而操作对象 常用命令 命令 命令作用 create -f &lt;filename|url&gt; 创建对象 replace -f &lt;filename|url&gt; 更新对象 delete -f &lt;filename|url&gt; 删除对象 get -f &lt;filename|url&gt; -o yaml 查看对象 声明式对象配置声明式对象配置是将所有对于对象的描述都声明在配置文件中，只需要执行apply命令执行配置文件目录，Kubernetes会创建指定目录中配置文件所定义的所有对象除非对应对象已经存在： 常用命令 命令 命令作用 apply -f &lt;目录/&gt; 创建/更新对象，添加-R可以递归地处理目录 diff -f &lt;配置文件|目录/&gt; 打印出将被创建的对象 get -f &lt;配置文件&gt; 打印现时配置 delete -f &lt;文件名&gt; 删除对象 在使用apply命令后也可以手动使用命令来更新集群的配置，比如使用scale进行扩容时，当前最新的配置就叫现时配置。 配置文件Kubernetes配置文件可以为YAML或JSON，官方推荐使用YAML。配置文件中有如下基本项 12345apiVersion: v1 #使用的api版本，一般为v1，代表的稳定版本kind: Pod #对象的类型metadata: #对象的元数据，如namespace、name、label等spec: #指定对象的目标状态，对于不同类型的对象也有不同的值status: #对象的当前状态，不需要 Workload APIPod 配置123456789101112131415161718192021222324252627282930apiVersion: v1kind: Podmetadata: name: Pod—examplespec: #Pod包含的容器列表，一个Pod中至少要有一个容器 containers: #容器名称 - name: con-name #指定镜像 image: image #容器运行时执行的命令 command: [&quot;echo&quot;] #命令的参数 args: [&quot;Hello,world&quot;] #从容器公开的端口列表 ports: - containerPort: 80 #容器内部环境变量 - env: #环境变量名 - name: GRPC_PORT #环境变量值 value: &quot;8080&quot; #node从最后一次处于活动状态到标记为失败并终止持续的时间，单位：秒 activeDeadlineSeconds: 3 #Pod的主机名，不指定默认为主机系统设置的值 hostname: host-name #将Pod调度到指定的Node上，如果该Node资源符合要求的话 nodeName: node—name Deployment 配置1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: deployment-examplespec: #副本数 replicas: 3 #Pod的标签选择器，符合匹配条件的副本集的Pod才会受本次Deployment的影响 selector: matchLabels: app: nginx #模板规范，描述将要创建的Pod template: metadata: labels: app: test spec: containers: - name: test image: test-image Job 配置12345678910111213141516171819apiVersion: batch/v1kind: Jobmetadata: name: job-examplespec: #指定所需要完成任务的Pod数量 completions: 3 #任务执行时创建的Pod template: metadata: name: example-job spec: containers: - name: job-con-name image: job-image command: [&quot;perl&quot;] args: [&quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;] #指定容器结束后不会重启 restartPolicy: Never ReplicationController 配置1234567891011121314151617181920212223apiVersion: v1kind: ReplicationControllermetadata: name: RC-examplespec: #副本数 replicas: 3 #新建pod完成后要持续指定的时间该Pod才被视为可用，默认为0，单位：秒 minReadySeconds: 1 #标签选择器，符合匹配条件的Pod才会被副本集管理 selector: matchLabels: app: nginx #检测到副本不足时会创建的pod模板 template: metadata: labels: app: nginx spec: containers: # Run the nginx image - name: nginx image: nginx:1.14 ReplicaSet 配置12345678910111213141516171819202122apiVersion: apps/v1kind: ReplicaSetmetadata: name: RS-examplespec: #副本数量 replicas: 3 #新建pod完成后要持续指定的时间该Pod才被视为可用，默认为0，单位：秒 minReadySeconds: 1 #标签选择器，符合匹配条件的Pod才会被副本集管理，在RC基础上增加了equality-based匹配机制 selector: matchLabels: app: nginx #检测到副本不足时会创建的pod模板 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14 Service APIService 配置123456789101112131415161718192021222324252627282930kind: ServiceapiVersion: v1metadata: name: service-examplespec: #向外公开的端口数组 ports: #端口的名称 - name: http #容器要公开的端口 port: 80 #在Pod上要访问的端口号或名称 targetPort: 80 #此端口的IP协议，支持TCP、UDP、SCTP，默认TCP protocol: UDP #标签选择器，将服务流量转发到符合匹配条件的Pod，不适用于ExternalName方式 selector: app: nginx #服务向外暴露的方式，支持ClusterIP（默认）、ExternalName、NodePort 、LoadBalancer #ClusterIP：为Endpoint分配一个集群内部IP地址 #NodePort：在每个Node上分配一个端口，该端口路由到与clusterIP相同的Endpoint #LoadBalancer：基于NodePort构建并创建一个外部负载均衡器，它路由到与clusterIP相同的端点 #ExternalName：将此服务的别名为指定为externalName，其他几个字段不适用于ExternalName服务 type: LoadBalancer #外部服务别名 externalName: external-service-name #外部IP地址列表 externalIPs: - 192.168.2.5 - 192.168.2.6","link":"/2022/05/23/%E5%B7%A5%E5%85%B7/Kubernetes/Kubernetes%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/"},{"title":"LiveKit 客户端","text":"LiveKit 客户端 SDK 的使用，以 Flutter 为例 安装依赖 其他客户端SDK参考：客户端SDK 在Flutter中首先需要安装依赖 12dependencies: livekit_client: &lt;version&gt; 然后配置好各个平台的权限 房间操作连接房间12var room = Room()await room.connect(wsUrl, token) wsUrl：LiveKit 服务器，默认为：ws://localhost:7880； token：服务端生成的访问令牌；进入房间后有两个关键属性： LocalParticipant：当前用户的对象； RemoteParticipants：房间中其他用户的对象数组； 离开房间12// 通知 LiveKit 离开事件Room.disconnect() 如果应用程序在未通知 LiveKit 的情况下关闭，它将继续显示参与者在房间中另外 15 秒。 网络变化和重新连接诶网络发生波动时，LiveKit 将尝试在幕后重新建立连接。如果重新连接成功，您将收到Reconnected回调告知您一切已恢复正常。否则，它会将您与房间断开连接。 发布 Track摄像头/麦克风将摄像头/麦克风发布到房间 1234567// 相机room.localParticipant.setCameraEnabled(true)// 麦克风room.localParticipant.setMicrophoneEnabled(true)// 禁用相机和麦克风room.localParticipant.setCameraEnabled(false)room.localParticipant.setMicrophoneEnabled(false) 屏幕共享跨平台共享本机屏幕 1room.localParticipant.setScreenShareEnabled(true); 其他 Track可以使用设置对Track进行更详细的调整，设置分为两类： 捕获设置：如何捕获媒体，包括设备选择和功能。 发布设置：编码方式，包括比特率和帧率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 设置房间默认值var room = Room( roomOptions: RoomOptions( // 默认相机捕获设置 defaultCameraCaptureOptions: CameraCaptureOptions( deviceId: '', cameraPosition: CameraPosition.front, params: VideoParametersPresets.h720_169, ), // 默认音频捕获设置 defaultAudioCaptureOptions: AudioCaptureOptions( deviceId: '', noiseSuppression: true, echoCancellation: true, autoGainControl: true, highPassFilter: true, typingNoiseDetection: true, ), // 默认视频发布设置 defaultVideoPublishOptions: VideoPublishOptions( videoEncoding: VideoParametersPresets.h720_169.encoding, videoSimulcastLayers: [ VideoParametersPresets.h180_169, VideoParametersPresets.h360_169, ], ), // 默认音频发布设置 defaultAudioPublishOptions: AudioPublishOptions( dtx: true, ) ),) // 单独创建Track try { var localVideo = await LocalVideoTrack.createCameraTrack(LocalVideoTrackOptions( // 相机的位置：前置摄像头 position: CameraPosition.FRONT, // 视频参数：h720_169 params: VideoParametersPresets.h720_169, )); await room.localParticipant.publishVideoTrack(localVideo); } catch (e) { print('could not publish video: $e'); }var localAudio = await LocalAudioTrack.createTrack();await room.localParticipant.publishAudioTrack(localAudio); 静音使用LocalTrackPublication可以禁止将Track发送到LiveKit服务器，当静音时，LiveKit 将对房间中的所有参与者触发一个TrackMuted事件。 视频联播默认启用，允许 LiveKit 根据每个接收者的可用带宽和首选分辨率动态转发最合适的流。 动态广播LiveKit 采用端到端优化设计，可最大程度地减少带宽消耗。要激活此功能，请在房间选项中设置 dynacast: true。 订阅权限默认情况下，所有参与者都可以订阅发布到房间的任何Track。 在某些情况下，发布者可能希望限制谁可以订阅他们正在发布的Track。例如，当两个人希望在大型会议中进行私人对话时。 对于这些用例，轨道订阅权限为发布者提供了指定允许谁订阅其轨道的方法。 123456localParticipant.setTrackSubscriptionPermissions( allParticipantsAllowed: false, trackPermissions: [ const ParticipantTrackPermission('allowed-identity', true, null) ],); 接收 Track订阅 Track从服务器接收 Track 首先需要订阅，跟踪订阅回调为您的应用程序提供Track和TrackPublication对象。Track是具体的媒体流，TrackPublication是Track的相关信息。 代码 媒体播放订阅Track后可以播放媒体 代码 发言者检测检测正在发言的参与者 代码 选择性订阅禁用autoSubscribe后只有显示订阅的Track才会发送到客户端，可以从客服端和服务端设置 代码 自适应流禁用Track后客户端不会收到任何该Track的新数据 代码； 联播控制如果视频轨道启用了联播，接收客户端可能需要手动指定最大可接收质量。这将导致目标轨道的质量和带宽降低。 代码 元数据参与者和房间都具有元数据，可以在服务端/服务端对元数据进行更改，更改会触发监听事件 代码 发布数据LiveKit 允许您从服务器和客户端通过 API 向房间中的任何参与者发布任意数据消息 代码 处理事件客户端 SDK 使用事件来与房间中发生的应用程序更改进行通信。 房间事件：房间事件从Room主对象发出，反映房间中的任何变化。 参与者事件：当特定参与者发生更改时，会从每个Participant发出参与者事件。 12345678EventsListener&lt;RoomEvent&gt; _listener = widget.room.createListener();_listener ..on&lt;RoomDisconnectedEvent&gt;((_) { // handle disconnect }) ..on&lt;ParticipantConnectedEvent&gt;((e) { print(&quot;participant joined: ${e.participant.identity}&quot;); })","link":"/2023/10/18/%E5%B7%A5%E5%85%B7/LiveKit/LiveKit%20%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"title":"LiveKit 服务器部署","text":"LiveKit 服务端的部署方式 本地部署12curl -sSL https://get.livekit.io | bashcurl x https://127.0.0.1:7890 -sSL https://get.livekit.io | bash 启动命令 1livekit-server --dev --bind 0.0.0.0 --keys &quot;myKey: mySecret&quot; 删除 1sudo rm /usr/local/bin/livekit-server docker 本地部署（未测试）12345678docker run -d\\-p 7881:7881 \\-p 7880:7880 \\-p 5349:5349 \\-p 3478:3478 \\--name livekit \\--hostname livekit \\livekit/livekit-server:latest livekit-server --dev --bind 0.0.0.0 --keys &quot;mykey: mySecret&quot;","link":"/2023/10/18/%E5%B7%A5%E5%85%B7/LiveKit/LiveKit%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"},{"title":"LiveKit 服务端","text":"LiveKit 服务端 SDK 的使用，以 Go 为例 安装依赖1go get github.com/livekit/server-sdk-go 创建令牌客户端想要连接到 LiveKit 中的房间需要服务端生成的令牌保存 LiveKit 的 Key 和 Secret 1234567var LiveKitConfig = struct { LivekitApiKey string LivekitApiSecret string}{ LivekitApiKey: &quot;APIMmxiL8rquKztZEoZJV9Fb&quot;, LivekitApiSecret: &quot;123456&quot;,} 在代码中创建令牌 1234567891011121314151617181920// identity: 用户唯一标识，room：房间唯一标识func getJoinToken(room, identity string) string { at := auth.NewAccessToken(global.LiveKitConfig.LivekitApiKey, global.LiveKitConfig.LivekitApiSecret) // 视频权限 grant := &amp;auth.VideoGrant{ // 可以进入房间 RoomJoin: true, Room: room, } at.AddGrant(grant). SetIdentity(identity). // 设置过期时间 SetValidFor(time.Hour) jwt, err := at.ToJWT() if err != nil { return &quot;livekit jwt token 创建失败&quot; } return jwt} 管理房间LiveKit 中使用 RoomServiceClient 对房间进行管理 首先进行初始化 12345678910111213import ( lksdk &quot;github.com/livekit/server-sdk-go&quot;)const host = &quot;https://my.livekit.host&quot;var RoomClient *lksdk.RoomServiceClientfunc init() { // 初始化 RoomClient RoomClient = lksdk.NewRoomServiceClient(host, &quot;api-key&quot;, &quot;secret-key&quot;)} 接下来可以使用 RoomClient 对房间进行操作： 123456789101112131415// 创建房间room, _ := RoomClient.CreateRoom(context.Background(), &amp;livekit.CreateRoomRequest{ Name: &quot;myroom&quot;, // 房间名 EmptyTimeout: 10 * 60, // 超时实践 MaxParticipants: 20, // 最大参与者})}// 房间列表rooms, _ := RoomClient.ListRooms(context.Background(), &amp;livekit.ListRoomsRequest{})// 删除房间_, _ = RoomClient.DeleteRoom(context.Background(), &amp;livekit.DeleteRoomRequest{ Room: &quot;myroom&quot;,}) 管理参与者LiveKit 中同样使用 RoomServiceClient 对参与者进行管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 列出房间内的参与者res, err := roomClient.ListParticipants(context.Background(), &amp;livekit.ListParticipantsRequest{ Room: roomName,})// 获取参与者详情res, err := roomClient.GetParticipant(context.Background(), &amp;livekit.RoomParticipantIdentity{ Room: roomName, Identity: identity,})// 将观众提升为演讲者res, err := c.UpdateParticipant(context.Background(), &amp;livekit.UpdateParticipantRequest{ Room: roomName, Identity: identity, Permission: &amp;livekit.ParticipantPermission{ CanSubscribe: true, CanPublish: true, CanPublishData: true, },})// 然后将它们移回观众席res, err := c.UpdateParticipant(context.Background(), &amp;livekit.UpdateParticipantRequest{ Room: roomName, Identity: identity, Permission: &amp;livekit.ParticipantPermission{ CanSubscribe: true, CanPublish: false, CanPublishData: true, },})//更新参与者的元数据，更改后房间内的参与者将收到一个`ParticipantMetadataChanged`事件data, err := json.Marshal(values)_, err = c.UpdateParticipant(context.Background(), &amp;livekit.UpdateParticipantRequest{ Room: roomName, Identity: identity, Metadata: string(data),})// 删除参与者，将参与者移出房间res, err := roomClient.RemoveParticipant(context.Background(), &amp;livekit.RoomParticipantIdentity{ Room: roomName, Identity: identity,})// 禁言：将参与者的Track静音/取消静音res, err := roomClient.MutePublishedTrack(context.Background(), &amp;livekit.MuteRoomTrackRequest{ Room: roomName, Identity: identity, TrackSid: &quot;track_sid&quot;, Muted: true,}) Webhooks自托管或使用官方提供的云服务才能使用Webhooks功能。 配置 LiveKit 以在房间事件发生时通知您的服务器。 Webhooks 是由 LiveKit 发起并发送到您的后端的 HTTP 请求。 123456789101112func ServeHTTP(w http.ResponseWriter, r *http.Request) { authProvider := auth.NewSimpleKeyProvider( apiKey, apiSecret, ) // event is a livekit.WebhookEvent{} object event, err := webhook.ReceiveWebhookEvent(r, authProvider) if err != nil { // could not validate, handle error return } // consume WebhookEvent} event 是一个livekit.WebhookEvent对象，里面包含了事件相关的所有信息，可以通过event识别事件类型，具体事件类型参考：事件","link":"/2023/10/18/%E5%B7%A5%E5%85%B7/LiveKit/LiveKit%20%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"title":"LiveKit 入门","text":"LiveKit 是 Go 实现实时音视频传输平台，本文介绍其基本概念、核心结构以及认证方式。 LiveKit 介绍LiveKit 是一个实时平台，使开发人员能够将视频、语音和数据功能构建到他们的应用程序中。它建立在 WebRTC 之上，提供多种前后端平台的 SDK，具有如下特定： 封装了 WebRTC，提供了很多开箱即用的功能； WebRTC SFU结构，可以支持大量并发用户； LiveKit 组件 LiveKit Server：这是 LiveKit 平台的核心组件。它作为SFU，处理信令、媒体和其他实时通信任务。 SDK：LiveKit 提供功能齐全的 Web、原生和后端 SDK，以抽象出 WebRTC 的复杂性，以便于集成。 Egress：此组件允许录制或实时流式传输房间和单个参与者的轨道。 Ingress：这允许将外部流（如 RTMP 和 WHIP）引入 LiveKit 房间。 AI Agents：此服务器端框架允许构建具有实时功能的智能、AI 驱动的应用程序。 LiveKit 使用步骤 安装 LiveKit 服务端 SDK：LiveKit 服务器端 SDK 提供必要的 API 和工具来管理房间、生成访问令牌和处理服务器端操作。它们充当应用程序后端和 LiveKit 服务器之间的桥梁； 设置 LiveKit 服务器：将 LiveKit Server 二进制文件或 Docker 映像部署到基础架构（自托管），或使用 LiveKit Cloud 托管服务； 安装 LiveKit 客户端 SDK：将相应的 LiveKit 客户端 SDK（例如 Web 或移动设备）集成到应用程序代码中； 创建访问令牌服务器：设置一种机制来生成和验证访问令牌 （JWT） 以实现安全的房间访问； 开发前端：开发视频会议的用户界面，包括摄像头和麦克风访问、参与者列表和屏幕共享； 添加高级功能（可选）：根据应用程序的要求集成其他 LiveKit 组件，如 Egress、Ingress 或 AI Agent。 测试和优化：跨不同网络、设备和负载全面测试您的实施。根据需要优化媒体服务器设置（CPU、带宽、编解码器）。 部署和监视：将 LiveKit 实施部署到生产环境，并为性能跟踪和调试设置监视和日志记录。 核心结构LiveKit 只有三个核心结构：Room（聊天室）、Participant（参与者）、Track。 参与者进入聊天室，然后订阅Track即可接收该Track的数据，参与者可以随时订阅和取消订阅 参与者进入聊天室时默认自动订阅所有正在发布的Track，如果想要更精细的控制，可以使用选择性订阅 Room（聊天室）Room 中的每个参与者都会收到有关同一聊天室中其他参与者的更改的更新。可以通过服务器API手动创建聊天室，一旦最后一位参与者离开房间，房间将在短暂延迟后关闭。 Participant（参与者）Participant 是 Room 中的用户，Participant 是唯一的，客户端提供 identity，服务端生成 sid，参与者对象还包含有关其状态和已发布的跟踪的元数据。 Participant 的身份在每个房间都是唯一的。因此，如果具有相同身份的参与者加入一个房间，则只会保留最近加入的参与者;服务器会自动断开使用该标识的其他参与者的连接。 参与者有两种： LocalParticipant：表示默认情况下可以在聊天室中发布Track的当前用户； RemoteParticipant：表示远程用户。默认情况下，本地参与者可以订阅远程参与者发布的任何Track； TrackTrack 标识信息流，包括音频、视频还有自定义数据。默认情况下，聊天室中的参与者可以发布Track，例如他们的摄像头或麦克风流，并订阅其他参与者发布的一个或多个Track。为了对本地参与者可能不订阅的轨道进行建模，所有轨道对象都有一个相应的 TrackPublication 对象： Track: 一个原生 WebRTC MediaStreamTrack 的包装器，表示可播放的媒体； TrackPublication: 已发布到服务器的Track。本地 Participant 订阅后可以在本地播放； TrackPublication 的属性： 字段 类型 描述 sid string 此特定 Track 的 uid，由 LiveKit 服务器生成。 kind Track.Kind Track 的类型，无论是音频、视频还是任意数据。 source Track.Source 媒体来源：相机、麦克风、ScreenShare 或 ScreenShareAudio。 name string 最初发布时该Track的名称。 subscribed boolean 指示本地参与者是否已订阅此Track。 track Track 如果本地参与者已订阅，则可以获取关联的Track对象。 muted boolean 此Track是否被本地参与者静音。静音时，它不会从服务器接收新字节。 认证要使 LiveKit 客户端成功连接到服务器，必须通过请求传递访问令牌。此令牌对参与者的身份、聊天室名称、功能和权限进行编码。访问令牌是基于 JWT 的，并使用您的 API 密钥进行签名，以防止伪造。 访问令牌还具有过期时间，在此时间之后，服务器将拒绝与该令牌的连接。注意：过期时间仅影响初始连接，不会影响后续重新连接。 令牌样例1234567891011{ &quot;exp&quot;: 1621657263,//令牌的到期时间 &quot;iss&quot;: &quot;APIMmxiL8rquKztZEoZJV9Fb&quot;,//用于颁发此令牌的 API 密钥 &quot;sub&quot;: &quot;myidentity&quot;,//参与者的唯一标识 &quot;nbf&quot;: 1619065263,//令牌生效的开始时间 &quot;video&quot;: {//视频授权，包括聊天室权限 &quot;room&quot;: &quot;myroom&quot;, &quot;roomJoin&quot;: true }, &quot;metadata&quot;: &quot;&quot;//metadata参与者元数据} token详细信息参考：token","link":"/2024/05/14/%E5%B7%A5%E5%85%B7/LiveKit/LiveKit%E5%85%A5%E9%97%A8/"},{"title":"Minio 访问策略","text":"Minio 每个桶可以设置访问策略， private 策略private 策略下的桶不允许直接通过文件路径url访问文件，只能通过分享的方式获取url，private 策略文件如下： 1234{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: []} public 策略public 策略下的桶可以直接通过文件路径访问文件，public 策略文件如下 123456789101112131415161718192021222324252627282930313233343536373839{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;AWS&quot;: [ &quot;*&quot; ] }, &quot;Action&quot;: [ &quot;s3:GetBucketLocation&quot;, &quot;s3:ListBucket&quot;, &quot;s3:ListBucketMultipartUploads&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::test&quot; ] }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;AWS&quot;: [ &quot;*&quot; ] }, &quot;Action&quot;: [ &quot;s3:ListMultipartUploadParts&quot;, &quot;s3:PutObject&quot;, &quot;s3:AbortMultipartUpload&quot;, &quot;s3:DeleteObject&quot;, &quot;s3:GetObject&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::test/*&quot; ] } ]} 自定义访问策略可以通过自定义的方式细粒度的控制桶内的访问策略，其配置如下： Version：版本声明； Statement：访问策略的数组； Effect：指定Statement的效果 Allow：在本Statement声明的操作时允许的； Deny：在本Statement声明的操作时禁止的； Principal：可选。指定受限主体，可以是用户、角色； Action：指定操作； Resource：受限的资源，资源的路径； 举例如下： 1234567891011121314151617181920212223{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;AWS&quot;: [ &quot;*&quot; ] }, &quot;Action&quot;: [ &quot;s3:AbortMultipartUpload&quot;, &quot;s3:DeleteObject&quot;, &quot;s3:GetObject&quot;, &quot;s3:ListMultipartUploadParts&quot;, &quot;s3:PutObject&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::test/public/*&quot; ] } ]} 表示只有test/public/*下的文件是公开的，其他文件都是私有的","link":"/2022/12/27/%E5%B7%A5%E5%85%B7/Minio/Minio%20%E8%AE%BF%E9%97%AE%E7%AD%96%E7%95%A5/"},{"title":"MongoDB 数据库","text":"MongoDB中数据库的概念和操作。 MongoDB官方文档：MongoDB 简介 - MongoDB 手册 v7.0 数据库1. 默认数据库默认情况下一个数据库有三个默认数据库： admin：管理每个数据库的权限数据，如用户名、密码等； config：使用分片的时候保存分片相关信息； local：不会被赋值，存储本地服务器的合集； 2. 查看所有数据库12show dbsshow databases 3. 使用数据库MongoDB默认数据库为test。使用use关键字可以切换数据库，该数据库可以不存在，在插入文档后才会真正被创建： 1use 数据库名 4. 当前数据库查看当前使用的数据库 1db 5. 删除数据库1db.dropDatabase()","link":"/2024/05/22/%E5%B7%A5%E5%85%B7/MongoDB/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"MongoDB 文档","text":"MongoDB中文档的概念和操作。 官方文档：MongoDB CRUD 操作 - MongoDB 手册 v7.0； 概念1. 数据类型MongoDB 支持丰富的数据类型，并且由于支持Object类型，所以可以实现嵌套 类型 数值 别名 注意 双精度 1 “double” 字符串 2 “string” 对象 3 “object” 阵列 4 “array” 二进制数据 5 “binData” 未定义 6 “undefined” 已弃用。 ObjectId 7 “objectId” 布尔 8 “bool” Date 9 “date” null 10 “null” 正则表达式 11 “regex” 数据库指针 12 “dbPointer” 已弃用。 JavaScript 13 “javascript” 符号 14 “symbol” 已弃用。 32 位整数 16 “int” 时间戳 17 “timestamp” 64 位整型 18 “long” Decimal128 19 “decimal” 最小键 -1 “minKey” Max key 127 “maxKey” 字符串是UTF-8编码； 使用$type操作符可以在查询时匹配类型； null和不存在是不同的，不存在代表文档没有对应字段，null代表该字段值为null； 每条文档都有一个ObjectId类型的_id字段作为主键，默认情况下，会在_id上创建唯一索引； 操作1. 创建文档 插入数据时，如果指定的文档不存在，则会创建集合； 如果文档未指定_id，则会自动生成； 1.1. 插入单条123db.collection.insertOne( {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10}) 1.2. 插入多条1234db.collection.insertMany([ {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10}, {&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:11}]) 2. 查询文档2.1. 查询全部1db.集合名.find({}) 2.2. 查询筛选器123456{ // 等值匹配 字段: 值, 字段: { 操作符: 值 }, ...} 查询操作符非常多： $eq：= $gt：&gt; $gte：&gt;= $in：in $lt：&lt; $lte：&lt;= $ne：!= $nin：not in $and：与 $not：非 $or：或 其他：查询和投影操作符 — MongoDB 手册 v7.0 2.3. 条件查询123456789101112131415db.集合名.find(查询筛选器)// 举例db.集合名.find({ // 多个条件默认是and关系 &quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:{ $in: [10,11,12], $gt: 9, }, // or 条件拼接 $or: { &quot;age&quot;: 12, //... }}) 2.4. 查询嵌入文档MongoDB 中使用.指定嵌入文档 12345678910db.集合名.find({ &quot;name.first&quot;: &quot;张&quot;})db.集合名.find({ &quot;name&quot;: { &quot;first&quot;:&quot;张&quot; &quot;second&quot;:三 }}) 2.5. 查询数组1234567891011121314db.集合名.find({ // 多个条件默认是and关系 &quot;name&quot;:&quot;张三&quot;, // 匹配数组，数组元素必须完全一致 &quot;三围&quot;: [100,100,100], // 这里表示数组中必须包含100这一元素 &quot;三围&quot;: 100, // 数组也可以指定条件，表示至少包含一个符合条件的元素 &quot;三围&quot;: { $gt: 25 }, // 指定数组长度 &quot;三围&quot;: { $size: 3 }}) 2.6. 指定返回字段12345678910db.集合名.find({ // 指定返回的字段，1代表返回，0表示排除 { &quot;age&quot;:1, // _id比较特殊，如果不指定_id为0则默认返回 &quot;_id&quot;:0, // 可以指定嵌套字段 &quot;name.first&quot;:1 }}) 2.7. null/不存在字段查询 匹配字段值为null或不存在item字段1db.inventory.find( { item: { $ne : null } } ) 查询存在且不为null的文档1db.inventory.find( { item: { $ne : null } } ) 匹配字段值为null的文档1db.inventory.find( { item: { $ne : null } } ) 不存在字段查询1db.inventory.find( { item: { $ne : null } } ) 3. 删除文档3.1. 删除所有1db.inventory.deleteMany({}) 3.2. 删除单个会删除第一个匹配到的文档 123db.inventory.deleteOne({ &quot;age&quot;: 10}) 3.3. 删除多个123db.inventory.deleteMany({ &quot;age&quot;: 10}) 4. 更新文档4.1. 更新操作符 $inc：递增； $min：相当于min(a,b)方法，保存最小值； $currentDate：将字段设置为当前时间； 其他：更新操作符 - MongoDB 手册 v v7.0；12345{ &quot;更新操作符号&quot;: { &quot;字段&quot;：值 }} 4.2. 更新单个会默认更新匹配到的第一个文档 1234567db.inventory.updateOne( { name: &quot;张三&quot; }, { $set: { &quot;age&quot;: &quot;10&quot;, sex: &quot;男&quot; }, $currentDate: { updateTime: true } }) 4.3. 更新多个1234567db.inventory.updateMany( { &quot;age&quot;: { $lt: 100 } }, { $set: { &quot;age&quot;: &quot;10&quot;, sex: &quot;男&quot; }, $currentDate: { updateTime: true } }) 4.4. 替换文档替换第一个匹配到的文档 1234db.inventory.replaceOne( { &quot;age&quot;: { $lt: 100 } }, { &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 10 })","link":"/2024/05/22/%E5%B7%A5%E5%85%B7/MongoDB/MongoDB%20%E6%96%87%E6%A1%A3/"},{"title":"MongoDB 索引","text":"MongoDB中聚合操作通过多个阶段对一个或多个文档进行处理。 官方文档：索引 - MongoDB 手册 v7.0； 基础操作1. 创建索引1234db.集合.createIndex( 索引和类型, 选项 )// 在name字段上创建一个单键降序索引db.集合.createIndex( { name: -1 } ) 2. 获取索引12// 获取全部索引db.集合.getIndexes() 3. 删除索引123456// 删除单个db.集合.dropIndex(&quot;索引1&quot;)// 删除多个db.集合.dropIndexes( [ &quot;索引1&quot;, &quot;索引2&quot; ] )// 删除_id以外的全部索引db.集合.dropIndexes() 索引类型索引类型 - MongoDB 手册 v7.0； 1. 单字段索引单个字段索引收集集合内每个文档中单个字段的数据，并对其排序。 2. 复合索引复合索引从集合中每个文档的两个或多个字段收集数据并对其排序。数据先按索引中的第一个字段分组，再按每个后续字段分组。 3. 多键索引多键索引收集数组中存储的数据并进行排序。 您无需显式指定多键类型。对包含数组值的字段创建索引时，MongoDB 会自动将该索引设为多键索引。 4. 地理空间索引地理空间索引可提高对地理空间坐标数据进行查询的性能。 5. 文本索引文本索引支持对包含字符串内容的字段进行文本搜索查询。 索引属性索引属性 - MongoDB 手册 v7.0； 1. 部分大小写的索引支持以不考虑字母大小写的方式对字符串进行查询。 2. 隐藏索引对索引规划期不可见，不能用于支持查询，可以使用隐藏索引评估删除索引的潜在影响，而无需将其实际删除。如有不利影响，您可以取消隐藏该索引，而不必重新创建删除的索引。隐藏索引是完全保留的，可以在取消隐藏后立即使用。 3. 部分索引仅对集合中符合指定过滤表达式的文档进行索引。部分索引的存储要求较低，创建和维护索引的性能成本也较低。部分索引提供了比稀疏索引更全面的功能，因此应优先选择部分索引。 4. 稀疏索引仅包含具有索引字段的文档的条目。这些索引跳过没有索引字段的文档。 5. TTL索引可在一定时间后从集合中自动删除文档。这些索引适用于只需在有限时间内持续存在的数据，比如机器生成的事件数据、日志和会话信息。 6. 唯一索引会导致 MongoDB 拒绝字段的重复值。当您的文档包含唯一标识符（例如 userId）时，这些索引就非常有用。","link":"/2024/05/22/%E5%B7%A5%E5%85%B7/MongoDB/MongoDB%20%E7%B4%A2%E5%BC%95/"},{"title":"MongoDB 聚合","text":"MongoDB中聚合操作通过多个阶段对一个或多个文档进行处理。 官方文档：聚合操作 - MongoDB 手册 v7.0；聚合操作的结构为：聚合-管道-阶段- 聚合管道聚合管道由多个聚合阶段组成，大多数阶段可以出现多次 123db.集合.aggregate([ // 聚合阶段]) 聚合阶段聚合阶段 - MongoDB 手册 v7.0；聚合阶段声明了该阶段所要做的任务 1. project（指定输出字段）指定传递给下一阶段的文档的字段，0代表排除，1代表传递 123456789101112{ $project: { // 支持嵌套 &quot;name&quot;:{ &quot;first&quot;: 0 }, &quot;name.last&quot;: 0, &quot;age&quot;: 0, // 可以将字段x和y投影道数组中 myArray: [ &quot;$x&quot;, &quot;$y&quot; ] } } 注意： _id如果不想返回的话必须手动排除 2. unwind（解构数组）将数组字段解构，默认情况下数组必须不为空，否则结果不会包含该文档 12345678910111213db.集合.aggregate( [ { $unwind : &quot;$数组字段&quot; } ] )db.集合.aggregate([ { $unwind: { path: &quot;$数组字段&quot;, // 结果是否保留null、缺失、空数组的文档 preserveNullAndEmptyArrays: true, // 输出结果中是否插入一个字段，该字段表示数组元素的索引 includeArrayIndex: &quot;字段名&quot; } }]) 假如现在有一条数据： 12{ &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, sizes: [ &quot;S&quot;, &quot;M&quot;, &quot;L&quot;]}{ &quot;_id&quot; : 2, &quot;item&quot; : &quot;ABC1&quot;, sizes: [ &quot;S&quot;, &quot;M&quot;, &quot;L&quot;]} 聚合操作： 1db.inventory.aggregate( [ { $unwind : &quot;$sizes&quot; } ] ) 上面操作会将sizes字段解构，然后返回三条数据 123{ &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;S&quot; }{ &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;M&quot; }{ &quot;_id&quot; : 1, &quot;item&quot; : &quot;ABC1&quot;, &quot;sizes&quot; : &quot;L&quot; } 3. replaceRoot（替换）使用文档中的一个子文档字段替换根文档 指定的子文档在输入的文档列表中必须都存在1{ $replaceRoot: { newRoot: 文档 } } 假设当前数据为： 1{ &quot;_id&quot;: 1, &quot;name&quot; : { &quot;first&quot; : &quot;John&quot;, &quot;last&quot; : &quot;Backus&quot; } }, 聚合操作： 123db.collection.aggregate([ { $replaceRoot: { newRoot: &quot;$name&quot; } }]) 结果： 1{ &quot;first&quot; : &quot;John&quot;, &quot;last&quot; : &quot;Backus&quot; } 聚合操作符聚合操作符 - MongoDB 手册 v7.0；聚合操作符用于构建表达式，用于组成聚合阶段 1. subtract（减法）返回两个数字的插值 123456db.temperatureChange.aggregate([ { // 返回value1-value2的值，将结果赋值给字段result $project: { result: { $subtract: [ &quot;$value1&quot;, &quot;$value2&quot; ] } } }]) 2. abs（绝对值）返回数字的绝对值 123456db.temperatureChange.aggregate([ { // 返回value的绝对值，将结果赋值给字段result $project: { result: { $abs: { &quot;$value&quot; } } } }])","link":"/2024/05/22/%E5%B7%A5%E5%85%B7/MongoDB/MongoDB%20%E8%81%9A%E5%90%88/"},{"title":"MongoDB 集合","text":"MongoDB中数据库的概念和操作。 MongoDB官方文档：MongoDB 简介 - MongoDB 手册 v7.0 1. 创建集合1db.createCollection(&quot;集合名&quot;) 2. 查看集合查看集合列表 12show tablesshow collections 3. 删除集合1db.集合名.drop()","link":"/2024/05/22/%E5%B7%A5%E5%85%B7/MongoDB/MongoDB%20%E9%9B%86%E5%90%88/"},{"title":"Redis 事务","text":"Redis 事务是指一次指定多个命令，中间不会被其他命令插入，可以理解为打包执行。 1. 命令 multi：开启事务，然后可以输入多条命令，命令会被放入队列中； exec：执行队列中的命令，命令执行失败不会回滚，而是继续执行，只有命令语法错误才会回滚； discard：中断事务，没有执行exec之前使用； watch：版本号机制，监视key，如果在exec执行之前这个key被其他命令改动，那么任务会被打断并丢弃；","link":"/2021/05/22/%E5%B7%A5%E5%85%B7/Redis/Redis%20%E4%BA%8B%E5%8A%A1/"},{"title":"Redis 库","text":"Redis 中默认有16个库 1. redis的db对于单体的redis默认提供了0-15共计16个库，刚进入redis时默认使用的是0号db，可通过select命令进行切换 12127.0.0.1:6379&gt; select 1OK 可以通过调整Redis的配置文件redis/redis.conf中的databases来修改这一个值，设置完毕后重启Redis便完成配置。另外在集群的情况下不支持使用select命令来切换db，因为redis集群模式下只有一个db0。 在spring boot项目中也可以指定db 12# redis db索引，默认为0app.redis_database = 0 2. 为什么要设计16个db由于Redis不支持自定义db的名字，所以每个db都以编号命名。另外Redis也不支持为每个db设置不同的访问密码，所以一个客户端要么可以访问全部db，要么全部db都没有权限访问。可通过flushall命令清空一个redis实例所有的db 12127.0.0.1:6379[1]&gt; flushallOK 我们常用的关系型数据库，如mysql中，各个db是相互隔离的，不同db用来存储不同应用程序的数据，而redis的db更适合作为命名空间来使用，不同的数据库可用于存储不同环境的数据。比如可以使用0号db存储某个应用生产环境中的数据，使用1号db存储测试环境中的数据，多个应用程序不应使用同一个redis不同库，而是应一个应用程序对应一个redis实例。由于redis是轻量级的，一个空的redis只占用1mb左右的内存，所以不用在意空间不足的问题。","link":"/2021/05/22/%E5%B7%A5%E5%85%B7/Redis/Redis%20%E5%BA%93/"},{"title":"Redis 基本数据类型","text":"Redis 五种基本类型 Redis中都是以一个key-value格式存储的，key是一个唯一的标识，value是具体存储的数据，value有多种类型。 1. 字符串（String）字符串不仅可以存储字符串类型的value，同样支持整形操作。 1.1. 命令12set key valueget key 1.2. 参考 命令 介绍 SET key value 设置指定 key 的值 SETNX key value 只有在 key 不存在时设置 key 的值 GET key 获取指定 key 的值 MSET key1 value1 key2 value2 … 设置一个或多个指定 key 的值 MGET key1 key2 … 获取一个或多个指定 key 的值 STRLEN key 返回 key 所储存的字符串值的长度 INCR key 将 key 中储存的数字值增一 DECR key 将 key 中储存的数字值减一 EXISTS key 判断指定 key 是否存在 DEL key（通用） 删除指定的 key EXPIRE key seconds（通用） 给指定 key 设置过期时间 2. 列表（List）是一个双向链表，可以在头尾两边插入和删除value。 2.1. 命令1234567# 插入lpush key value1 value2 ...rpush key value1 value2 ...# 从头部删除lpop key# 从左边遍历，-1代表lrange key 0 -1 2.2. 参考 命令 介绍 RPUSH key value1 value2 ... 在指定列表的尾部（右边）添加一个或多个元素 LPUSH key value1 value2 ... 在指定列表的头部（左边）添加一个或多个元素 LSET key index value 将指定列表索引 index 位置的值设置为 value LPOP key 移除并获取指定列表的第一个元素(最左边) RPOP key 移除并获取指定列表的最后一个元素(最右边) LLEN key 获取列表元素数量 LRANGE key start end 获取列表 start 和 end 之间 的元素 3. 哈希（Hash）HashMap 的实现 3.1. 命令123456# 插入或更新hset hashKey key1 value1 key2 value2 ...# 根据key获取hget hashKey key# 获取全部hgetall hash key 旧版本批量插入需要用hmset命令，4.0已被弃用 3.2. 参考 命令 介绍 HSET key field value 设置指定哈希表中指定字段的值 HSETNX key field value 只有指定字段不存在时设置指定字段的值 HMSET key field1 value1 field2 value2 ... 同时将一个或多个 field-value (域-值)对设置到指定哈希表中 HGET key field 获取指定哈希表中指定字段的值 HMGET key field1 field2 ... 获取指定哈希表中一个或者多个指定字段的值 HGETALL key 获取指定哈希表中所有的键值对 HEXISTS key field 查看指定哈希表中指定的字段是否存在 HDEL key field1 field2 ... 删除一个或多个哈希表字段 HLEN key 获取指定哈希表中字段的数量 4. 集合（Set）Set 集合，集合中元素唯一 4.1. 命令12345678# 添加sadd key value# 遍历smembers key# 随机删除Set中的元素spop key# 随机筛选，不会删除srandmember key 4.2. 参考 命令 介绍 SADD key member1 member2 ... 向指定集合添加一个或多个元素 SMEMBERS key 获取指定集合中的所有元素 SCARD key 获取指定集合的元素数量 SISMEMBER key member 判断指定元素是否在指定集合中 SINTER key1 key2 ... 获取给定所有集合的交集 SINTERSTORE destination key1 key2 ... 将给定所有集合的交集存储在 destination 中 SUNION key1 key2 ... 获取给定所有集合的并集 SUNIONSTORE destination key1 key2 ... 将给定所有集合的并集存储在 destination 中 SDIFF key1 key2 ... 获取给定所有集合的差集 SDIFFSTORE destination key1 key2 ... 将给定所有集合的差集存储在 destination 中 SPOP key count 随机移除并获取指定集合中一个或多个元素 SRANDMEMBER key count 随机获取指定集合中指定数量的元素 5. 有序集合（Sorted Set）在 Set 的基础上添加了一个double类型的权重参数 score，集合中元素可以按照 score 进行排列 5.1. 命令1234# 添加zadd key score1 value1 score2 value2 ...# 删除 5.2. 参考 命令 介绍 ZADD key score1 member1 score2 member2 ... 向指定有序集合添加一个或多个元素 ZCARD KEY 获取指定有序集合的元素数量 ZSCORE key member 获取指定有序集合中指定元素的 score 值 ZINTERSTORE destination numkeys key1 key2 ... 将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量 ZUNIONSTORE destination numkeys key1 key2 ... 求并集，其它和 ZINTERSTORE 类似 ZDIFF destination numkeys key1 key2 ... 求差集，其它和 ZINTERSTORE 类似 ZRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从低到高） ZREVRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从高到底） ZREVRANK key member 获取指定有序集合中指定元素的排名(score 从大到小排序)","link":"/2021/05/22/%E5%B7%A5%E5%85%B7/Redis/Redis%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Redis 消息队列","text":"Redis 消息队列 1. 基本操作1234# 订阅给定的一个或多个频道subscribe # 将消息发送到指定频道publish","link":"/2021/05/22/%E5%B7%A5%E5%85%B7/Redis/Redis%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"title":"Redis 特殊数据类型","text":"Redis 的三种特殊类型 Redis中都是以一个key-value格式存储的，key是一个唯一的标识，value是具体存储的数据，value有多种类型。 1. 位图（Bitmap）Bitmap存储了一个连续的bit位，一个bit位代表某个元素的状态，可以节省大量空间 1.1. 使用offset表示偏移量，因为位图中是连续存储的，value只能是0或1 12setbit key offset valuegetbit key offset 1.2. 命令 命令 介绍 SETBIT key offset value 设置指定 offset 位置的值 GETBIT key offset 获取指定 offset 位置的值 BITCOUNT key start end 获取 start 和 end 之前值为 1 的元素个数 BITOP operation destkey key1 key2 ... 对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT bitpos key value [start end] 第一次出现value的位置 2. 超日志（HyperLogLog）HyperLogLog 是一种基数计数概率算法，节省内存，存在一定误差，一般用于数量巨大的计数场景 2.1. 使用1234# 添加元素pdadd key value# 获取基数pfcount key 2.2. 命令 命令 介绍 PFADD key element1 element2 ... 添加一个或多个元素到 HyperLogLog 中 PFCOUNT key1 key2 获取一个或者多个 HyperLogLog 的唯一计数。 PFMERGE destkey sourcekey1 sourcekey2 ... 将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。 3. 地理信息（Geospatial）以经纬度存储地理位置信息，基于Sorted Set实现 3.1. 使用1geoadd key 经度 维度 成员名 3.2. 命令 命令 介绍 GEOADD key longitude1 latitude1 member1 ... 添加一个或多个元素对应的经纬度信息到 GEO 中 GEOPOS key member1 member2 ... 返回给定元素的经纬度信息 GEODIST key member1 member2 M/KM/FT/MI 返回两个给定元素之间的距离 GEORADIUS key longitude latitude radius distance 获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数 GEORADIUSBYMEMBER key member radius distance 类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素","link":"/2021/05/22/%E5%B7%A5%E5%85%B7/Redis/Redis%20%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"LiveKit入门","text":"LiveKit 的基本概念、核心结构、认证方式 LiveKit 介绍LiveKit 是一个实时平台，使开发人员能够将视频、语音和数据功能构建到他们的应用程序中。它建立在 WebRTC 之上，提供多种前后端平台的 SDK，具有如下特定： 封装了 WebRTC，提供了很多开箱即用的功能； WebRTC SFU结构，可以支持大量并发用户； LiveKit 组件 LiveKit Server：这是 LiveKit 平台的核心组件。它作为SFU，处理信令、媒体和其他实时通信任务。 SDK：LiveKit 提供功能齐全的 Web、原生和后端 SDK，以抽象出 WebRTC 的复杂性，以便于集成。 Egress：此组件允许录制或实时流式传输房间和单个参与者的轨道。 Ingress：这允许将外部流（如 RTMP 和 WHIP）引入 LiveKit 房间。 AI Agents：此服务器端框架允许构建具有实时功能的智能、AI 驱动的应用程序。 LiveKit 使用步骤 安装 LiveKit 服务端 SDK：LiveKit 服务器端 SDK 提供必要的 API 和工具来管理房间、生成访问令牌和处理服务器端操作。它们充当应用程序后端和 LiveKit 服务器之间的桥梁； 设置 LiveKit 服务器：将 LiveKit Server 二进制文件或 Docker 映像部署到基础架构（自托管），或使用 LiveKit Cloud 托管服务； 安装 LiveKit 客户端 SDK：将相应的 LiveKit 客户端 SDK（例如 Web 或移动设备）集成到应用程序代码中； 创建访问令牌服务器：设置一种机制来生成和验证访问令牌 （JWT） 以实现安全的房间访问； 开发前端：开发视频会议的用户界面，包括摄像头和麦克风访问、参与者列表和屏幕共享； 添加高级功能（可选）：根据应用程序的要求集成其他 LiveKit 组件，如 Egress、Ingress 或 AI Agent。 测试和优化：跨不同网络、设备和负载全面测试您的实施。根据需要优化媒体服务器设置（CPU、带宽、编解码器）。 部署和监视：将 LiveKit 实施部署到生产环境，并为性能跟踪和调试设置监视和日志记录。 核心结构LiveKit 只有三个核心结构：Room（聊天室）、Participant（参与者）、Track。 参与者进入聊天室，然后订阅Track即可接收该Track的数据，参与者可以随时订阅和取消订阅 参与者进入聊天室时默认自动订阅所有正在发布的Track，如果想要更精细的控制，可以使用选择性订阅 Room（聊天室）Room 中的每个参与者都会收到有关同一聊天室中其他参与者的更改的更新。可以通过服务器API手动创建聊天室，一旦最后一位参与者离开房间，房间将在短暂延迟后关闭。 Participant（参与者）Participant 是 Room 中的用户，Participant 是唯一的，客户端提供 identity，服务端生成 sid，参与者对象还包含有关其状态和已发布的跟踪的元数据。 Participant 的身份在每个房间都是唯一的。因此，如果具有相同身份的参与者加入一个房间，则只会保留最近加入的参与者;服务器会自动断开使用该标识的其他参与者的连接。 参与者有两种： LocalParticipant：表示默认情况下可以在聊天室中发布Track的当前用户； RemoteParticipant：表示远程用户。默认情况下，本地参与者可以订阅远程参与者发布的任何Track； TrackTrack 标识信息流，包括音频、视频还有自定义数据。默认情况下，聊天室中的参与者可以发布Track，例如他们的摄像头或麦克风流，并订阅其他参与者发布的一个或多个Track。为了对本地参与者可能不订阅的轨道进行建模，所有轨道对象都有一个相应的 TrackPublication 对象： Track: 一个原生 WebRTC MediaStreamTrack 的包装器，表示可播放的媒体； TrackPublication: 已发布到服务器的Track。本地 Participant 订阅后可以在本地播放； TrackPublication 的属性： 字段 类型 描述 sid string 此特定 Track 的 uid，由 LiveKit 服务器生成。 kind Track.Kind Track 的类型，无论是音频、视频还是任意数据。 source Track.Source 媒体来源：相机、麦克风、ScreenShare 或 ScreenShareAudio。 name string 最初发布时该Track的名称。 subscribed boolean 指示本地参与者是否已订阅此Track。 track Track 如果本地参与者已订阅，则可以获取关联的Track对象。 muted boolean 此Track是否被本地参与者静音。静音时，它不会从服务器接收新字节。 认证要使 LiveKit 客户端成功连接到服务器，必须通过请求传递访问令牌。此令牌对参与者的身份、聊天室名称、功能和权限进行编码。访问令牌是基于 JWT 的，并使用您的 API 密钥进行签名，以防止伪造。 访问令牌还具有过期时间，在此时间之后，服务器将拒绝与该令牌的连接。注意：过期时间仅影响初始连接，不会影响后续重新连接。 创建令牌1234567891011121314151617181920212223import ( &quot;time&quot; lksdk &quot;github.com/livekit/server-sdk-go&quot; &quot;github.com/livekit/protocol/auth&quot;)func getJoinToken(apiKey, apiSecret, room, identity string) (string, error) { canPublish := true canSubscribe := true at := auth.NewAccessToken(apiKey, apiSecret) grant := &amp;auth.VideoGrant{ RoomJoin: true, Room: room, CanPublish: &amp;canPublish, CanSubscribe: &amp;canSubscribe, } at.AddGrant(grant). SetIdentity(identity). SetValidFor(time.Hour) return at.ToJWT()} 令牌样例1234567891011{ &quot;exp&quot;: 1621657263,//令牌的到期时间 &quot;iss&quot;: &quot;APIMmxiL8rquKztZEoZJV9Fb&quot;,//用于颁发此令牌的 API 密钥 &quot;sub&quot;: &quot;myidentity&quot;,//参与者的唯一标识 &quot;nbf&quot;: 1619065263,//令牌生效的开始时间 &quot;video&quot;: {//视频授权，包括聊天室权限 &quot;room&quot;: &quot;myroom&quot;, &quot;roomJoin&quot;: true }, &quot;metadata&quot;: &quot;&quot;//metadata参与者元数据} token详细信息参考：token","link":"/2024/05/14/%E5%BA%93/LiveKit/LiveKit%E5%85%A5%E9%97%A8/"},{"title":"Transformers 基础","text":"Transformers 基础 环境配置1pip install transformers datasets evaluate 模型加载模型通过AutoModel.from_pretrained(&quot;模型名&quot;)方法可以加载所有存储在 Model Hub 上的模型。 123from transformers import AutoModelmodel = AutoModel.from_pretrained(&quot;bert-base-cased&quot;) 也可以先将模型下载下来，然后将模型的路径传给 from_pretrained()方法 1model = AutoModel..from_pretrained(&quot;./models/bert/&quot;) 保存模型通过save_pretrained()方法保存模型 1model.save_pretrained(&quot;./models/bert-base-cased/&quot;) 这会在保存目录下创建两个文件： config.json：模型配置文件，里面包含构建模型结构的必要参数； pytorch_model.bin：又称为 state dictionary，包含模型的所有权重； 分词器加载分词器12from transformers import AutoTokenizertokenizer = AutoTokenizer.from_pretrained(&quot;bert-base-cased&quot;) 保存分词器1tokenizer.save_pretrained(&quot;./models/bert-base-cased/&quot;) 调用 Tokenizer.save_pretrained() 函数会在保存路径下创建三个文件： special_tokens_map.json：配置文件，里面包含 unknown tokens 等特殊字符的映射关系； tokenizer_config.json：配置文件，里面包含构建分词器需要的参数； vocab.txt：词表，每一个 token 占一行，行号就是对应的 token id（从 0 开始）。 编码编码是将文本转化为 token id tokenize()：对文本序列进行分词 convert_tokens_to_ids()：将 token 转化为 token id encode()：上面两个方法的结合，并且会自动添加需要的字符（例如[CLS]） tokenizer()：直接使用分词器处理，在encode()的基础上添加 token_type_ids 和 attention_mask。并且可以指定padding、截断、指定返回格式等操作 1234567891011121314151617sequence = &quot;Using a Transformer network is simple&quot;tokens = tokenizer.tokenize(sequence)//token：['Using', 'a', 'Trans', '##former', 'network', 'is', 'simple']print(tokens)ids = tokenizer.convert_tokens_to_ids(tokens)//ids：[7993, 170, 13809, 23763, 2443, 1110, 3014]print(ids)sequence = &quot;Using a Transformer network is simple&quot;sequence_ids = tokenizer.encode(sequence)//sequence_ids：[101, 7993, 170, 13809, 23763, 2443, 1110, 3014, 102]print(sequence_ids)tokenized_text = tokenizer(&quot;Using a Transformer network is simple&quot;)//tokenized_text：{'input_ids': [101, 7993, 170, 13809, 23763, 2443, 1110, 3014, 102], //'token_type_ids': [0, 0, 0, 0, 0, 0, 0, 0, 0], //'attention_mask': [1, 1, 1, 1, 1, 1, 1, 1, 1]}print(tokenized_text) 解码解码是将 token id 转化为文本 12345678decoded_string = tokenizer.decode([7993, 170, 11303, 1200, 2443, 1110, 3014])//Using a transformer network is simpleprint(decoded_string)decoded_string = tokenizer.decode([101, 7993, 170, 13809, 23763, 2443, 1110, 3014, 102])//[CLS] Using a Transformer network is simple [SEP]print(decoded_string) Trainertransformers 提供了 Trainer 用于对模型进行微调和训练： model：模型 args：模型参数，TrainingArguments 类对象 train_dataset：训练集 eval_dataset：验证集 compute_metrics：一个方法，用于评估模型 1234567trainer = Trainer( model=model, args=training_args, train_dataset=small_train_dataset, eval_dataset=small_eval_dataset, compute_metrics=compute_metrics,) 执行训练 1trainer.train() dataset读取数据集 123from datasets import load_dataset# 加载数据集dataset = load_dataset(&quot;yelp_review_full&quot;) 使用 dataset 的 map 方法对数据进行分词，处理成可以被模型处理的数据 12345678from transformers import AutoTokenizertokenizer = AutoTokenizer.from_pretrained(&quot;bert-base-cased&quot;)def tokenize_function(examples): return tokenizer(examples[&quot;text&quot;], padding=&quot;max_length&quot;, truncation=True)tokenized_datasets = dataset.map(tokenize_function, batched=True) （可选）可以对完整数据集进行打乱和取子集的操作 12small_train_dataset = tokenized_datasets[&quot;train&quot;].shuffle(seed=42).select(range(1000))small_eval_dataset = tokenized_datasets[&quot;test&quot;].shuffle(seed=42).select(range(1000)) TrainingArgumentsTrainingArguments 类中包含了可以调整的所有超参数以及用于激活不同训练选项的标志。 12from transformers import TrainingArgumentstraining_args = TrainingArguments() compute_metricsTrainer 默认不会在训练期间评估模型，如果希望训练时评估，则需要提供一个评估函数传递给 Trainer 中，并且设置 evaluation_strategy 参数，指定哪个时期进行评估 1234def compute_metrics(eval_pred): logits, labels = eval_pred predictions = np.argmax(logits, axis=-1) return metric.compute(predictions=predictions, references=labels) 官方提供了一些简单的评估函数，通过如下代码创建： 1evaluate.load( &quot;accuracy&quot; ) 配置类初始化初始化时指定需要的参数 1resnet50d_config = ResnetConfig(block_type=&quot;bottleneck&quot;, stem_width=32, stem_type=&quot;deep&quot;, avg_down=True) 保存和加载将配置类保存在一个名为custom-resnet的文件夹内名为 config.json的文件中 1resnet50d_config.save_pretrained(&quot;custom-resnet&quot;) 通过如下方法加载 1resnet50d_config = ResnetConfig.from_pretrained(&quot;custom-resnet&quot;)","link":"/2023/05/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Transformers/Transformers%E5%9F%BA%E7%A1%80/"},{"title":"自定义Transformers模型","text":"自定义Transformers模型 自定义配置类配置类用于提供模型的配置信息，需要满足以下三点： 继承PretrainedConfig类 __init__函数需要接收kwargs参数 kwargs需要传递给父类 1234567891011121314151617181920212223242526272829303132333435from transformers import PretrainedConfigfrom typing import Listclass ResnetConfig(PretrainedConfig): model_type = &quot;resnet&quot; def __init__( self, block_type=&quot;bottleneck&quot;, layers: List[int] = [3, 4, 6, 3], num_classes: int = 1000, input_channels: int = 3, cardinality: int = 1, base_width: int = 64, stem_width: int = 64, stem_type: str = &quot;&quot;, avg_down: bool = False, **kwargs, ): if block_type not in [&quot;basic&quot;, &quot;bottleneck&quot;]: raise ValueError(f&quot;`block_type` must be 'basic' or bottleneck', got {block_type}.&quot;) if stem_type not in [&quot;&quot;, &quot;deep&quot;, &quot;deep-tiered&quot;]: raise ValueError(f&quot;`stem_type` must be '', 'deep' or 'deep-tiered', got {stem_type}.&quot;) self.block_type = block_type self.layers = layers self.num_classes = num_classes self.input_channels = input_channels self.cardinality = cardinality self.base_width = base_width self.stem_width = stem_width self.stem_type = stem_type self.avg_down = avg_down super().__init__(**kwargs) 初始化初始化时指定需要的参数 1resnet50d_config = ResnetConfig(block_type=&quot;bottleneck&quot;, stem_width=32, stem_type=&quot;deep&quot;, avg_down=True) 保存和加载将配置类保存在一个名为custom-resnet的文件夹内名为 config.json的文件中 1resnet50d_config.save_pretrained(&quot;custom-resnet&quot;) 通过如下方法加载 1resnet50d_config = ResnetConfig.from_pretrained(&quot;custom-resnet&quot;) 自定义模型官方给示例如下： 123456789101112131415161718192021222324252627import torchclass ResnetModelForImageClassification(PreTrainedModel): config_class = ResnetConfig def __init__(self, config): super().__init__(config) block_layer = BLOCK_MAPPING[config.block_type] self.model = ResNet( block_layer, config.layers, num_classes=config.num_classes, in_chans=config.input_channels, cardinality=config.cardinality, base_width=config.base_width, stem_width=config.stem_width, stem_type=config.stem_type, avg_down=config.avg_down, ) def forward(self, tensor, labels=None): logits = self.model(tensor) if labels is not None: loss = torch.nn.cross_entropy(logits, labels) return {&quot;loss&quot;: loss, &quot;logits&quot;: logits} return {&quot;logits&quot;: logits} 初始化1resnet50d = ResnetModelForImageClassification(resnet50d_config)","link":"/2023/05/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Transformers/%E8%87%AA%E5%AE%9A%E4%B9%89Transformers/"},{"title":"pytorch 基础","text":"pytorch 基础 张量张量创建张量 (Tensor) 是深度学习的基础，例如常见的 0 维张量称为标量 (scalar)、1 维张量称为向量 (vector)、2 维张量称为矩阵 (matrix)。Pytorch 本质上就是一个基于张量的数学计算工具包，它提供了多种方式来创建张量： 1234567//前两个参数（2, 3）代表两行三列。torch.empty(2, 3)torch.rand(2, 3)torch.randn(2, 3)torch.zeros(2, 3, dtype=torch.long)torch.zeros(2, 3, dtype=torch.double)torch.arange(10) 也可以通过 torch.tensor() 或者 torch.from_numpy() 基于已有的数组或 Numpy 数组创建张量： 1234array = [[1.0, 3.8, 2.1], [8.6, 4.0, 2.4]]torch.tensor(array)array = np.array([[1.0, 3.8, 2.1], [8.6, 4.0, 2.4]])torch.from_numpy(array) 如果想在GPU中处理，需要指定 123torch.rand(2, 3).cuda()torch.rand(2, 3, device=&quot;cuda&quot;)torch.rand(2, 3).to(&quot;cuda&quot;) 张量计算pytorch提供了很多张量的计算函数： torch.dot()：计算向量点积 torch.mm()：计算矩阵相乘 自动微分pytorch提供了自动计算梯度的功能，可以自动计算一个函数关于一个变量在某一取值下的导数，从而基于梯度对参数进行优化，这就是机器学习中的训练过程。使用 Pytorch 计算梯度非常容易，只需要执行 tensor.backward()，就会自动通过反向传播 (Back Propogation) 算法完成。 12345678&gt;&gt;&gt; x = torch.tensor([2.], requires_grad=True)&gt;&gt;&gt; y = torch.tensor([3.], requires_grad=True)&gt;&gt;&gt; z = (x + y) * (y - 2)&gt;&gt;&gt; print(z)tensor([5.], grad_fn=&lt;MulBackward0&gt;)&gt;&gt;&gt; z.backward()&gt;&gt;&gt; print(x.grad, y.grad)tensor([1.]) tensor([6.]) 加载数据pytorch 提供了 DataLoader 和 Dataset 类（或 IterableDataset）专门用于处理数据，它们既可以加载 Pytorch 预置的数据集，也可以加载自定义数据： Dataset（或 IterableDataset）：存储样本以及它们对应的标签 数据加载类 DataLoader：负责迭代地访问数据集中的样本 DatasetDataset 类提供了一种按照索引访问样本的方式。Dataset 数据集负责存储数据样本，所有的数据集类都必须继承自 Dataset 或 IterableDataset。Pytorch 支持两种形式的数据集： 映射型 (Map-style) 数据集：继承自 Dataset 类，表示一个从索引到样本的映射（索引可以不是整数），这样我们就可以方便地通过 dataset[idx] 来访问指定索引的样本。这也是目前最常见的数据集类型。映射型数据集必须实现 __getitem__() 函数，其负责根据指定的 key 返回对应的样本。一般还会实现 __len__() 用于返回数据集的大小。 迭代型 (Iterable-style) 数据集：继承自 IterableDataset，表示可迭代的数据集，它可以通过 iter(dataset) 以数据流 (steam) 的形式访问，适用于访问超大数据集或者远程服务器产生的数据 1234567891011121314151617class AFQMC(Dataset): def __init__(self, data_file): self.data = self.load_data(data_file) def load_data(self, data_file): Data = {} with open(data_file, 'rt') as f: for idx, line in enumerate(f): sample = json.loads(line.strip()) Data[idx] = sample return Data def __len__(self): return len(self.data) def __getitem__(self, idx): return self.data[idx] DataLoaderDataLoader 用于将数据集分批 batche 然后按批次送入模型，所有批次训练完一次后称为一个 epoch 。Pytorch 提供了 DataLoader 类专门负责处理这些操作，除了基本的 dataset（数据集），常用参数： batch_size：batch大小 shuffle：是否打乱数据集 sampler：采样器，也就是一个索引上的迭代器 collate_fn：批处理函数，用于对采样出的一个 batch 中的样本进行处理（例如 Padding 操作） SamplerSampler 用于 Dataset 类，通过 Sampler 对象来设置加载时的索引序列，即设置一个索引上的迭代器。如果设置了 shuffle 参数，DataLoader 就会自动创建一个顺序或乱序的 Sampler，我们也可以通过 sampler 参数传入一个自定义的 Sampler 对象。 常见的 Sampler 对象包括序列采样器 SequentialSampler 和随机采样器 RandomSampler，它们都通过传入待采样的数据集来创建 12345train_sampler = RandomSampler(training_data)test_sampler = SequentialSampler(test_data)//使用train_dataloader = DataLoader(training_data, batch_size=64, sampler=train_sampler)test_dataloader = DataLoader(test_data, batch_size=64, sampler=test_sampler) collate_fn批处理函数 collate_fn 负责对每一个采样出的 batch 中的样本进行处理。默认的 collate_fn 会进行如下操作： 添加一个新维度作为 batch 维 自动地将 NumPy 数组和 Python 数值转换为 PyTorch 张量 保留原始的数据结构，例如输入是字典的话，它会输出一个包含同样键 (key) 的字典，但是将值 (value) 替换为 batched 张量（如何可以转换的话） 模型模型构建自定义一个模型类需要如下操作： 继承mm.Module类或其子类 __init__() 初始化模型中的层和参数 forward() 中定义模型的操作 123456789101112131415161718192021222324252627282930313233343536373839import torchfrom torch import nndevice = 'cuda' if torch.cuda.is_available() else 'cpu'print(f'Using {device} device')class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 256), nn.ReLU(), nn.Linear(256, 10), nn.Dropout(p=0.2) ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)print(model)--------------------------------------------------------------------------Using cpu deviceNeuralNetwork( (flatten): Flatten(start_dim=1, end_dim=-1) (linear_relu_stack): Sequential( (0): Linear(in_features=784, out_features=512, bias=True) (1): ReLU() (2): Linear(in_features=512, out_features=256, bias=True) (3): ReLU() (4): Linear(in_features=256, out_features=10, bias=True) (5): Dropout(p=0.2, inplace=False) )) 优化模型参数模型训练是一个迭代的过程，每一轮 epoch 迭代中模型都会对输入样本进行预测，然后对预测结果计算损失 (loss)，并求 loss 对每一个模型参数的偏导，最后使用优化器更新所有的模型参数。 损失函数 （Loss function）：用于度量预测值与答案之间的差异，模型的训练过程就是最小化损失函数。Pytorch 实现了很多常见的损失函数，例如： 用于回归任务的均方误差 (Mean Square Error) nn.MSELoss、 用于分类任务的负对数似然 (Negative Log Likelihood) nn.NLLLoss、 同时结合了 nn.LogSoftmax 和 nn.NLLLoss 的交叉熵损失 (Cross Entropy) nn.CrossEntropyLoss 等。 优化器 (Optimization) 使用特定的优化算法（例如随机梯度下降），通过在每一个训练阶段 (step) 减少（基于一个 batch 样本计算的）模型损失来调整模型参数。Pytorch 实现了很多优化器，例如 SGD、ADAM、RMSProp 等。 每一轮迭代 (Epoch) 实际上包含了两个步骤： 训练循环 (The Train Loop)：在训练集上进行迭代，尝试收敛到最佳的参数； 验证/测试循环 (The Validation/Test Loop)：在测试/验证集上进行迭代以检查模型性能有没有提升。 优化器通过以下三个步骤进行优化： 调用 optimizer.zero_grad() 重设模型参数的梯度。默认情况下梯度会进行累加，为了防止重复计算，在每个训练阶段开始前都需要清零梯度 通过 loss.backwards() 反向传播预测结果的损失，即计算损失对每一个参数的偏导 调用 optimizer.step() 根据梯度调整模型的参数 训练过程： 123456789101112131415161718192021training_data = datasets.FashionMNIST( root=&quot;data&quot;, train=True, download=True, transform=ToTensor())model.train()for batch, (X, y) in enumerate(training_data, start=1): X, y = X.to(device), y.to(device) # 计算预测值和损失函数 pred = model(X) loss = loss_fn(pred, y) # 反向传播 optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: {loss:&gt;7f} [{current:&gt;5d}/{size:&gt;5d}]&quot;) 保存模型通过 torch.save() 保存模型权重 123model = models.vgg16(pretrained=True)# 保存到指定位置torch.save(model.state_dict(), 'model_weights.pth') 保存完整模型 12model = models.vgg16(pretrained=True)torch.save(model, 'model.pth') 加载模型通过 Model.state_dict() 加载模型权重 1234# 先创建模型实例model = models.vgg16()# 加载权重model.load_state_dict(torch.load('model_weights.pth')) 加载完整模型 1model = torch.load('model.pth')","link":"/2023/04/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/pytorch%E5%9F%BA%E7%A1%80/"},{"title":"pytorch 示例","text":"pytorch 示例 加载数据集DataSet数据集 1{'sentence1': '蚂蚁借呗等额还款可以换成先息后本吗', 'sentence2': '借呗有先息到期还本吗', 'label': '0'} 自定义Dataset 12345678910111213141516171819202122232425from torch.utils.data import Datasetimport jsonclass AFQMC(Dataset): def __init__(self, data_file): self.data = self.load_data(data_file) def load_data(self, data_file): Data = {} with open(data_file, 'rt') as f: for idx, line in enumerate(f): sample = json.loads(line.strip()) Data[idx] = sample return Data def __len__(self): return len(self.data) def __getitem__(self, idx): return self.data[idx]train_data = AFQMC('data/afqmc_public/train.json')valid_data = AFQMC('data/afqmc_public/dev.json')print(train_data[0]) 如果数据集非常巨大，难以一次性加载到内存中，我们也可以继承 IterableDataset 类构建迭代型数据集： 12345678910111213141516from torch.utils.data import IterableDatasetimport jsonclass IterableAFQMC(IterableDataset): def __init__(self, data_file): self.data_file = data_file def __iter__(self): with open(self.data_file, 'rt') as f: for line in f: sample = json.loads(line.strip()) yield sampletrain_data = IterableAFQMC('data/afqmc_public/train.json')print(next(iter(train_data))) DataLoader通过 DataLoader 库按 batch 加载数据，并且将样本转换成模型可以接受的输入格式。对于 NLP 任务，这个环节就是将每个 batch 中的文本按照预训练模型的格式进行编码（包括 Padding、截断等操作）。 123456789101112131415161718192021222324252627import torchfrom torch.utils.data import DataLoaderfrom transformers import AutoTokenizercheckpoint = &quot;bert-base-chinese&quot;tokenizer = AutoTokenizer.from_pretrained(checkpoint)def collote_fn(batch_samples): batch_sentence_1, batch_sentence_2 = [], [] batch_label = [] for sample in batch_samples: batch_sentence_1.append(sample['sentence1']) batch_sentence_2.append(sample['sentence2']) batch_label.append(int(sample['label'])) X = tokenizer( batch_sentence_1, batch_sentence_2, padding=True, truncation=True, return_tensors=&quot;pt&quot; ) y = torch.tensor(batch_label) return X, ytrain_dataloader = DataLoader(train_data, batch_size=4, shuffle=True, collate_fn=collote_fn)batch_X, batch_y = next(iter(train_dataloader)) 建立模型自定义模型123456789101112131415161718device = 'cuda' if torch.cuda.is_available() else 'cpu'print(f'Using {device} device')class BertForPairwiseCLS(nn.Module): def __init__(self): super(BertForPairwiseCLS, self).__init__() self.bert_encoder = AutoModel.from_pretrained(checkpoint) self.dropout = nn.Dropout(0.1) self.classifier = nn.Linear(768, 2) def forward(self, x): bert_output = self.bert_encoder(**x) cls_vectors = bert_output.last_hidden_state[:, 0, :] cls_vectors = self.dropout(cls_vectors) logits = self.classifier(cls_vectors) return logitsmodel = BertForPairwiseCLS().to(device) 训练模型参数更新过程 12345678910111213141516171819202122232425262728293031323334353637from tqdm.auto import tqdmdef train_loop(dataloader, model, loss_fn, optimizer, lr_scheduler, epoch, total_loss): progress_bar = tqdm(range(len(dataloader))) progress_bar.set_description(f'loss: {0:&gt;7f}') finish_step_num = (epoch-1)*len(dataloader) model.train() for step, (X, y) in enumerate(dataloader, start=1): X, y = X.to(device), y.to(device) pred = model(X) loss = loss_fn(pred, y) optimizer.zero_grad() loss.backward() optimizer.step() lr_scheduler.step() total_loss += loss.item() progress_bar.set_description(f'loss: {total_loss/(finish_step_num + step):&gt;7f}') progress_bar.update(1) return total_lossdef test_loop(dataloader, model, mode='Test'): assert mode in ['Valid', 'Test'] size = len(dataloader.dataset) correct = 0 model.eval() with torch.no_grad(): for X, y in dataloader: X, y = X.to(device), y.to(device) pred = model(X) correct += (pred.argmax(1) == y).type(torch.float).sum().item() correct /= size print(f&quot;{mode} Accuracy: {(100*correct):&gt;0.1f}%\\n&quot;) 训练过程 12345678910111213141516171819learning_rate = 1e-5epoch_num = 3loss_fn = nn.CrossEntropyLoss()optimizer = AdamW(model.parameters(), lr=learning_rate)lr_scheduler = get_scheduler( &quot;linear&quot;, optimizer=optimizer, num_warmup_steps=0, num_training_steps=epoch_num*len(train_dataloader),)total_loss = 0.for t in range(epoch_num): print(f&quot;Epoch {t+1}/{epoch_num}\\n-------------------------------&quot;) total_loss = train_loop(train_dataloader, model, loss_fn, optimizer, lr_scheduler, t+1, total_loss) test_loop(valid_dataloader, model, mode='Valid')print(&quot;Done!&quot;) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import randomimport osimport numpy as npimport jsonimport torchfrom torch import nnfrom torch.utils.data import Dataset, DataLoaderfrom transformers import AutoTokenizer, AutoConfigfrom transformers import BertPreTrainedModel, BertModelfrom transformers import AdamW, get_schedulerfrom tqdm.auto import tqdmdef seed_everything(seed=1029): random.seed(seed) os.environ['PYTHONHASHSEED'] = str(seed) np.random.seed(seed) torch.manual_seed(seed) torch.cuda.manual_seed(seed) torch.cuda.manual_seed_all(seed) # some cudnn methods can be random even after fixing the seed # unless you tell it to be deterministic torch.backends.cudnn.deterministic = Truedevice = 'cuda' if torch.cuda.is_available() else 'cpu'print(f'Using {device} device')seed_everything(42)learning_rate = 1e-5batch_size = 4epoch_num = 3checkpoint = &quot;bert-base-chinese&quot;tokenizer = AutoTokenizer.from_pretrained(checkpoint)class AFQMC(Dataset): def __init__(self, data_file): self.data = self.load_data(data_file) def load_data(self, data_file): Data = {} with open(data_file, 'rt') as f: for idx, line in enumerate(f): sample = json.loads(line.strip()) Data[idx] = sample return Data def __len__(self): return len(self.data) def __getitem__(self, idx): return self.data[idx]train_data = AFQMC('data/afqmc_public/train.json')valid_data = AFQMC('data/afqmc_public/dev.json')def collote_fn(batch_samples): batch_sentence_1, batch_sentence_2 = [], [] batch_label = [] for sample in batch_samples: batch_sentence_1.append(sample['sentence1']) batch_sentence_2.append(sample['sentence2']) batch_label.append(int(sample['label'])) X = tokenizer( batch_sentence_1, batch_sentence_2, padding=True, truncation=True, return_tensors=&quot;pt&quot; ) y = torch.tensor(batch_label) return X, ytrain_dataloader = DataLoader(train_data, batch_size=batch_size, shuffle=True, collate_fn=collote_fn)valid_dataloader= DataLoader(valid_data, batch_size=batch_size, shuffle=False, collate_fn=collote_fn)class BertForPairwiseCLS(BertPreTrainedModel): def __init__(self, config): super().__init__(config) self.bert = BertModel(config, add_pooling_layer=False) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(768, 2) self.post_init() def forward(self, x): outputs = self.bert(**x) cls_vectors = outputs.last_hidden_state[:, 0, :] cls_vectors = self.dropout(cls_vectors) logits = self.classifier(cls_vectors) return logitsconfig = AutoConfig.from_pretrained(checkpoint)model = BertForPairwiseCLS.from_pretrained(checkpoint, config=config).to(device)def train_loop(dataloader, model, loss_fn, optimizer, lr_scheduler, epoch, total_loss): progress_bar = tqdm(range(len(dataloader))) progress_bar.set_description(f'loss: {0:&gt;7f}') finish_step_num = (epoch-1)*len(dataloader) model.train() for step, (X, y) in enumerate(dataloader, start=1): X, y = X.to(device), y.to(device) pred = model(X) loss = loss_fn(pred, y) optimizer.zero_grad() loss.backward() optimizer.step() lr_scheduler.step() total_loss += loss.item() progress_bar.set_description(f'loss: {total_loss/(finish_step_num + step):&gt;7f}') progress_bar.update(1) return total_lossdef test_loop(dataloader, model, mode='Test'): assert mode in ['Valid', 'Test'] size = len(dataloader.dataset) correct = 0 model.eval() with torch.no_grad(): for X, y in dataloader: X, y = X.to(device), y.to(device) pred = model(X) correct += (pred.argmax(1) == y).type(torch.float).sum().item() correct /= size print(f&quot;{mode} Accuracy: {(100*correct):&gt;0.1f}%\\n&quot;) return correctloss_fn = nn.CrossEntropyLoss()optimizer = AdamW(model.parameters(), lr=learning_rate)lr_scheduler = get_scheduler( &quot;linear&quot;, optimizer=optimizer, num_warmup_steps=0, num_training_steps=epoch_num*len(train_dataloader),)total_loss = 0.best_acc = 0.for t in range(epoch_num): print(f&quot;Epoch {t+1}/{epoch_num}\\n-------------------------------&quot;) total_loss = train_loop(train_dataloader, model, loss_fn, optimizer, lr_scheduler, t+1, total_loss) valid_acc = test_loop(valid_dataloader, model, mode='Valid') if valid_acc &gt; best_acc: best_acc = valid_acc print('saving new weights...\\n') torch.save(model.state_dict(), f'epoch_{t+1}_valid_acc_{(100*valid_acc):0.1f}_model_weights.bin')print(&quot;Done!&quot;)","link":"/2023/04/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/pytorch%E7%A4%BA%E4%BE%8B/"},{"title":"中介者模式、","text":"当一系列同事对象之间发生通信时，调用关系非常复杂，为了减少耦合，可以创建一个中介对象，用于统一管理同事，当一个同事想要向其他同事发送请求时，只需要向中介发送请求，再由中介进行转发即可。 中介者（Mediator）：定义各同事对象之间交互的接口，协调各个同事对象的交互行为，降低同事之间的耦合度。 同事类（Colleague）：知道中介者对象的存在，与中介者对象交互，通过中介者对象与其他同事对象通信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 中介接口 interface Mediator { // 注册 void register(Colleague colleague); // 客户注册 // 取消注册 void unregister(Colleague colleague); // 转发请求 void send(String from, String to, String message); // 转发 } // 中介实现类 class ConcreteMediator implements Mediator { private List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;(); @Override public void register(Colleague colleague) { colleagues.add(colleague); } @Override public void unregister(Colleague colleague) { colleagues.remove(colleague); } // 转发请求 @Override public void send(String from, String to, String message) { for (Colleague colleague : colleagues) { if (colleague.name.equals(to)) { colleague.receive(from, message); } } } } // 同事类 abstract class Colleague { // 中介 Mediator mediator; // 名字 String name; public Colleague(String name, Mediator mediator) { this.name = name; this.mediator = mediator; } // 发送请求 public abstract void Send(String to, String message); // 接收请求的方法 public abstract void receive(String from, String message); } class ConcreteColleague extends Colleague { public ConcreteColleague(String name, Mediator mediator) { super(name, mediator); } //发送消息，调用中介 @Override public void Send(String to, String message) { mediator.send(name, to, message); } @Override public void receive(String from, String message) { System.out.println(&quot;接收请求&quot;); } } public class Main { public static void main(String[] args) { Mediator mediator = new ConcreteMediator(); Colleague colleague1 = new ConcreteColleague(&quot;同事1&quot;, mediator); Colleague colleague2 = new ConcreteColleague(&quot;同事2&quot;, mediator); // 将同事注册到中介 mediator.register(colleague1); mediator.register(colleague2); // 同事1向同事2发送消息 colleague1.Send(&quot;同事2&quot;, &quot;消息&quot;); } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"命令模式","text":"调用者发送请求，接收器接收请求并完成，为了更方便的处理他们之间的请求，可以在调用者和接收器之间添加一个命令类，调用的方式为：调用者-&gt;命令-&gt;接收器。 抽象命令类（Command）：声明执行命令的接口； 具体命令角色（Concrete Command）：命令类的具体实现类，用于接受调用者的请求，然后调用接收器； 接收器（Receiver）：实现命令的具体逻辑代码； 调用者（Invoker）：是请求的发送者。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 命令抽象类 interface Command { // 执行 public void excute(); // 回滚 public void undo(); } // 命令实现类，用于 class ConcreteCommand implements Command { private Receiver receiver; public ConcreteCommand(Receiver receiver) { this.receiver = receiver; } @Override public void excute() { receiver.exec(); } @Override public void undo() { receiver.undo(); } } // 接收者 class Receiver { public void exec() { System.out.println(&quot;处理请求&quot;); } public void undo() { System.out.println(&quot;回滚请求&quot;); } } // 调用者 class Invoker { public void CommandExecute(Command command) { command.excute(); } public void CommandUndo(Command command) { command.undo(); } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"title":"策略模式","text":"完成一项任务需要按顺序调用多个方法，可以在父类定义好方法的流程和顺序，子类提供各个方法的具体实现。 123456789101112131415161718192021222324252627282930313233abstract class Template { // 假如必须要按照抽烟、喝酒、烫头的顺序才能完成happy方法 protected void happy() { this.smoke(); this.drink(); this.Perm(); } public abstract void smoke(); public abstract void drink(); public abstract void Perm(); } class ATemplate extends Template { @Override public void smoke() { System.out.println(&quot;抽烟&quot;); } @Override public void drink() { System.out.println(&quot;喝酒&quot;); } @Override public void Perm() { System.out.println(&quot;烫头&quot;); } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"},{"title":"备忘录模式","text":"也叫快照模式，获取一个对象的内部状态，并在该对象之外保存这个状态，当需要时能将该对象恢复到原先保存的状态。 发起人（Originator）：负责创建一个备忘录，记录自身需要保存的状态，而且需要具备状态的回滚功能。 备忘录（Memento）：用于存储Originator角色的内部状态，且可以防止Originator以外的对象进行访问。 管理者（Caretaker）：负责存储，管理备忘录。且其本身应该无法对备忘录的内容进行访问。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 备忘录基类 interface MementoIF { } // 备忘录实现类 class Memento implements MementoIF { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } // 发起者 class Originator { private String state; // 生成备忘录 public Memento saveToMemento() { return new Memento(state); } // 从备忘录中恢复状态 public String getStateFromMemento(MementoIF memento) { return ((Memento) memento).getState(); } } // 管理者 class CareTaker { // 保存备忘录的集合 private List&lt;MementoIF&gt; mementoList = new ArrayList&lt;MementoIF&gt;(); // 添加备忘录 public void add(MementoIF memento) { mementoList.add(memento); } // 获取某个备忘录 public MementoIF get(int index) { return mementoList.get(index); } } 使用时创建一个管理者，当需要保存发起者的状态时，生成备忘录，然后保存到管理者中，需要恢复时可以将备忘录传入发起者恢复状态。","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"},{"title":"状态模式","text":"一个对象可能拥有多种状态，每种状态的行为也不同，状态模式使用状态转换机处理对象状态的变化。 状态基类（State）：规定一个状态应该具有什么功能； 状态实现类（Concrete State）：每种状态功能的具体实现； 环境（Context）：具有多种状态的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485interface State { void exec(); } class StateA implements State { private Context context; public StateA(Context context) { this.context = context; } @Override public void exec() { System.out.println(&quot;抽烟&quot;); // 抽完烟后就该喝酒了 context.setState(context.drink); } } class StateB implements State { private Context context; public StateB(Context context) { this.context = context; } @Override public void exec() { System.out.println(&quot;喝酒&quot;); context.setState(context.perm); } } class StateC implements State { private Context context; public StateC(Context context) { this.context = context; } @Override public void exec() { System.out.println(&quot;烫头&quot;); context.setState(context.smoke); } } // 代表一个人，这个人有三种状态，并且必须按顺序执行：抽烟-&gt;喝酒-&gt;烫头-&gt;抽烟 class Context { // 定义所有的状态 State smoke; State drink; State perm; // 当亲状态 private State currentState; // 初始状态 public Context() { smoke = new StateA(this); drink = new StateB(this); perm = new StateC(this); // 设置一个初始状态 this.currentState = smoke; } // 执行方法 public void exec() { System.out.println(&quot;指令:开始移动&quot;); currentState.exec(); } public void setState(State state) { this.currentState = state; } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"策略模式","text":"一个方法可能有多种实现策略，根据外部环境的不同选择具体策略。 策略基类（Strategy）：用于定义该策略方法； 策略实现类（ConcreteStrategy）：定义具体实现； 环境（Context）：外部环境，通过组合的方式获取策略；1234567891011121314151617181920212223242526272829//抽象策略类 interface Strategy { public void strategyMethod(); //策略方法 } //具体策略类A class ConcreteStrategyA implements Strategy { public void strategyMethod() { System.out.println(&quot;具体策略A的策略方法被访问！&quot;); } } //具体策略类B class ConcreteStrategyB implements Strategy { public void strategyMethod() { System.out.println(&quot;具体策略B的策略方法被访问！&quot;); } } //环境类 class Context { private Strategy strategy; public Strategy getStrategy() { return strategy; } public void setStrategy(Strategy strategy) { this.strategy = strategy; } public void strategyMethod() { strategy.strategyMethod(); } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"访问者模式","text":"在不改变元素类内数据结构的前提下，为每个元素提供多种访问方式，将访问操作和数据结构分离。对于一个元素来说，不同的访问器关注的点不同，例如对于一个多语言的文档元素，中文访问器访问中文内容，英文访问器访问英文内容。 Visitor（访问者）：访问者接口，定义了用于访问元素的方法； ConcreteVisitor（具体访问者）：实现了访问元素的方法； Element（元素）：被访问对象，内部包含自己的数据结构； ConcreteElement（具体元素）：元素的具体实现。 ObjectStructure（对象结构）：保存一系列元素，提供访问内部元素的方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 访问者接口interface Visitor { void visit(Element element); } // 访问器的具体实现，这里时一个中文访问器 class ConcreteVisitor implements Visitor { @Override public void visit(Element element) { if (element instanceof ConcreteElement) System.out.println(((ConcreteElement) element).chineseName); } } interface Element { void accept(Visitor visitor); } class ConcreteElement implements Element { // 元素的中英文名字 public String chineseName = &quot;中文名&quot;; public String englishName = &quot;中文名&quot;; // 接受访问，会调用所提供的访问器来访问元素 @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 保存元素集合 class ObjectStructure { private List&lt;Element&gt; elements = new ArrayList&lt;&gt;(); // 添加元素 public void add(Element element) { elements.add(element); } // 访问元素，根据传入访问器不同会访问不同的元素 public void print(Visitor visitor) { for (Element e : elements) { e.accept(visitor); } } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"责任链模式","text":"对于一个待处理的请求，可能需要一个或多个处理器进行处理，使用if判断然后选择处理器的方式耦合度太高，可以将这些处理器组成一个责任链，这样可以将请求与处理器解耦。 处理器（Handler）：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 处理器实现类（Concrete Handler）：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 所要处理的请求 class Request { public int level; public Request(int level) { this.level = level; } } // 迭代器接口 abstract class Handler { public Handler nextHandler = null; abstract void handle(Request request); // 设置责任链的下一个处理器 public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } } // 迭代器实现 class AHandler extends Handler { @Override public void handle(Request request) { if (request.level &lt; 5) { System.out.println(&quot;A处理了请求&quot;); } else { nextHandler.handle(request); } } } class BHandler extends Handler { @Override public void handle(Request request) { if (request.level &lt; 10) { System.out.println(&quot;B处理了请求&quot;); } else { nextHandler.handle(request); } } } class CHandler extends Handler { @Override public void handle(Request request) { System.out.println(&quot;C处理了请求&quot;); } } class HandlerChain{ public static Handler createHandlerChain(){ AHandler aHandler = new AHandler(); BHandler bHandler = new BHandler(); CHandler cHandler = new CHandler(); aHandler.setNextHandler(bHandler); bHandler.setNextHandler(cHandler); return aHandler; } } public class Main { public static void main(String[] args) { Handler handlerChain = HandlerChain.createHandlerChain(); Request request = new Request(5); handlerChain.handle(request); } } 通过客户端创建责任链，然后返回第一个处理器，每个处理器都保存着下一个处理器的引用，将请求创建后放入处理器即可处理请求。","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"title":"迭代器模式","text":"提供一种方法，可以顺序访问集合中的元素, 而又无须暴露该对象的内部表示。 抽象迭代器（Iterator）：定义了遍历聚合对象所需的方法，包括hashNext()和next()方法等，用于遍历聚合对象中的元素。 具体迭代器（Concrete Iterator）：它是实现迭代器接口的具体实现类，负责具体的遍历逻辑。它保存了当前遍历的位置信息，并可以根据需要向前或向后遍历集合元素。 抽象聚合器（Aggregate）：集合类接口，例如Java中的Collection接口，List接口、Set接口等。 具体聚合器（ConcreteAggregate）：集合的具体实现类，比如HashSet、LinkedList。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 迭代器接口 interface Iterator { boolean hasNext(); Object next(); } // 集合接口 interface Aggregate { void add(Integer o); void remove(Integer o); } // 集合类实现 class ConcreteAggregate implements Aggregate { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 获取迭代器 public Iterator getIterator() { return new ConcreteIterator(); } // 迭代器实现 class ConcreteIterator implements Iterator { int currentIndex; public ConcreteIterator() { this.currentIndex = 0; } @Override public boolean hasNext() { return currentIndex&gt;=list.size(); } @Override public Object next() { Integer i = list.get(currentIndex); currentIndex++; return i; } } // 集合方法... @Override public void add(Integer o) { list.add(o); } @Override public void remove(Integer o) { list.remove(o); } }","link":"/2023/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%B3%E7%B3%BB%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"单例模式","text":"确保一个类最多只有一个实例，并提供一个全局访问点。 1. 预加载类初始化时创建对象，用时直接返回。 123456789101112public class PreloadSingleton { public static PreloadSingleton instance = new PreloadSingleton(); //其他的类无法实例化单例类的对象 private PreloadSingleton() { }; public static PreloadSingleton getInstance() { return instance; }} 2. 懒加载用到时才创建对象 2.1. 线程不安全1234567891011121314151617public class Singleton { private static Singleton instance=null; private Singleton(){ }; public static Singleton getInstance() { if(instance==null) { instance=new Singleton(); } return instance; }} 2.2. 线程安全 同步方法：可以直接在方法上加锁，但这样效率太低，只需要在创建对象时加锁即可1234567891011public class Singleton { private static Singleton instance = null; private Singleton() { }; public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 同步代码块：由于可能多个线程同时进入if内，需要使用双重判断123456789101112131415public class Singleton { private static Singleton instance = null; private Singleton() { }; public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.Class) { if (instance == null) { instance = new Singleton(); } } } return instance; }}","link":"/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"原型模式","text":"通过复制现有实例来创建新的实例，用于创建重复对象。 Java中实现Cloneable接口，然后在类中重写Object中的clone()方法，然后通过类调用clone()方法才能克隆成功，如果不实现这个接口，则会抛出CloneNotSupportedException异常。clone()方法是一个native方法，会调用底层代码实现浅拷贝 1protected native Object clone() throws CloneNotSupportedException; 1. 浅拷贝12345678910111213141516171819class Student{ public String name; public int age; } class School implements Cloneable{ public Student student; public String name; // 不会生成新的Student对象，会引用旧的 @Override public School clone() { try { return (School) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } } } 2. 深拷贝在Java中，如果想实现深拷贝，则需要让属性也实现 1234567891011121314151617181920212223242526272829class Student implements Cloneable{ public String name; public int age; @Override public Student clone() { try { return (Student) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } } } class School implements Cloneable{ public Student student; public String name; // 会生成新的Student对象 @Override public School clone() { try { return (School) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } } }","link":"/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"工厂模式","text":"用于创建对象的类。 1. 简单工厂创建一个工厂类，用于创建各种对象。 12345678910111213141516public class SimpleFactory { public Phone createPhone() { return new Phone(); } public TV createTV() { return new TV(); }}public class Main{ public static void main(String[] args){ // 直接使用工厂创建对象 SimpleFactory simpleFactory = new SimpleFactory(); Phone phone = simpleFactory.createPhone(); }} 2. 工厂方法模式定义了一个创建对象的抽象接口，由子类决定要实例化的类。 123456789101112131415161718192021222324// 创建工厂接口public interface PhoneFactory{ abstract Phone createPhone(); // ...}// 对于每种类型的对象都创建一个工厂类public class APhoneFactory implement PhoneFactory{ APhone createPhone() { return new APhone(); } //...}public class BPhoneFactory implement PhoneFactory{ // ...}public class Main{ public static void main(String[] args){ // 创建需要的工厂类，然后创建对象 PhoneFactory aPhoneFactory = new APhoneFactory(); Phone aPhone = aPhoneFactory.createPhone(); }} 3. 抽象工厂模式定义了一个用于创建一组对象的接口。 12345678910111213141516171819202122232425262728293031323334// 创建工厂接口，可以创建多种产品，例如手机厂商还会生产TVpublic interface PhoneFactory{ abstract Phone createPhone(); abstract TV createTV(); // ...}// 对于每种类型的对象都创建一个工厂类public class APhoneFactory implement PhoneFactory{ APhone createPhone() { return new APhone(); } ATV createTV() { return new ATV(); } //...}public class BPhoneFactory implement PhoneFactory{ // ...}public class Main{ public static void main(String[] args){ // 创建需要的工厂类，然后创建对象 PhoneFactory aPhoneFactory = new APhoneFactory(); // 创建手机 Phone aPhone = aPhoneFactory.createPhone(); // 创建TV TV aTV = aPhoneFactory.createTV(); }}","link":"/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"建造者模式","text":"用于封装一系列对象创建过程的类，一般对象构造过程比较复杂，例如有可选参数、需要多个步骤等。 产品（Product）：具体生产器要构造的复杂对象； 抽象生成器（Bulider）：抽象生成器是一个接口，该接口除了为创建一个Product对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法（定义构造步骤）； 具体生产器（ConcreteBuilder）：实现Builder接口的类，具体生成器将实现Builder接口所定义的方法（生产各个组件）； 例如创建DataSource时需要指定相关信息，还需要配置一些默认配置，过程相对复杂，可以使用建造者模式 123456789101112131415161718192021222324252627282930313233343536373839abstract class Builder{ public DataSource build(){} } class DruidDataSourceBuilder{ public String username; public String password; public String jdbcUrl; public String driverClassName; public void setPassword(String password) { this.password = password; } public void setUsername(String username) { this.username = username; } public void setJdbcUrl(String jdbcUrl) { this.jdbcUrl = jdbcUrl; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public DataSource build(){ // 进行对象创建过程... DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setTestWhileIdle(true); dataSource.setTimeBetweenEvictionRunsMillis(60000); dataSource.setMaxActive(20); // ... return dataSource; } }","link":"/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"享元模式","text":"池化技术，将共享资源集中管理，需要时返回现有资源，减小开销。 Flyweight （享元抽象类）：享元对象抽象基类或者接口，同时定义出对象的外部状态和内部状态的接口或实现； ConcreteFlyweight（具体享元类）：实现抽象享元类中的方法，是需要共享的对象类； FlyweightFactory（享元工厂类）：维护一个享元对象的池。 123456789101112131415161718192021222324252627282930313233343536// 享元，可以共享的单元 interface IFlyweight { void print(); } // 享元具体实现 class Flyweight implements IFlyweight { private String id; public Flyweight(String id) { this.id = id; } @Override public void print() { System.out.println(&quot;Flyweight.id = &quot; + getId() + &quot; ...&quot;); } public String getId() { return id; } } // 管理享元类 class FlyweightFactory { private Map&lt;String, IFlyweight&gt; flyweightMap = new HashMap(); public IFlyweight getFlyweight(String str) { // 如果不存在则新建一个，否则直接返回 return flyweightMap.computeIfAbsent(str, Flyweight::new); } public int getFlyweightMapSize() { return flyweightMap.size(); } }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"title":"装饰者模式","text":"实现方式和装饰者模式类似，但代理模式并不提供新的功能，而是在原有功能上添加控制 1. 静态代理通过组合的方式调用目标对象，然后在其上下位置添加代码 1234567891011121314151617181920212223242526interface SQLOperator { void insert(); } class SQLOperatorImpl implements SQLOperator { @Override public void insert() { } } class SQLOperatorProxy implements SQLOperator { private SQLOperator sqlOperator; public SQLOperatorProxy(SQLOperator buyHouse) { this.sqlOperator = buyHouse; } @Override public void insert() { System.out.println(&quot;开启事务&quot;); sqlOperator.insert(); System.out.println(&quot;关闭事务&quot;); } } 2. 动态代理动态代理是在代码运行过程中通过反射动态生成代理对象，Java中使用动态代理分以下步骤： 创建目标对象接口 实现代理对象的handler，用于处理方法执行逻辑 使用Proxy.newProxyInstance()方法创造代理对象123456789101112131415161718192021222324252627282930313233343536373839interface SQLOperator { void insert(); } class SQLOperatorImpl implements SQLOperator { @Override public void insert() { } } class DynamicProxyHandler implements InvocationHandler { private Object object; // 以组合的方式获取目标对象 public DynamicProxyHandler(final Object object) { this.object = object; } // 代理对象调用方法时会被转发到invoke方法 // 参数列表包括：代理对象，方法对象，方法参数列表 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;开启事务&quot;); Object result = method.invoke(object, args); System.out.println(&quot;关闭事务&quot;); return result; } } class Main { public static void main(String[] args) { SQLOperator sqlOperator = new SQLOperatorImpl(); // 获取代理对象 SQLOperator proxy = (SQLOperator)Proxy.newProxyInstance(SQLOperatorImpl.class.getClassLoader(), new Class[]{SQLOperatorImpl.class}, new DynamicProxyHandler(sqlOperator)); proxy.insert(); } }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"title":"外观模式","text":"把多个子系统进行封装，只向客户端提供了一个可以访问系统的接口，隐藏具体的子系统调用过程。 外观角色（Facade）：封装子系统功能，用于被客户调用 子系统角色（SubSystem）：系统内的多个子系统12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 子系统public class CPU { public void start() { System.out.println(&quot;cpu is start...&quot;); } public void shutDown() { System.out.println(&quot;CPU is shutDown...&quot;); }} public class Disk { public void start() { System.out.println(&quot;Disk is start...&quot;); } public void shutDown() { System.out.println(&quot;Disk is shutDown...&quot;); }} public class Memory { public void start() { System.out.println(&quot;Memory is start...&quot;); } public void shutDown() { System.out.println(&quot;Memory is shutDown...&quot;); }}// 外观角色public class Computer { private CPU cpu; private Memory memory; private Disk disk; public Computer() { cpu = new CPU(); memory = new Memory(); disk = new Disk(); } public void start() { System.out.println(&quot;Computer start begin&quot;); cpu.start(); disk.start(); memory.start(); System.out.println(&quot;Computer start end&quot;); } public void shutDown() { System.out.println(&quot;Computer shutDown begin&quot;); cpu.shutDown(); disk.shutDown(); memory.shutDown(); System.out.println(&quot;Computer shutDown end...&quot;); }}","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"title":"桥接模式","text":"桥接模式用于减少实现类的数量，将抽象部分与它的实现部分分离，使它们都可以独立地变化。 比如有一个几何图形，这个图形有多种形状（如三角形、圆形）和颜色（如红色、蓝色），假设有m种图形，n种颜色，那么子类不同组合的数量就为m*n，数量太多了，并且假如要加一种颜色，那么每种形状都要创建一个子类。我们可以将图形和颜色分离，然后通过组合的方式将图形和颜色结合起来 12345678910111213141516171819202122// 形状abstract class Shape { // 组合颜色 Color color; } class Circle extends Shape { } class Rectangle extends Shape { } // 颜色interface Color { } class Blue implements Color { } class Red implements Color { }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"title":"组合模式","text":"把一组相似的对象当作一个单一的对象，依据树形结构来组合对象，表示部分以及整体层次 抽象构件（Component）：叶子节点和树枝节点的公共接口，规范它们的默认行为。 树叶构件（Leaf）：叶子节点，没有子节点。 树枝构件（Composite）：是组合中的分支节点对象，它有子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758interface Component { public void add(Component c); public void remove(Component c); public Component getChild(int i); public void operation(); } // 叶子节点 class Leaf implements Component { @Override public void add(Component c) { } @Override public void remove(Component c) { } @Override public Component getChild(int i) { return null; } @Override public void operation() { System.out.println(&quot;被访问&quot;); } } // 树枝节点 class Composite implements Component { // 子节点列表，包含叶子节点和树枝节点 private ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;(); public void add(Component c) { children.add(c); } public void remove(Component c) { children.remove(c); } public Component getChild(int i) { return children.get(i); } public void operation() { for (Component obj : children) { obj.operation(); } } }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"装饰者模式","text":"为组件添加新功能。 组件抽象（Component）：被装饰者基类； 组件（ConcreteComponent）：被装饰者； 装饰者（Decorator）：维持一个指向Component实例的引用，并定义一个与Component接口一致的接口； 装饰者（ConcreteDecorator）：具体的装饰对象，扩展功能。12345678910111213141516171819202122232425262728293031323334353637383940414243// 原本组件只有一个hello功能 interface Component { void hello(); } // 具体组件的实现 class ConcreteComponent implements Component { @Override public void hello() { System.out.println(&quot;你好&quot;); } } // 装饰者，定义组合关系，定义装饰者规范 abstract class Decorator implements Component { // 组合组件 private Component component; public Decorator(Component component) { this.component = component; } // 定义规范，新功能 abstract void sayNo(); // 通过调用组件完成组件功能 @Override public void hello() { component.hello(); } } class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } @Override void sayNo() { System.out.println(&quot;no&quot;); } }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"观察者模式","text":"观察目标对象，当不表对象发生改变时自身也需要执行相应的操作。 主题基类（Subject）：被观察者 主题实现类（ConcreteSubject）：主题实现 观察者（Observer）：观察者 观察者实现类（ConcrereObserver）：观察者实现类 12345678910111213141516171819202122232425262728293031323334353637interface Subject { public void addObserver(Observer observer); public void update(); } class ConcreteSubject implements Subject { List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); // 添加观察者 @Override public void addObserver(Observer observer) { observers.add(observer); } // 被观察者更新会触发观察者更新 @Override public void update() { for (var observer : observers) { observer.update(); } } } interface Observer { public void update(); } class ConcrereObserver implements Observer { @Override public void update() { System.out.println(&quot;观察者触发回调&quot;); } }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"适配器模式","text":"适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。 目标接口（target）：需要适配的标准接口。 源对象（source）：需要被适配的不兼容对象。 适配器对象（adapter）：充当中间转换角色，该对象将源对象转换成目标接口。 1. 继承方式实现使用继承的方式，让适配器继承source，同时实现target接口的方法 123456789101112131415161718class Source { public Integer increase(Integer num) { return num + 1; } } // 输入和输出的都是字符串类型 interface Target { String increase(String num); } // 适配器 class Adapter extends Source implements Target { @Override public String increase(String num) { return super.increase(Integer.parseInt(num)).toString(); } } 2. 组合方式实现通过组合的方式，将适配对象与目标接口组合，实现目标接口的所有方法，并在适配类中调用需要适配对象的方法。 12345678910111213141516171819class Source { public Integer increase(Integer num) { return num + 1; } } // 输入和输出的都是字符串类型 interface Target { String increase(String num); } // 适配器 class Adapter implements Target { Source source = new Source(); @Override public String increase(String num) { return source.increase(Integer.parseInt(num)).toString(); } } 3. 接口适配器当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求 12345678910111213141516171819202122232425262728class Source { public Integer increase(Integer num) { return num + 1; } } // 输入和输出的都是字符串类型 interface Target { String increase(String num); String decrease(String num); } abstract class AbstractAdapter implements Target { @Override public String decrease(String num) { return &quot;&quot;; } } // 适配器 class Adapter extends AbstractAdapter { Source source = new Source(); @Override public String increase(String num) { return source.increase(Integer.parseInt(num)).toString(); } }","link":"/2023/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"类型系统","text":"整数类型、浮点类型、布尔类型、字符类型、结构体、枚举、可空值类型、类型转换 不能从任何值类型派生类型； 对于值类型变量，没有单独的堆分配或垃圾回收开销； 值类型派生自System.ValueType(派生自System.Object)； 整数类型 关键字 取值范围 占用大小 .NET类型 sbyte -128 到 127 1byte System.SByte byte 0 到 255 1byte System.Byte short -32,768 到 32,767 2byte System.Int16 ushort 0 到 65,535 2byte System.UInt16 int -2,147,483,648 到 2,147,483,647 4byte System.Int32 uint 0 到 4,294,967,295 4byte System.UInt32 long -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 8byte System.Int64 ulong 0 到 18,446,744,073,709,551,615 8byte System.UInt64 nint 取决于平台（带符号） 32/64byte System.IntPtr nuint 取决于平台（无符号） 32/64byte System.UIntPtr BigInteger 任意大整数（带符号） System.Numerics.BigInteger 除nint和nuint外每个 C# 类型关键字都是相应 .NET 类型的别名，关键字和 .NET 类型名称是可互换 12int a = 123;System.Int32 b = 123; nint和nuint的大小和机器相关，它们和对应的 .NET 类型的别名不能互换 整数文本进制 十六进制：使用 0x 或 0X 前缀 二进制：使用 0b 或 0B 前缀（ C# 7.0） 整数文本类型整数文本的类型由其后缀确定： 以 U 或 u 为后缀：其类型为以下类型中可表示其值的第一个类型：uint、ulong 以 L 或 l 为后缀：其类型为以下类型中可表示其值的第一个类型：long、ulong 后缀为 UL、Ul、uL、ul、LU、Lu、lU 或 lu：其类型为 ulong。 如果文本没有后缀，则其类型为以下类型中可表示其值的第一个类型：int、uint、long、ulong。 如果由整数字面量所表示的值超出了 UInt64.MaxValue（18446744073709551615），则编译报错 补充： 可以将 _ 用作数字分隔符（C# 7.0） 除了nint和nuint外，每个整型类型都有 MinValue 和 MaxValue 常量，提供该类型的最小值和最大值。 编译器为 nint 和 nuint 提供适用于整数类型的操作和转换。 浮点类型 关键字 取值范围 精度 占用大小 .NET类型 float ±1.5 x 10−45 至 ±3.4 x 1038 6-9 位 4byte System.Single double ±5.0 × 10−324 到 ±1.7 × 10308 15-17 位 8byte System.Double decimal ±1.0 x 10-28 至 ±7.9228 x 1028 28-29 位 16byte System.Decimal 上表中类型关键字和相应的 .NET 类型别名可以互换 12double a = 12.3;System.Double b = 12.3; decimal 类型是小数类型，一般在所需的精度由小数点右侧的位数决定时使用。在表示小数时会更加准确 浮点数真实文本的类型由其后缀确定，如下所示： 不带后缀的文本或带有 d 或 D 后缀的文本的类型为 double 带有 f 或 F 后缀的文本的类型为 float 带有 m 或 M 后缀的文本的类型为 decimal 补充： 每个浮点类型都有 MinValue 和 MaxValue 常量，提供该类型的最小值和最大有限值。 布尔类型 关键字 取值范围 .NET类型 bool true/false System.Boolean 字符类型 关键字 取值范围 大小 .NET类型 char U+0000 到 U+FFFF 2byte System.Char 可以使用以下命令指定 char 值： 字符文本。 Unicode 转义序列，它是 \\u 后跟字符代码的十六进制表示形式（四个符号）。 十六进制转义序列，它是 \\x 后跟字符代码的十六进制表示形式。 12345678var chars = new[]{ 'j', '\\u006A', '\\x006A', (char)106,};Console.WriteLine(string.Join(&quot; &quot;, chars)); // output: j j j j 补充： char 类型支持比较、相等、增量和减量运算符 可以使用算数和逻辑位运算符对char进行操作，得出 int 类型的结果。 结构体内置的数值类型是struct，它们具有可访问的字段和方法： 1byte b = byte.MaxValue; 使用struct关键字可以创建自定义值类型，如下： 12345678910public struct MyValue{ public int x, y; public MyValue(int p1, int p2) { x = p1; y = p2; }} 枚举enum定义的是一组已命名的整型常量。所有枚举继承自 System.Enum（继承自System.ValueType）。 123456public enum MyEnum{ one = 1, two = 2, three = 3} 可空值类型普通值类型不能为null，不过可以在类型后面追加 ?，创建可为空的值类型，例如： 12//int? 是还可以包含值 null 的 int 类型int? a = null; 类型转换隐式类型转换 原类型 目标类型 sbyte short、int、long、float、double、decimal 或 nint。 byte short、ushort、int、uint、long、ulong、float、double、decimal、nint 或 nuint short int、long、float、double、decimal 或 nint ushort int、uint、long、ulong、float、double、decimal、nint 或 nuint int long、float、double、decimal 或 nint uint long、ulong、float、double、decimal 或 nuint long float、double 或 decimal ulong float、double 或 decimal float double nint long、float、double 或 decimal nuint ulong、float、double 或 decimal 从 int、uint、long、ulong、nint 或 nuint 到 float 的隐式转换以及从 long、ulong、nint 或 nuint 到 double 的隐式转换可能会丢失精准率； 任何整型数值类型都可以隐式转换为任何浮点数值类型； 不存在针对 byte 和 sbyte 类型的隐式转换 不存在从 double 和 decimal 类型的隐式转换； decimal 类型和 float 或 double 类型之间不存在隐式转换； 类型 int 的常量表达式的值如果在目标类型的范围内，则可隐式转换为 sbyte、byte、short、ushort、uint、ulong、nint 或 nuint； 显式类型转换1目标类型变量 = (目标类型)原类型变量 原类型 目标类型 sbyte byte、ushort、uint、ulong 或 nuint byte sbyte short sbyte、byte、ushort、uint、ulong 或 nuint ushort sbyte、byte 或 short int sbyte、byte、short、ushort、uint、ulong 或 nuint。 uint sbyte、byte、short、ushort 或 int long sbyte、byte、short、ushort、int、uint、ulong、nint 或 nuint ulong sbyte、byte、short、ushort、int、uint、long、nint 或 nuint float sbyte、byte、short、ushort、int、uint、long、ulong、decimal、nint 或 nuint double sbyte、byte、short、ushort、int、uint、long、ulong、float、decimal、nint 或 nuint decimal sbyte、byte、short、ushort、int、uint、long、ulong、float、double、nint 或 nuint nint sbyte、byte、short、ushort、int、uint、ulong 或 nuint nuint sbyte、byte、short、ushort、int、uint、long 或 nint 整数类型相互转换时，数值超出目标类型 若为checked（已检查上下文），则报错； 若为unchecked（未检查上下文），则放弃高位（二进制）； 整数类型相互转换时，不论正负，原值在目标类型范围内，则原值与目标值的大小相同。 （如果源类型带符号，则是符号扩展；如果源类型是无符号的，则是零扩展）； 将 decimal 值转换为整型类型时，保留整数位。如果超出范围，抛出异常； 将 double 或 float 值转换为整型类型时，保留整数位。如果数值超出目标类型 若为checked（已检查上下文），则报错； 若为unchecked（未检查上下文），则结果是目标类型的未指定值； 将 double 转换为 float 时，double 值舍入为最接近的 float 值。 如果 double 值太小或太大，无法匹配 float 类型，结果将为零或无穷大； 将 decimal 转换为 float 或 double 时，源值分别舍入为最接近的 float 或 double 值； 将 float 或 double 转换为 decimal 时 如果原值为 NaN（非数值）、无穷大或太大而无法表示为 decimal，则报错； 如果源值太小，无法表示为 decimal，结果则为零；","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E5%80%BC%E7%B1%BB%E5%9E%8B/"},{"title":"异常处理","text":"抛出异常、处理异常 抛出异常使用throw关键字抛出异常 1throw 异常对象; 举例如下 1throw new IndexOutOfRangeException(); 异常类都派生自System.Exception 捕获异常使用try-catch-finally语句处理异常，其中catch和finally必须有其中一个 12345678910111213try{ //...}catch(异常类 e){ //异常处理 //重新引发异常 throw;}finally{ //...}","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"命名空间","text":"命名空间声明和引入 声明命名空间C#程序由一个活多个文件组成，每个文件包含零个或多个命名空间。一个命名空间包含类、结构、接口、枚举、委托等类型或其他命名空间，使用namespace关键字声明命名空间 123456789101112131415161718192021222324252627282930313233343536//程序入口点是顶级语句（ C# 9 ）Console.WriteLine(&quot;顶级语句&quot;);namespace YourNamespace{ class YourClass { //程序入口点是Main方法（ C# 9以前 ），如果有顶级语句那么Main会被忽略（ C# 9 ） static void Main(string[] args) { //Your program starts here... Console.WriteLine(&quot;Main方法&quot;); } } struct YourStruct { } interface IYourInterface { } delegate int YourDelegate(); enum YourEnum { } namespace YourNestedNamespace { struct YourStruct { } }} 从 C# 10 开始，可以为文件中定义的所有类型声明命名空间，如以下示例所示： 123namespace SampleNamespace;//... 引入命名空间命名空间用来组织多个类，可以通过using关键字显式引入一个命名空间 1using 命名空间; 引入命名空间后可直接使用其中的类 12using System;Console.WriteLine(args); 如果不显式引入命名空间，并且还想使用命名空间中的类的话，需要使用全类名访问 1System.Console.WriteLine(args);","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"title":"命名空间","text":"循环语句、选择语句、跳转语句 循环语句for 循环1234for (初始化表达式; 循环条件; 迭代器){ 循环体} 初始化表达式 仅在进入循环前执行一次，通常，在该部分中声明并初始化局部循环变量 初始化部分可以使用零个或多个【2】所示的表达式 循环条件 必须为布尔表达式 迭代器 可包含用逗号分隔的零个或多个【2】所示的表达式 初始化部分表达式和迭代器部分表达式 算数运算 赋值运算 方法的调用 await 表达式 通过使用 new 运算符来创建对 foreach 语句foreach语句用于遍历实现了的每个元素 1234foreach (int element in fibNumbers){ Console.Write($&quot;{element} &quot;);} foreach可用于如下类型： 实现System.Collections.IEnumerable或 System.Collections.Generic.IEnumerable接口的类型 类型具有公共无参数 GetEnumerator 方法 GetEnumerator 方法的返回类型具有公共 Current 属性和公共无参数 MoveNext 方法（其返回类型为 bool） 如果枚举器的 Current 属性返回引用返回值，就可以使用 ref 或 ref readonly 修饰符来声明迭代变量 1234foreach (ref readonly var item in storage){ Console.Write($&quot;{item} &quot;);} await foreach（C# 8）可以使用 await foreach 语句来使用异步数据流。异步检索下一个元素时，可能会挂起循环的每次迭代 1234await foreach (var item in GenerateSequenceAsync()){ Console.WriteLine(item);} await foreach可用于以下实例 实现 IAsyncEnumerable 接口的集合类型 类型具有公共无参数 GetAsyncEnumerator 方法。 GetAsyncEnumerator 方法的返回类型具有公共 Current 属性和公共无参数 MoveNextAsync 方法（其返回类型为 Task、ValueTask 或任何其他可等待类型，其 awaiter 的 GetResult 方法返回 bool 值） 迭代变量类型可使用var关键字，由编译器推断类型 1foreach (var item in collection) { } 还可以显式指定迭代变量的类型 12IEnumerable&lt;T&gt; collection = new T[5];foreach (V item in collection) { } 2、do 循环1234do{ 循环体} while (布尔表达式); while 循环1234while (布尔表达式){ 循环条件} 选择语句if 语句基本语法123456789101112if (布尔表达式){ //... }else if (布尔表达式){ //...}else{ //...} 补充： 条件表达式上下文中，可以使用条件运算符 ? : 2、switch 语句switch语句根据与表达式匹配的模式来选择要执行的语句列表 12345678910111213switch (匹配表达式){ case 匹配模式: //... break; case 匹配模式: //... break; //无论default写在哪都是最后计算的 default: //... break;} 匹配多个case 123456789switch (匹配表达式){ case 匹配模式1: case 匹配模式2: //... break; default: break;} Case guardcase的表达式功能可能不够，需要额外的判断，这时可以使用 Case guard （必须是布尔表达式），相当于加了一个附加条件 1234567891011121314switch ((a, b)){ case (&gt; 0, &gt; 0) when a == b: //... break; case (&gt; 0, &gt; 0): //... break; default: //... break;} 补充： default可以在 switch 语句的任何位置出现。 不管在哪个位置，default总是最后计算的，并且仅在其他所有 case 模式都不匹配时计算。 在 C# 6 及更早版本中，使用 switch 语句时有以下限制： 匹配表达式必须是以下任一种类型：字符型、字符串、布尔型、整数类型或枚举类型。 跳转语句break 语句作用： 将终止最接近的封闭迭代语句（即 for、foreach、while 或 do 循环）或 switch 语句； 在嵌套循环中，break 语句仅终止包含它的最内部循环或switch语句，外层循环不受影响； continue 语句continue 语句启动最接近的封闭迭代语句（即 for、foreach、while 或 do 循环）的新迭代 gotogoto 跳转到带有标签的语句 123goto mark; //跳转Console.WriteLine(&quot;123&quot;); //这里不会执行mark: Console.WriteLine(&quot;goto&quot;); //标签 在 switch 中使用 goto 语句 12345678910int i = 2;switch (i){ case 1:Console.WriteLine(&quot;1&quot;); break; case 2: Console.WriteLine(&quot;2&quot;); //跳转到 case 1 goto case 1;} 补充： 可以使用 goto 语句退出嵌套循环 在 switch 语句中，还可使用语句 goto default跳转到 default goto后接的标签必须在当前函数内","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"引用类型","text":"字符串、记录、数组 引用类型均可派生类型 字符串 关键字 .NET类型 说明 string System.String Unicode 字符的序列 [] 可用于只读访问字符串个别字符 12string str = &quot;test&quot;;char x = str[2]; // x = 's'; 字符串声明1234567891011//只声明不初始化string s;//初始化为空 &quot;&quot;string s = System.String.Empty;//声明初始化string s = &quot;123&quot;;//使用原义标识符string s = @&quot;C:/vscode&quot;;//char数组生成字符串char[] letters = { 'A', 'B', 'C' };string alphabet = new string(letters); 说明： 字符串为不可变类型 StringBuilder在某些情况下，对字符串的大批量操作可能影响性能。 StringBuilder 类创建字符串缓冲区，可以重新分配各个字符，而不需要创建新的字符串，用于在程序执行多个字符串操控时提升性能 1234System.Text.StringBuilder sb = new System.Text.StringBuilder(&quot;012345&quot;);Console.WriteLine(sb.ToString()); //012345sb[5] = 'a';Console.WriteLine(sb.ToString()); //01234a 转义字符 转义序列 字符名称 Unicode 编码 ' 单引号 0x0027 &quot; 双引号 0x0022 \\ 反斜杠 0x005C \\0 null 0x0000 \\a 警报 0x0007 \\b Backspace 0x0008 \\f 换页 0x000C \\n 换行 0x000A \\r 回车 0x000D \\t 水平制表符 0x0009 \\v 垂直制表符 0x000B \\u Unicode 转义序列 (UTF-16) \\uHHHH（范围：0000 - FFFF；示例：\\u00E7 =“ç”） \\U Unicode 转义序列 (UTF-32) \\U00HHHHHH（范围：000000 - 10FFFF；示例：\\U0001F47D =“👽”) \\x 除长度可变外，Unicode 转义序列与“\\u”类似 \\xH[H][H][H]（范围：0 - FFFF；示例：\\x00E7、\\x0E7 或 \\xE7 =“ç”） 逐字字符串@ 特殊字符用于声明逐字字符串。 它具有以下用途： 使 C# 关键字用作标识符 1String @int = &quot;int&quot;; 将字符串中的转义字符全都按照字面量解释，只有引号 (&quot;&quot;) 不会按字面解释 123string filename1 = @&quot;c:\\documents\\files\\u0066.txt&quot;;//等同于string filename2 = &quot;c:\\\\documents\\\\files\\\\u0066.txt&quot;; 若要在 @字符串中包含双引号，双倍添加即可： 1String s = @&quot;我是&quot;&quot;&quot;&quot;引号&quot;; // 我是&quot;&quot;引号 内插字符串$ 特殊字符用于声明内插字符串，在字符串内部通过{}内插表达式 12string name = &quot;张三&quot;;string s = $&quot;name = {name}&quot;; 字符串与数字相互转换字符串 -&gt; 数字 调用数值类型的Parse()或TryParse()方法 或使用System.Convert类中Convert.ToXXX()的方法将string转换为数字 1234int i = int.Parse(&quot;321&quot;);int i2 = Convert.ToInt32(&quot;123&quot;);Console.WriteLine(i);Console.WriteLine(i2); 数字 -&gt; 字符串 使用string.Format(...)方法可以将数字转化为格式化字符串 12double i = 123456.78901;string.Format(&quot;{0:F3}&quot;, i); 访问12string s = &quot;0123456&quot;;Console.WriteLine(s[0]); //0 拼接1234//可使用 `+` 拼接字符串string s1 = &quot;123&quot;;string s2 = &quot;456&quot;;string s = s1 + s2; 记录（record）一个record是一个class或者struct，为数据模型提供了特殊的语法和行为，在以下情况考虑使用record： 像定义一个依赖于值相等的数据模型 想定义不可变对象类型 值相等对于记录，值相等是指类型匹配，并且所有的属性和字段值也匹配。对于引用类型，指的是两个引用指向一个对象。 不变性不可变类型是一种在实例化对象后就不能更改其任何属性或字段值的类型。 record和struct对比声明和实例化class和struct的语法都可用于record只需要将class关键字替换为record或使用record struct代替struct，同时recoed也支持继承 数组（array）数组声明数组分为： 一维数组 多维数组：增加逗号来增加维度 交错数组 一维数组1234// 一维数组声明int[] arr1 = new int[5];int[] arr2 = new int[] {1,2,3};int[] arr3 = { 1, 2, 3 }; 多维数组定义时通过增加[]中的逗号来显式声明数组维度 1234// 二维数组声明int[,] arr4 = new int[2,3];int[,] arr5 = { { 1, 2, 3 }, { 4, 5, 6 } }; 交错数组交错数组类似于多维数组，但多维数组时固定大小的，在声明时就已经确定并分配空间。而交错数组可以先初始化第一维然后逐步初始化之后的维数。 1234// 初始化一维int[][] arr6 = new int[6][];//初始化二维arr6[0] = { 1, 2, 3, 4 }; 数组默认值： 值类型默认为0 引用类型默认为null； 隐式数组通过var和new[]可以创建隐式类型数组，真是类型由初始化值推断 123456789// 一维隐式数组var arr = new[] { 1, 2, 3 };// 多维隐式数组var arr = new[]{ new[]{1,2,3 }, new[]{4,5,6},}; 类型化数组可以声明像声明对象的属性一样对数组的每一项进行类型化的声明，为其内部的每个初始化项声明一个名字，使用时通过.访问 123456789101112131415// 创建类化数组var contacts = new[]{ new { Name = &quot;小黑&quot;, arr = new[] { &quot;111&quot;, &quot;222&quot; } }, new { Name = &quot;小白&quot;, arr = new[] { &quot;333&quot; } }};Console.WriteLine(contacts[1].Name);Console.WriteLine(contacts[1].arr[0]); 字节数组与内置数据类型转换BitConverter类可以用于字节数组与其他内置数据类型相互转换： 将字节数组转换为其他类型：传入参数为byte数组与起始位置，会根据从传入的数组起始位置开始读对应类型占的字节数进行转换 123byte[] b = { 0,0,128,64};float f = BitConverter.ToSingle(b, 0);Console.WriteLine(f); 将其他类型转换为字节数组：BitConverter.GetBytes(value) 1byte[] i = BitConverter.GetBytes(3);","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"title":"类型系统","text":"变量、常量、默认值、文本值类型、隐式类型、匿名类型、托管类型和非托管类型、动态类型 变量显式声明123//声明变量double area;double radius = 2; 隐式声明12//编译器会分配合适的类型var double pi = 3.1415 在使用匿名类型初始化变量时，如果需要在以后访问对象的属性，则必须将变量声明为 var，因为匿名内部类是没有类型的 常量内置类型声明常量使用const关键字 用来声明常量字段或局部常量 类、结构体、数组使用readinly声明常量，在初始化后引用不能更改 也可以用来声明值类型，与const类似； 作用位置： 字段声明，可以在字段声明和构造函数中多次分配和重新分配只读字段，构造函数退出后，不能分配 readonly 字段； 在 readonly struct 类型定义中，readonly 指示结构类型是不可变的；todo 在结构类型内的实例成员声明中，readonly 指示实例成员不修改结构的状态；todo 在 ref readonly 方法返回中，readonly 修饰符指示该方法返回一个引用，且不允许向该引用写入内容；todo 12345678910public class R{ public R() { //在构造函数中可以更改，构造函数结束后无法更改 r = new A(); } const string s = &quot;&quot;; readonly A r = new A();} 默认值 类型 默认值 引用类型 null 内置整数值类型 0 内置浮点型 0 bool false char ‘\\0‘ (U + 0000) enum 表达式 (E)0 生成的值，其中 E 是枚举标识符。 struct 通过如下设置生成的值：将所有值类型的字段设置为其默认值，将所有引用类型的字段设置为 null。 default 运算符可以生成默认值 12345//使用default文本来初始化变量，使其具有其类型的默认值int a = default(int);// C# 7.1int a = default; 文本值类型文本值类型指的是C#中的文本值，例如 3.14、123f ，这些文本值已经类型化，且所有类型最终都是从System.Object派生，所以可以直接通过他们调用方法，如下： 13.14.GetType() //System.Double 隐式类型你可以使用var关键字隐式键入一个局部变量（但不是类成员）。 变量仍可在编译时获取类型，但类型是由编译器提供 1var a = 10; 匿名类型匿名类型提供了一种方便的方法，可以将一组只读属性封装到单个对象中，而无需先显式定义类型。类型名称由编译器生成，在源代码级别不可用。每个属性的类型由编译器推断。 1var v = new { Amount = 108, Message = &quot;Hello&quot; }; 如果未在匿名类型中指定成员名称，编译器将为匿名类型成员提供与用于初始化它们的属性相同的名称。 12//匿名类型的属性名称为Color和Pricenew { prod.Color, prod.Price } 声明匿名类型元素的数组 1var anonArray = new[] { new { name = &quot;apple&quot;, diam = 4 }, new { name = &quot;grape&quot;, diam = 1 }}; 补充： 用于初始化属性的表达式不能是null、匿名函数或指针类型。 不能将字段、属性、事件或方法的返回类型声明为具有匿名类型。 不能将方法、属性、构造函数或索引器的形式参数声明为具有匿名类型。 要将匿名类型或包含匿名类型的集合作为参数传递给方法，可以将参数声明为 type object。但违背了强类型原则，并不推荐。 匿名类型属于引用类型 托管类型和非托管类型托管类型 引用类型 托管类型的结构体 非托管类型 数字类型 枚举类型 指针类型 只包含非托管类型字段的用户自定义struct类型 动态类型在大多数情况下，dynamic 类型与 object 类型的行为类似。不同的是dynamic 类型变量的使用和对其成员的引用绕过编译时类型检查， 改为在运行时解析这些操作。任何非 Null 表达式都可以转换为 dynamic 类型。在运行时，dynamic 类型的变量会编译为 object 类型的变量。 因此，dynamic 类型只在编译时存在，在运行时则不存在。 123456dynamic dyn = 1;object obj = 1;//无法点进dyn.GetType()，因为在运行时才会解析System.Console.WriteLine(dyn.GetType());//可以点进obj.GetType()System.Console.WriteLine(obj.GetType());","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"模式匹配","text":"模式匹配 C# 6之前switch语句只能是：字符、字符串、布尔、整数、枚举类型之一，并且case语句只能使用常数表达式。从C# 7开始，switch 语句支持模式匹配，以下表达式和语句支持模式匹配： is表达式 switch语句 switch表达式（C# 8） 从 C# 9 开始，可在任何模式两边加上括号 1234if (input is not (float or double)){ return;} 声明和类型模式用于检查表达式的运行时类型，如果匹配成功，则将表达式结果分配给声明的变量 12345//如果不相使用“变量”，可以用下划线（弃元）代替if (表达式 is 类型 变量){ //...} 表达式结果为非null且满足以下情况之一时会通过匹配： 表达式结果与目标类型一致 表达式结果与派生自目标类型 目标类型是可为null的值类型，并且与表达式结果类型匹配（比如int?和int） 存在表达式结果到目标类型的装箱和取消装箱转换 举例如下 1234567object v = 1;//判断v是否是int类型，如果是//判断可以有多个，用逻辑运算符相连：if (v1 is int a &amp;&amp; v2 is int b)if (v is int value){ Console.WriteLine(value); //1} 常量模式用于测试表达式结果是否等于指定常量（C# 7）。在常量模式中可以使用任何常量表达式，包括 整型、浮点型、字符、字符串文本 true/false 枚举值 声明常量字段或本地名称 null 123456switch(v){ case 0:break; case 1:break; case 2:break;} 关系模式用于将表达式结果与指定常量进行比较(C# 9)。可以使用关系运算符（&gt;、&gt;=、&lt;、&lt;=），多个范围可以使用and或or相连 123456switch(v){ case &gt; 10:break; case &lt; 10 and &gt;1:break; default:break;} 逻辑模式用于测试表达式是否与模式的逻辑组合匹配（ C# 9）。 not、and 和 or 模式连结符可与其他模式一起使用，优先级顺序： not and or 属性模式用于测试表达式的属性或字段是否与嵌套模式匹配（C# 8）。可使用属性模式来将表达式的属性或字段与嵌套模式进行匹配 12345switch(){ //多个属性使用逗号间隔 case 类型{属性:条件,...}:break; /...} 举例如下 123456switch(v){ case string { Length:&gt;5 and &lt;10}:break; case string { Length:&lt;3}:break; default:break;} 位置模式用于解构表达式结果并测试结果值是否与嵌套模式匹配（C# 8）。 12345switch(变量1,变量2,...){ case (匹配值1, 匹配值2):break; //...} 举例如下 12345switch(v1,v2){ case (0, 1):break; case (1, 2):break;} var 模式用于匹配任何表达式（包括null）并将其结果分配给声明的变量（C# 7）。 1234if (v is var value){ Console.WriteLine(value);} 弃元模式用于匹配任何表达式，包括null（C# 8）。弃元模式不能是 is 表达式或 switch 语句中的模式 1234switch(v1,v2){ case (_, 2):break;}","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"运算符","text":"算术运算符、比较运算符、逻辑运算符、位运算符、相等运算符、运算符优先级、运算符重载 算术运算符 运算符 说明 + 加 - 减/取负 * 乘 / 除 % 取模 ++ 自增 – 自减 = 赋值 x op= y 复合赋值，等效于 x op y 比较运算符 运算符 说明 &lt; 小于 &gt; 大于 &lt;= 不大于 &gt;= 不小于 逻辑运算符 运算符 说明 ! 逻辑非 &amp; 逻辑与 ^ 逻辑异或 | 逻辑或 &amp;&amp; 短路逻辑与 || 短路逻辑或 x op= y 复合赋值，等效于 x op y 位运算符 运算符 说明 ~ 按位取反 &lt;&lt; 左移 &gt;&gt; 右移 &amp; 按位与 ^ 按位异或 | 按位或 x op= y 复合赋值，等效于 x op y 相等运算符 运算符 说明 == 相等 != 不等 运算符优先级下表优先级从高到底 运算符 类别 x.y、f(x)、a[i]、x?.y、x?[y]、x++、x–、x!、new、typeof、checked、unchecked、default、nameof、delegate、sizeof、stackalloc、x-&gt;y 基本 +x、-x、!x、~x、++x、–x、^x、(T)x、await、&amp;x、*x、true 和 false 一元 x..y 范围 switch、with switch 和 with 表达式 x * y、x / y、x % y 乘除取模 x + y、x – y 加减 x &lt;&lt; y, x &gt;&gt; y 移位 x &lt; y, x &gt; y、x &lt;= y, x &gt;= y、is、as 关系和类型测试 x == y、x != y 相等 x &amp; y 与 x ^ y 异或 x | y 或 x &amp;&amp; y 条件与 x || y 条件或 x ?? y null合并 c ? t : f 三元运算符 x = y、x += y、x -= y、x *= y、x /= y、x %= y、x &amp;= y、x |= y、x ^= y、x &lt;&lt;= y、x &gt;&gt;= y、x ??= y、=&gt; 赋值和 lambda 声明 运算符重载用户定义的类型可重载预定义的 C# 运算符。 也就是说，当一个或两个操作数都是某类型时，此类型可提供操作的自定义实现 基本语法使用 operator 关键字来声明运算符，运算符声明必须符合以下规则： 同时包含 public 和 static 修饰符； 一元运算符有一个输入参数。 二元运算符有两个输入参数； 至少有一个参数必须具有类型 T 或 T?，其中 T 是包含运算符声明的类型； 1234567891011121314151617181920212223class School{ private int girlNum = 100; private int boyNum = 100; //a是左边的变量，b是右边的变量 //+= 也被隐式重载了 public static School operator +(School a, School b) { School s = new School(); s.girlNum = a.girlNum+b.girlNum; s.boyNum = a.boyNum+b.boyNum; return s; } public static School operator ++(School a) { a.girlNum++; a.boyNum++; return a; }} 可重载运算符一元运算符 +x、-x !x ~x ++、– true、false 二元运算符 x + y、x - y、x * y、x / y、x % y、x &amp; y、 x | y、x ^ y x &lt;&lt; y, x &gt;&gt; y x == y、x != y、x &lt; y, x &gt; y、x &lt;= y, x &gt;= y 其中，比较运算符必须成对重载： == 和 != 运算符 &lt; 和 &gt; 运算符 &lt;= 和 &gt;= 运算符 复合运算符 +=、-=、*=、/=、%=、&amp;= |=、^=、&lt;&lt;=, &gt;&gt;= 复合运算符不能重载，但在重载二元运算符时也会隐式的重载对应的复合运算符，比如重载 + 后+=也会被重载 条件逻辑运算符 x &amp;&amp; y、x || y 条件逻辑运算符不能重载，但如果重载了true或false，并且重载了&amp; 或 |，则可以使用条件逻辑运算符","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"面向对象","text":"类、继承、接口、泛型、抽象类、分部类、嵌套类型、扩展方法、委托、班底函数、匿名函数、属性和索引器、静态类、密封类、访问修饰符 类类定义及成员1234[访问修饰符] class ClassName{ //类成员：字段、属性、方法、事件等 } 通过new关键字实例化 12//`class`是引用类型，默认值为null，直到使用new关键字创建实例或分配对象ClassName i = new ClassName(); 字段12345class ClassName{ //声明字段,如果不初始化则为默认值 private string value = &quot;初始化&quot;;} 方法基本语法123[static] [访问修饰符] [可选修饰符] 返回值 方法名(参数列表){ //...} 说明： static：指定是静态方法 可选修饰符： abstract：抽象方法，只能声明在抽象类和接口里 sealed：密封方法，子类不可重写 virtual：虚方法，子类可以重写 举例如下： 1234567class ClassName{ public void F1() { } public String F2(){return &quot;123&quot;;}} 方法访问访问方法使用 . 12ClassName c = new ClassName();c.F2(3); 值传递与引用传递默认情况下，值类型参数传递给方法时，传递的时副本而非实例本身。 因此，对参数的更改不会影响调用方法中的原始实例。 若要按引用传递值类型实例，可以使用ref关键字 123456789101112static public void Main(){ int i = 0; //传递时变量前加ref Add(ref i); Console.WriteLine(i);}//接收时类型前加refstatic public void Add(ref int i){ i++;} 引用返回值返回值需要和声明的返回值类型匹配，没有返回值使用void。如果想返回值类型的引用，可以声明返回值为ref 123456789101112131415161718class ClassName{ static public void Main() { ClassName c = new ClassName(); //接收时也要使用ref ref string name = ref c.Fun(); //如果不加ref，对name1的更改不会反映到类成员中的name string name1 = c.Fun(); } private string name = &quot;&quot;; public ref string Fun() { return ref name; }} 说明： ref后不能加常量； 方法重载方法名相同、参数列表不同的方法是重载方法，返回值类型不计入方法重载 异步方法使用async标记异步方法，可以在该方法中使用await运算符。当程序执行到await表达式时，程序返回到调用方继续执行任务，方法中的进度会处于挂起状态。任务完成后，可在方法中恢复执行 异步方法返回值一般为： Task&lt;TResult&gt; Task IAsyncEnumerable&lt;T&gt; void 1234567891011121314151617181920static public void Main(){ DoSomethingAsync();}static async Task DoSomethingAsync(){ //进入DelayAsync() Task&lt;int&gt; delayTask = DelayAsync(); //（1）遇到delayTask继续回去执行 int result = await delayTask; Console.WriteLine($&quot;Result: {result}&quot;);}static async Task&lt;int&gt; DelayAsync(){ //遇到await，返回（1），程序被挂起 await Task.Delay(100); return 5;} 异步方法不能声明任何 ref 或 out参数，但是可以调用具有这类参数的方法。 构造函数构造函数不包含返回值类型 1234567891011121314class ClassName{ private String name; public ClassName(String name) { this.name = name; } //自动生成构造函数：输入ctor，按Tab public ClassName() { this.name = null; }} 使用静态构造函数初始化静态字段，静态构造函数是无参的， 将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数 1234567891011class ClassName{ private static String name; //自动生成构造函数：输入ctor，按Tab static ClassName() { name = &quot;张三&quot;; }} 终结器终结器用于垃圾回收类实例时执行必要的清理操作，不能手动调用。声明如下 12345678class ClassName{ ~ClassName() { //清理资源 }} 终结器隐式调用对象基类上的 Finalize方法。因此，对终结器的调用会隐式转换为以下代码： 1234567891011protected override void Finalize(){ try { // Cleanup statements... } finally { base.Finalize(); }} 继承和实现通过冒号声明基类（接口/类），当一个类声明一个基类时，它继承了基类的所有成员，除了构造函数。 123456789class Parent{}class Child : Parent{} C#中一个类只能继承一个基类，但可以实现多个接口 接口接口包含功能的定义，需要class或struct实现 1234[访问修饰符] interface 接口名{} 接口成员规则如下： 接口可以包含实例方法、属性、事件、索引器或这四种成员类型 接口可能包含静态构造函数、字段、常量或运算符 接口不能包含实例字段、实例构造函数或终结器 接口可以为成员定义默认实现（C# 8） 接口成员默认都是公有的，可根据需要指定访问修饰符，private成员必须有一个默认实现 接口可以定义static方法，并且必须给出实现 举例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869interface Animal&lt;T&gt;{ //接口包含属性 public string value { get { return &quot;接口属性&quot;; } set { Console.WriteLine(&quot;接口属性赋值：&quot; + value); } } //接口定义实例方法 public void InstanceFun() { Console.WriteLine(&quot;接口实例方法&quot;); void Fun() { //声明本地函数 String LocalMethod() { //访问外部成员 return &quot;&quot;; } } } //必须声明静态，接口中不能有实例字段 public static T[] arr = new T[5]; //索引器 public T this[int i] { get { return arr[i]; } set { arr[i] = value; } } //私有成员 private void PriFun() { Console.WriteLine(&quot;私有成员必须有默认实现&quot;); } //事件 public event CustomEventEventHandler RaiseCustomEvent { add { throw new NotImplementedException(); } remove { throw new NotImplementedException(); } } //委托 public delegate void CustomEventEventHandler(object sender, CustomEventArgs e); //静态方法 static void StaticFun() { Console.WriteLine(&quot;静态方法必须有默认实现&quot;); } }class Cat&lt;T&gt; : Animal&lt;T&gt;{} 补充： 不能对接口或显式接口成员实现使用访问器修饰符； 泛型在类型和方法定义中以尖括号&lt;占位符&gt;声明泛型，由客户端指定特定类型的占位符 泛型定义泛型可以加在任何类、方法、接口、结构体上 1234567891011121314151617181920212223//泛型类class GenericClass&lt;T&gt;{ public T? t; public void F1(T t) { } //泛型方法 public void GenericFun&lt;F&gt;(T t,F f) { }}//泛型接口interface IGenericInterface&lt;T&gt; { }//泛型结构struct GenericStruct&lt;T&gt;{ T? t;}//泛型抽象类abstract class AbstractGenericClass&lt;T&gt; { } 泛型约束使用where关键字指定约束，可以加在类或方法上 where T : struct：T必须是不可为 null 的值类型 where T : class：T必须是引用类型 where T : class?：T必须是可为 null 或不可为 null 的引用类型 where T : notnull：T必须是不可为 null 的类型 where T : default：表示基类方法中的T没有class或struct约束 where T : unmanaged：T必须是非null的非托管类型 where T : new()：T必须具有公共无参数构造函数 where T : &lt;base class name&gt;：规定 T 的基类，基类为不为null的引用类型 where T : &lt;base class name&gt;?：规定 T 的基类，基类可为 null 或不可为 null 的类型 where T : &lt;interface name&gt;：规定 T 的接口，基类为不为null的引用类型 where T : &lt;interface name&gt;?：规定 T 的接口，基类可为 null 或不可为 null 的类型 where T : U：为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数 12345class TestClass&lt;T&gt; where T : notnull{ // 同一类型的多个约束使用 , 分隔 public virtual void F1&lt;C&gt;(C c) where C : class, new() { }} 约束多个参数 1234public virtual void F1&lt;C,S&gt;(C c,S s) where C : class where S : struct{ } 泛型委托 **定义方式 ** 1public delegate void 委托名&lt;T&gt;(T t); 使用方式 1委托名&lt;int&gt; 变量名 = 方法名 举例如下： 123456//委托public delegate void DelName&lt;T&gt;(T t);//方法public static void Notify(int i) { }//引用DelName&lt;int&gt; d = fun; 抽象类通过abstract修饰一个类，即为抽象类 抽象类包含具有签名定义但没有实现的抽象方法； 抽象类不能实例化； 抽象类的派生类必须实现所有抽象方法； 当抽象类从基类继承虚方法时，抽象类可以使用抽象方法重写该虚方法； 1234567891011121314151617public abstract class AbstractClass : Father{ //定义抽象方法 public abstract void AbstractFun(); //使用抽象方法重写该虚方法，这样派生类就必须实现该方法 public abstract override void VirtualFun(); //定义方法并提供实现 public void CommonFun() { }}public class Father{ //虚方法 public virtual void VirtualFun() { }} 分部类分布类就是将一个类、结构体或接口拆分成多个部分，每个部分使用partail关键字修饰。，并且确保可以合成最终的类型 12345678910111213141516public partial class PartClass{ private string first_name = &quot;尼古拉斯&quot;;}public partial class PartClass{ private string second_name = &quot;赵四&quot;; public void ShowName() { //不同部分可以相互访问 Console.WriteLine($&quot;{first_name}:{second_name}&quot;); }} 说明： 每个部分的访问修饰符、基类等声明必须一致； partial 修饰符不可用于委托或枚举声明中； 嵌套类型在类、接口或结构体中定义的类型成为嵌套类型，嵌套类默认为private 类的嵌套类型可以是：public、protected、internal、protected internal、private 或 private protected； 结构体的嵌套类型可以是： public、internal 或 private； 内部类型可以访问外部类型 123456789101112131415161718192021public class Outer{ private String value; //完整名称为Outer.Inner public class Inner { private Outer outer; public Inner() { //访问外部类 outer.value = &quot;123&quot;; } //如果内部类想访问外部类，可以将外部类作为参数传递给内部类 public Inner(Outer outer) { this.outer = outer; } }} 扩展方法扩展方法就是向现有类型添加方法，调用时与普通方法没有区别。扩展方法必须在非泛型静态类中定义，但它们是通过实例方法的形式被调用 123456789101112131415161718public class TestClass{ public static void Main() { TestClass testClass = new TestClass(); //调用方式 testClass.ExtensionFun(&quot;参数&quot;); }}public static class Extension{ //扩展方法 static public void ExtensionFun(this TestClass testClass,string s) { Console.WriteLine(&quot;扩展方法&quot;); }} 说明： 可以使用扩展方法来扩展类或接口，但不能重写扩展方法； 与接口或类方法具有相同名称和签名的扩展方法永远不会被调用； 本地函数本地函数就是声明在成员中的方法，可用以下修饰符修饰： async unsafe static（C# 8）： 静态本地函数无法捕获局部变量或实例状态。 extern（C# 9）： 外部本地函数必须为 static。 1234567891011121314class ClassName{ private String name = &quot;&quot;; public void Fun() { //声明本地函数 String LocalMethod() { //访问外部成员 return name; } }} 说明： 本地函数都是私有的，不能声明访问修饰符； 包含在成员中定义的所有本地变量都可以在非静态本地函数中访问； 匿名函数委托和事件委托委托是一种引用类型，它类似于函数指针。是对指定的参数列表和返回值的方法的引用 委托声明使用delegate声明委托 1public delegate int 委托名(参数列表); 说明： 委托声明可以声明为成员，也可以声明在顶级位置； 静态或实例方法都可分配给委托； 委托的类型是密封的，不能被继承； 举例如下： 123456789101112131415161718public delegate void Delegate(string s);class DelegateClass{ public static void Main() { Delegate d = DelegateClass.TestMethod; d(&quot;s&quot;); //可以接收包括匿名方法或lambda表达式 Delegate d = delegate (string s) { Console.WriteLine(&quot;匿名委托方法&quot;); }; } //可以是静态或实例方法 public static void TestMethod(string s) { Console.WriteLine(&quot;被委托方法&quot;); }} 多播委托一个委托可以通过 +/- 运算符添加或减少任意个方法，然后一起调用，这被称为多播 12345678910111213141516171819202122232425class DelegateClass{ public static void Main() { Delegate d = DelegateClass.TestMethod1; d = d + DelegateClass.TestMethod2; d += DelegateClass.TestMethod3; d(&quot;s&quot;); } public delegate void Delegate(string s); public static void TestMethod1(string s) { Console.WriteLine(&quot;被委托方法1&quot;); } public static void TestMethod2(string s) { Console.WriteLine(&quot;被委托方法2&quot;); } public static void TestMethod3(string s) { Console.WriteLine(&quot;被委托方法3&quot;); }} 上面代码中，一个委托引用了三个方法，调用时三个方法都会被调用 2、事件类、接口、结构体可以定义事件。事件是一种特殊的多播委托，仅可以从声明事件的类或结构中对其进行调用。 如果其他类或结构可以订阅这个事件，其实就是一个发布订阅或者说观察者模式 发布事件的类或结构体称为发布者； 订阅事件的类或结构体称为订阅者； 事件声明使用event关键字声明事件 1[访问修饰符] event 委托类型 变量名 说明： 事件可以被static、virtual、sealed、abstract关键字修饰 EventHandler 是官方提供的委托，.net类库中的所有事件都基于 EventHandler 委托，其实在定义事件时可以不使用EventHandler，所有东西都自定义也可以实现，但官方推荐使用，主要也是为了和.net类库兼容。声明事件的方式有如下三个： 使用 EventHandler&lt;TEventArgs&gt; 1public event EventHandler&lt;自定义事件参数&gt; 事件名; 使用 EventHandler 1public event EventHandler 事件名; 使用自定义事件 1public event 自定义委托类型 事件名; 根据事件方式不同可能需要自定义内容如下： **自定义参数 ** 如果触发事件需要传递参数，则应该定义事件参数类 123456789public class CustomEventArgs : EventArgs{ public CustomEventArgs(string message) { Message = message; } public string Message { get; set; }} 自定义事件委托 如果使用的EventHandler发布事件不使用泛型，则需要自定义委托 1public delegate void CustomEventHandler(object sender, CustomEventArgs args); 说明： sender：事件源 args：传递的参数 使用 EventHandler&lt;TEventArgs&gt; 声明事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 自定义事件参数public class CustomEventArgs : EventArgs{ public CustomEventArgs(string message) { Message = message; } //定义事件参数字段 public string Message { get; set; }}//发布者class Publisher{ // 使用EventHandler&lt;T&gt;定义事件 public event EventHandler&lt;CustomEventArgs&gt; RaiseCustomEvent; public void DoSomething() { // 业务代码... // 在这里提交一个事件 OnRaiseCustomEvent(new CustomEventArgs(&quot;事件被触发&quot;)); } // 允许派生类重写事件的行为 protected virtual void OnRaiseCustomEvent(CustomEventArgs e) { // 临时拷贝当前的订阅者事件，为了防止可能出现的错误： // 在空检查之后和提交事件之前的这段时间，可能订阅者会取消订阅 // 这样就可能出现空指针 EventHandler&lt;CustomEventArgs&gt; raiseEvent = RaiseCustomEvent; // 如果没有订阅者，事件将会被取消 if (raiseEvent != null) { // 填充参数 e.Message += $&quot; at {DateTime.Now}&quot;; // 提交事件 raiseEvent(this, e); } }}//订阅者class Subscriber{ private readonly string _id; public Subscriber(string id, Publisher pub) { _id = id; // 订阅事件 pub.RaiseCustomEvent += HandleCustomEvent; } // 当提交事件会执行的行为 void HandleCustomEvent(object sender, CustomEventArgs e) { Console.WriteLine($&quot;{_id} received this message: {e.Message}&quot;); }} 使用 EventHandler 声明事件EventHandler 委托是一个预定义的委托，专门表示不生成数据的事件的事件处理程序方法。 如果事件确实生成了数据，则必须使用泛型 EventHandler&lt;TEventArgs&gt; 委托类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//发布者class Publisher{ // 使用EventHandler&lt;T&gt;定义事件 public event EventHandler RaiseCustomEvent; public void DoSomething() { // 业务代码... // 在这里提交一个事件 OnRaiseCustomEvent(); } // 允许派生类重写事件的行为 protected virtual void OnRaiseCustomEvent() { // 临时拷贝当前的订阅者事件，为了防止可能出现的错误： // 在空检查之后和提交事件之前的这段时间，可能订阅者会取消订阅 // 这样就可能出现空指针 EventHandler raiseEvent = RaiseCustomEvent; // 如果没有订阅者，事件将会被取消 if (raiseEvent != null) { // 提交事件 // 如果有参数直接传递EventArgs或其子类 // 如果没有参数传递EventArgs.Empty raiseEvent(this, EventArgs.Empty); } }}//订阅者class Subscriber{ private readonly string _id; public Subscriber(string id, Publisher pub) { _id = id; // 订阅事件 pub.RaiseCustomEvent += HandleCustomEvent; } // 当提交事件会执行的行为 void HandleCustomEvent(object sender, EventArgs e) { Console.WriteLine($&quot;事件被触发，参数为：{e}&quot;); }} 使用自定义委托声明事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 自定义事件参数public class CustomEventArgs{ public CustomEventArgs(string message) { Message = message; } public string Message { get; set; }}// 自定义事件委托public delegate void CustomEventEventHandler(object sender, CustomEventArgs e);//发布者class Publisher{ // 使用EventHandler&lt;T&gt;定义事件 public event CustomEventEventHandler RaiseCustomEvent; public void DoSomething() { // 业务代码... // 在这里提交一个事件 OnRaiseCustomEvent(new CustomEventArgs(&quot;默认信息&quot;)); } // 允许派生类重写事件的行为 protected virtual void OnRaiseCustomEvent(CustomEventArgs e) { // 临时拷贝当前的订阅者事件，为了防止可能出现的错误： // 在空检查之后和提交事件之前的这段时间，可能订阅者会取消订阅 // 这样就可能出现空指针 CustomEventEventHandler raiseEvent = RaiseCustomEvent; // 如果没有订阅者，事件将会被取消 if (raiseEvent != null) { e.Message = &quot;我是事件生成的信息&quot;; // 提交事件 // 如果有参数直接传递EventArgs或其子类 // 如果没有参数传递EventArgs.Empty raiseEvent(this, e); } }}//订阅者class Subscriber{ private readonly string _id; public Subscriber(string id, Publisher pub) { _id = id; // 订阅事件 pub.RaiseCustomEvent += HandleCustomEvent; } // 当提交事件会执行的行为 void HandleCustomEvent(object sender, CustomEventArgs e) { Console.WriteLine($&quot;事件被触发，参数为：{e}&quot;); }} 事件访问器事件也可以像属性一样声明访问器，不过 名字叫add和remove，因为可能有多线程问题所以建议加lock 锁定事件 123456789101112131415161718event EventHandler IDrawingObject.OnDraw{ add { lock (objectLock) { PreDrawEvent += value; } } remove { lock (objectLock) { PreDrawEvent -= value; } }} 属性和索引器属性属性声明属性可以声明set、get、init三个方法，并且get和init不能共存 123456789101112131415161718192021222324252627282930class ClassName{ private string _firstName ; private string _lastName; public string Name { get { return $&quot;{_firstName} {_lastName}&quot;; } //访问器也可以设置访问修饰符，用于控制访问性 protected set { _firstName= value.Split(&quot;-&quot;)[0]; _lastName= value.Split(&quot;-&quot;)[1]; } //init和set不能同时存在，此处列出 init { _firstName = &quot;尼古拉斯&quot;; _lastName = &quot;赵四&quot;; } //自动实现get和set（或get和init） public string Name { get; set; } }} 说明： value关键字：用于定义由 set 或 init 访问器分配的值 get：属性访问器用于返回属性值 set：属性访问器用于分配新值 init 关键字：在属性或索引器中定义访问器方法，仅在对象构造期间为属性或索引器元素赋值 2、索引器索引器定义索引器允许类或结构的实例就像数组一样进行索引，类似于属性，根据需要提供get和set方法 1234567891011121314151617181920212223class Index&lt;T&gt;{ public T[] arr = new T[10]; //索引器 public T this[int index] { get { return arr[index]; } set { arr[index] = value; } }}class Test{ static public void Main() { //使用方式 Index&lt;int&gt; index = new Index&lt;int&gt;(); index[2] = 1; Console.WriteLine(index[2]); }} 只读索引器如果只想定义只读索引器，可以简写为 12345678class Index&lt;T&gt;{ public T[] arr = new T[10]; //索引器 public T this[int index] =&gt; arr[index];} 重写和访问修饰符属性和索引器访问修饰符规则如下： 默认情况下，访问器与其所属属性或索引器可见性相同。 如果属性或索引器同时具有 set 和 get 访问器时，属性可以声明访问器修饰符。 这种情况下，只允许对其中一个访问器使用修饰符 属性或索引器可以被重写，重写的访问器修饰符必须与重写的访问器的访问器（如有）相同； 访问器的可访问性级别必须比属性或索引器本身的可访问性级别更严格； 属性重写和修饰符示例123456789101112131415161718192021public class Parent{ public virtual int TestProperty { protected set { } get { return 0; } }}public class Kid : Parent{ //重写访问器 public override int TestProperty { // 相同的访问级别 protected set { } get { return 0; } }} 索引器重写和修饰符示例1234567891011121314151617181920212223public class Parent&lt;T&gt;{ public T[] arr = new T[10]; //索引器 public virtual T this[int index] { protected get { return arr[index]; } set { arr[index] = value; } }}public class Kid&lt;T&gt; : Parent&lt;T&gt;{ public T[] Kid_Arr = new T[10]; //重写索引器 public override T this[int index] { protected get { return arr[index]; } set { arr[index] = value; } }} 静态类和静态成员静态类与只包含静态成员和私有构造函数的类基本相同，但静态类无法实例化 只包含静态成员 无法进行实例化 不能包含实例构造函数，可以包含静态构造函数 会进行密封，无法被继承 静态成员：静态成员可以使用static声明，并且必须初始化。由于const字段在行为上也时静态的，虽然不支持 static const，但在静态类中可以直接声明const字段 1234567891011//密封类static public class StaticClass{ //静态构造函数 static StaticClass(){ } //只能包含静态成员 static public String value1 = &quot;&quot;; public const String value2 = &quot;&quot;; static public void StaticFun() { }} 密封类和密封成员使用sealed修饰的类，即为密封类 密封类不能用作基类，也就是禁止派生，也不能是抽象类； 由于密封类从不用作基类，所以有些运行时优化可以略微提高密封类成员的调用速度； 密封成员：在对基类的虚成员进行重写的派生类上，方法、索引器、属性或事件可以将该成员声明为密封成员。 在用于以后的派生类时，这将取消成员的虚效果。 12345678910111213141516171819//密封类public sealed class SealedClass{ //定义方法并提供实现 public void CommonFun() { }}public class Father{ //虚方法 public virtual void VirtualFun() { }}class ChildClass:Father{ //重写方法为密封成员，之后的子类无法重写该方法 public sealed override void VirtualFun() { }} 访问修饰符 public protected internal protected internal private protected private 类内 √ √ √ √ √ √ 派生类（相同程序集） √ √ √ √ √ × 非派生类（相同程序集） √ √ × √ × × 派生类（不同程序集） √ √ √ × × × 非派生类（不同程序集） √ × × × × × 类、记录、结构体的访问性 类、记录、结构体可以为 public 或 internal，默认是internal； 结构体成员（包括嵌套的类和结构）可以为 public、internal 或 private； 类成员（包括嵌套的类和结构）可以声明为任何访问修饰符； 类成员和结构成员（包括嵌套的类和结构）默认为private； 派生类/记录不能比基类访问性高； 类、记录、结构体成员的访问性 类和记录的成员可声明为任意访问修饰符； 通常情况下，成员的可访问性不大于包含该成员的类型的可访问性。但是，如果内部类的 public 成员实现了接口方法或替代了在公共基类中定义的虚拟方法，则可从该程序集的外部访问该成员； 为字段、属性或事件成员的类型必须至少与该成员本身具有相同的可访问性； 任何方法、索引器或委托的返回类型和参数类型必须至少与该成员本身具有相同的可访问性； 用户定义的运算符始终必须声明为 public 和 static； 终结器不能具有可访问性修饰符； 其他类型的访问性 在命名空间内直接声明的接口可以声明为 public 或 internal，默认为internal； 接口成员默认为 public； 接口成员声明可以包含任何访问修饰符； 枚举成员始终为 public，并且不能应用任何访问修饰符 委托可以为 public 或 internal，默认是internal； 委托作为嵌套成员时默认为private；","link":"/2020/11/01/%E6%8A%80%E6%9C%AF%E6%A0%88/CSharp/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Phoenix Context","text":"上下文（Context）用于将属于不同方面的功能进行隔离。Phoenix 应用程序由多个Context组成，每个Context提供一个方面的一系列功能","link":"/2024/01/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Context/"},{"title":"Phoenix Controller","text":"控制器（controller）用来处理请求，然后返回模板或Json数据，Phoenix 控制器也是基于 Plug 软件包构建的，并且本身就是Plug。 声明 Controller路由的示例如下： 12345678defmodule HelloWeb.PageController do # use宏会调用 HelloWeb 模块的 __using__/1 函数导入一些有用的模块 use HelloWeb, :controller def home(conn, _params) do render(conn, :home, layout: false) endend conn：连接结构体 params：接收传递的参数，建议以模式匹配的方式接收数据 1234567defmodule HelloWeb.HelloController do ... def show(conn, %{&quot;messenger&quot; =&gt; messenger}) do render(conn, :show, messenger: messenger) endend 命名规范 index：呈现给定资源类型的所有项目的列表 show：按 ID 呈现单个项目 new：呈现用于创建新项目的表单 create：接收一项新项目的参数并将其保存在数据存储中 edit：按 ID 检索单个项目并将其显示在表单中以供编辑 update：接收一个已编辑项目的参数并将该项目保存到数据存储中 delete：接收要删除的项目的 ID 并将其从数据存储中删除 渲染控制器可以以多种方式渲染内容： 纯文本：text(conn, &quot;From messenger #{messenger}&quot;) Json：json(conn, %{id: messenger}) HTML：render(conn, :show, messenger: messenger) 模板传惨如果希望在使用render是传递参数，有两种方式： 使用关键字传递 使用Plug.Conn.assign/3方法：该方法返回一个conn 1234567891011# 下面两种方式都是合法的def show(conn, %{&quot;messenger&quot; =&gt; messenger}) do conn |&gt; assign(:messenger, messenger) |&gt; assign(:receiver, &quot;Dweezil&quot;) |&gt; render(:show)enddef show(conn, %{&quot;messenger&quot; =&gt; messenger}) do render(conn, :show, messenger: messenger, receiver: &quot;Dweezil&quot;)end 设置内容类型12345def home(conn, _params) do conn |&gt; put_resp_content_type(&quot;text/xml&quot;) |&gt; render(:home, content: some_xml_content)end 直接回复使用Plug.Conn.send_resp/3函数直接发送状态码，没有回复正文 123def home(conn, _params) do send_resp(conn, 201, &quot;&quot;)end 设置状态码12345def home(conn, _params) do conn |&gt; put_status(202) |&gt; render(:home, layout: false)end 模板格式在中可以查看lib/hello_web.ex控制器可以使用的模板格式 123456789101112def controller do quote do use Phoenix.Controller, formats: [:html, :json], layouts: [html: UserServiceWeb.Layouts] import Plug.Conn import UserServiceWeb.Gettext unquote(verified_routes()) end end todo 其他功能大多数都是和模板相关，暂不记录","link":"/2024/01/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Controller/"},{"title":"Phoenix Plug","text":"Plug是Phoenix处理请求的核心。当接收到请求时Phoenix会将其封装成Conn（连接结构体），然后将其依次通过定义的组件进行处理，最终得到输出。Plug分为两种： Function plugs Module plugs 定义 PlugFunction plugsFunction plugs 条件： 第一个参数为Conn（连接结构体，%Plug.Conn{}），第二个参数是选项 返回值是一个Conn 1234# 示例def index(conn, _params) do connend Module plugsModule plugs用于在模块中定义连接转换，该模块只需要实现两个方法： init/1：初始化要传递给call/2的参数和选项 call/2：执行连接转换。是一个功能插件 12345678910111213141516# 示例defmodule HelloWeb.Plugs.Locale do import Plug.Conn @locales [&quot;en&quot;, &quot;fr&quot;, &quot;de&quot;] def init(default), do: default def call(%Plug.Conn{params: %{&quot;locale&quot; =&gt; loc}} = conn, _default) when loc in @locales do assign(conn, :locale, loc) end def call(conn, default) do assign(conn, :locale, default) endend 使用 PlugPhoenix 中可以在endpoint, router和 controllers中使用插头。 endpointendpoint用于组织每个请求通用的所有插头，并在使用自定义pipline分派到路由器之前应用它们。 123456defmodule HelloWeb.Endpoint do ... plug :introspect # 添加 Plug plug HelloWeb.Router router在路由器中可以声明Plug用于处理请求，pipeline也是Plug 12345678910111213141516171819defmodule HelloWeb.Router do use HelloWeb, :router pipeline :browser do plug :accepts, [&quot;html&quot;] plug :fetch_session plug :fetch_live_flash plug :put_root_layout, html: {HelloWeb.LayoutView, :root} plug :protect_from_forgery plug :put_secure_browser_headers # 添加 Plug plug HelloWeb.Plugs.Locale, &quot;en&quot; end scope &quot;/&quot;, HelloWeb do pipe_through :browser # 添加 Plug get &quot;/&quot;, PageController, :index end controllers1234defmodule HelloWeb.PageController do use HelloWeb, :controller # 添加 Plug plug HelloWeb.Plugs.Locale, &quot;en&quot; 可以设置Plug执行的条件 1234defmodule HelloWeb.PageController do use HelloWeb, :controller plug HelloWeb.Plugs.Locale, &quot;en&quot; when action in [:index]","link":"/2024/01/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Plug/"},{"title":"Phoenix Router","text":"Router用于将请求与controller操作相匹配，并定义一系列仅限于一组路由的通道转换 声明 Router路由的示例如下： 12345678910111213141516171819202122232425262728293031# Router 和 Controller 模块名称都以应用程序的名称为前缀defmodule HelloWeb.Router do # 使 Phoenix 的路由功能在定义的路由器中可用 use HelloWeb, :router # 管道，具体后面章节介绍 pipeline :browser do plug :accepts, [&quot;html&quot;] plug :fetch_session plug :fetch_live_flash plug :put_root_layout, html: {HelloWeb.Layouts, :root} plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts, [&quot;json&quot;] end # 声明路由的范围 scope &quot;/&quot;, HelloWeb do pipe_through :browser # `get`是一个`Phoenix` get &quot;/&quot;, PageController, :home end # Other scopes may use custom stacks. # scope &quot;/api&quot;, HelloWeb do # pipe_through :api # end # ...end 检查 RouterPhoenix 提供了一个用于检查路由的工具，执行下面命令可以展示出当前存在的路由列表 1$ mix phx.routes Scopescope内部声明指定的controller，形式如下： 1请求类型 &quot;/路径&quot;, 控制器模块名, :函数名 声明请求类型的方式包括： HTTP 动词：声明单个类型的请求 Resource：声明一系列请求 HTTP 路由HTTP 动词可以声明单个路由 1get &quot;/&quot;, PageController, :home Resource 路由使用Resource会生成一系列路由，:only和:except选项来过滤特定操作 :only：限定 1234resources &quot;/posts&quot;, PostController, only: [:index, :show]# 生成路由为# GET /posts HelloWeb.PostController :index# GET /posts/:id HelloWeb.PostController :show :except：排除 123456789resources &quot;/comments&quot;, CommentController, except: [:delete]# 生成路由为# GET /comments HelloWeb.CommentController :index# GET /comments/:id/edit HelloWeb.CommentController :edit# GET /comments/new HelloWeb.CommentController :new# GET /comments/:id HelloWeb.CommentController :show# POST /comments HelloWeb.CommentController :create# PATCH /comments/:id HelloWeb.CommentController :update# PUT /comments/:id HelloWeb.CommentController :update 嵌套 Resource嵌套路由需要传递上层路由的ID， 123resources &quot;/users&quot;, UserController do resources &quot;/posts&quot;, PostControllerend 生成路由如下： 123456789// users 的路由GET /users/:user_id/posts HelloWeb.PostController :indexGET /users/:user_id/posts/:id/edit HelloWeb.PostController :editGET /users/:user_id/posts/new HelloWeb.PostController :newGET /users/:user_id/posts/:id HelloWeb.PostController :showPOST /users/:user_id/posts HelloWeb.PostController :createPATCH /users/:user_id/posts/:id HelloWeb.PostController :updatePUT /users/:user_id/posts/:id HelloWeb.PostController :updateDELETE /users/:user_id/posts/:id HelloWeb.PostController :delete Pipline当服务器接受请求时，请求将始终首先通过端点中的插头，然后尝试匹配路径和 HTTP 谓词。没有匹配到会返回404，匹配到后首先第一行会执行pipe_through :browser，也就是执行管道定义的操作 pipeline：定义管道，执行的一系列Plug :browser 用来为浏览器呈现内容 :api用来为API生成数据 pipe_through：用来声明接收的请求所通过的管道 123456789101112131415161718192021222324252627282930313233343536defmodule HelloWeb.Router do use HelloWeb, :router pipeline :browser do # 定义接受的请求格式 plug :accepts, [&quot;html&quot;] # 获取会话数据并使其在连接中可用 plug :fetch_session # 从 LiveView 获取任何 Flash 消息并将它们与控制器 Flash 消息合并 plug :fetch_live_flash # 存储根布局以用于渲染 plug :put_root_layout, html: {HelloWeb.Layouts, :root} # 下面两项用来防止跨站点伪造。 plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts, [&quot;json&quot;] end scope &quot;/&quot;, HelloWeb do # 使用 pipe_through 代表应用上面 :browser pipeline 声明的操作 pipe_through :browser get &quot;/&quot;, PageController, :home end # Other scopes may use custom stacks. scope &quot;/api&quot;, HelloWeb do pipe_through :api resources &quot;/reviews&quot;, ReviewController end # ...end 自定义 Pipline12345678910111213141516171819202122pipeline :browser do ...endpipeline :auth do plug HelloWeb.Authenticationendscope &quot;/&quot; do pipe_through [:browser] get &quot;/reviews&quot;, PostController, :index get &quot;/reviews/:id&quot;, PostController, :showendscope &quot;/&quot; do # 声明多个通道 pipe_through [:browser, :auth] get &quot;/reviews/new&quot;, PostController, :new post &quot;/reviews&quot;, PostController, :createend forwardforward用于将特定路径的请求发送到特定插件 123456789101112131415defmodule HelloWeb.Router do use HelloWeb, :router ... # 以 /jobs 开头的请求发送到 BackgroundJob.Plug 模块 forward &quot;/jobs&quot;, BackgroundJob.Plug scope &quot;/&quot;, HelloWeb do ... # 可以在scope中声明指定子路径 forward &quot;/jobs&quot;, BackgroundJob.Plug endend","link":"/2024/01/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Router/"},{"title":"函数","text":"函数声明、参数列表、匿名函数、入口函数 函数声明Dart中函数也是一种对象，也就意味着函数可以被赋值给变量或作为其他函数的参数 123456[返回值类型] 函数名(参数列表){ //...}//函数体只包含一个表达式时可以简写为箭头函数[返回值类型] 函数名(形参列表)=&gt;表达式 说明： 所有函数都有返回值，没有返回语句默认最后一行为 return null； 返回值类型可以省略，由编译器推断； 举例如下： 1234567891011//函数声明String fun1(String? p1,String p2){ print(&quot;fun&quot;); return &quot;&quot;;}//箭头函数String fun2(String p1,String p2) =&gt; p1+p2;//将函数赋值给变量Function fun = fun1 参数列表参数可以使用尾逗号。参数列表格式为类型 参数，其中参数的类型可以省略，但这样就无法使用该类型的方法 必要参数：声明在参数列表前面，调用函数时必须要传递； 可选参数：声明在必要参数后面，可选参数可以是命名参数或位置参数 。可以**使用=为命名参数和位置参数定义默认值，没有默认值的情况下默认值为null**； 举例如下： 12345678910111213141516void main(List&lt;String&gt; arguments) { //命名参数 fun1(&quot;p1&quot;, p2:&quot;p2&quot;); //位置参数 fun2(&quot;p1&quot;,&quot;p2&quot;);}//命名参数String fun1(String? p1,{required String p2,String p3=&quot;p3&quot;}){ print(&quot;fun1&quot;); return &quot;&quot;;}//位置参数，p1的类型可以省略String fun2(p1,[String? p2,String p3 = &quot;p3&quot;]){ print(&quot;fun2&quot;); return &quot;&quot;;} 命名参数使用{}包裹命名参数，在传递参数时使用参数名:参数值的形式传递。可以通过required标识一个命名参数是必须的还是可选的，默认是可选 12345//命名参数声明void funName({[required] 类型1 参数名1 ,...}){} //命名参数传递funName(参数名1:值1 ,...) 位置参数使用[]包裹位置参数，调用时只需要按顺序传递即可 12//声明位置参数void funName([类型1 参数名1 ,...]){} 匿名函数12345([类型] 参数,...) { 函数体;};//如果函数内只有一个返回语句，可以使用箭头函数(参数列表) =&gt; 表达式; 举例如下： 12345678//匿名函数var fun = (String p1) { print(&quot;匿名函数&quot;);};//调用函数fun(&quot;1&quot;);//箭头函数(String p1) =&gt; p1; 入口函数每个Dart程序都必须有一个main()顶级函数作为程序的入口，main()返回值为void，并且有一个List&lt;String&gt; 类型的可选参数，用来包装命令行参数信息 123void main(List&lt;String&gt; arguments) { //...}","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/"},{"title":"异常处理","text":"抛出异常、捕获异常 抛出异常通过throw可以抛出任意对象，不过一般为异常对象。 1throw 任意对象 说明： 它本身是一个表达式，可以用于箭头函数； 举例如下： 1throw &quot;123&quot;; 捕获异常可以使用on或catch捕获异常 on：指定异常类型 catch：捕获异常对象 12345678910111213try{ //...}on 异常类型{ //... //重新抛出异常 rethrow;}on 异常类型 catch(异常对象,栈信息){ //...}catch (异常对象,栈信息){ //...}finally{ //...} 说明： rethrow关键字用于再次抛出异常； finally 语句始终执行，如果没有指定 catch 语句来捕获异常，则异常会在执行完 finally 语句后抛出；","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"控制流","text":"函数条件语句、循环语句、跳转语句、断言 条件语句if 语句基本语法12345678//条件必须是布尔值，不能为其它类型if(条件表达式){}else if(条件表达式){}else{} switch 语句基本语法switch使用==进行比较， 1234567891011//变量一般为枚举、整数、字符串switch(对象){ case 常量: //... break; case 常量: //... break; default: //...} 条件表达式条件表达式可以用来替代if-else语句： condition?exp1:exp2：条件成立返回exp1结果，否则返回exp2结果； exp1??exp2：exp1结果为非null则返回其值，否则执行并返回exp2； 循环语句for 语句基本语法循环中会自动捕获索引值，所以不会出现js中闭包的变量引用问题 123for(初始化;条件;迭代){ } for-in 循环12345for(item in 可迭代对象){}//可迭代对象也可以使用forEach()方法遍历collection.forEach(print); while 语句基本语法123while(条件){ } do 语句基本语法123do{ }while(条件) 跳转语句 break：结束循环； continue：跳过本次循环直接进入下一次循环； 断言条件表达式为false时会打断代码执行 1assert(条件表达式 [,信息]) 断言生效取决于开发工具和框架： Flutter调试时生效； 一些工具默认生效，如dartdevc； 其他工具运行程序时添加命令行参数enable-asserts时断言生效； 举例如下： 1assert(text != null);","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"类型系统","text":"变量、常量、数字类型、布尔类型、字符串、标识、动态类型 变量1[late] 类型/var[?] 变量名 = 变量值; 说明： late关键字：表示在后面使用前会初始化，在声明是可以不初始化，如果使用前不初始化会报错； final：可以替代var关键字或加在类型前，表示该变量只能被赋值一次； 举例如下： 123456789101112//varvar name1 = &quot;魔力猫1&quot;;//所有的类都继承于 Object 类Object name2 = &quot;魔力猫2&quot;;//指定类型String name3 = &quot;魔力猫3&quot;;//latelate String name4;name4 = &quot;魔力猫4&quot;;//finalfinal name5 = &quot;魔力猫&quot;;final String name6 = &quot;魔力猫&quot;; 常量使用const可以替代var关键字或加在类型前，const 变量同时也是 final 的，表示常量（上下文中该值只有一个） 1234567891011//声明常量const name1 = &quot;魔力猫&quot;;const String name2 = &quot;魔力猫&quot;;//有些类支持常量构造函数const a1 = const Animal();const a2 = const Animal();print(a1==a2); //true//const可以省略一个，因为上下文可以推断出来const map1 = const {};const map2 = const {};print(map2==map1); //true 数字类型int和double都是num的子类，num 中定义了一些基本的运算符，还定义了一些相关方法 类型 长度 int 不超过64位 double 64位 int类型取值范围取决于不同平台 DartVM：-2^63^ ~2^63-1^ Web ：-2^53^ ~2^53-1^ 数字类型字面量格式 十六进制：使用 0x 或 0X 前缀，例如：0x10 科学计数法：底数+E/e+指数，例如：314e-2 布尔类型 类型 取值范围 bool true/false 字符串 类型 编码格式 每个字符长度(字节) String UTF-16 2~4 Runes Unicode 4 Runes就是将变长的String转化为Unicode编码的定长码位 字符串声明1234567891011//可以使用单引号和双引号声明字符串var s1 = '单引号';var s2 = &quot;双引号&quot;;//使用\\作为转义字符var s3 = '\\'';//单引号和双引号结合使用var s4 = &quot;双引号'单引号'&quot;;//r作为字符串前缀var s4 = r'不会解析转移字符\\n';//获取runesRunes r = '字符串'.runes; 说明： r作为字符串前缀，此时不会对该字符串做任何处理，比如转义字符； 字符串操作 使用==运算符判断两个字符串内容是否一样 使用+拼接多个字符串 多行字符串使用三个单引号或者三个双引号也能创建多行字符串 1234var s = '''第一行第二行，转义字符\\'''第三行'''; 模板字符串在字符串中，可以使用${表达式}嵌入表达式，如果表达式时一个标识符，可以省略掉{}，会调用表达式结果的toString方法获取结果字符串 12int i = 1;String s = &quot;i=$i，i+1=${i+1}&quot;; 字符串与数字相互转换字符串 -&gt; 数字使用parse()方法将字符串解析为数字 1234567// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1); 数字 -&gt; 字符串通过字符串的toString()方法将数字转化为字符串 1234567// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14'); 标识Symbol表示Dart 中声明的操作符或者标识符，一般不会使用 1#操作符/关键字 举例如下： 12var p = #public;var add = #+; 动态类型dynamic 可以接收认可类型 1dynamic p = &quot;aaa&quot;;","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"运算符","text":"算数运算符、关系运算符、类型运算、逻辑运算符、位运算符、级联运算符、运算符优先级 算数运算符 运算符 描述 + 加 – 减/负号 * 乘 / 除 ~/ 除并取整 % 取模 ++ 自增 -- 自减 = 赋值 运算符= 赋值 关系运算符 运算符 描述 == 相等 != 不等 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 类型判断运算符 运算符 描述 as 类型转换（也用作指定 类前缀)） is 如果对象是指定类型则返回 true is! 如果对象是指定类型则返回 false 逻辑运算符 运算符 描述 ! 逻辑非 ` &amp;&amp; 逻辑与 位运算符 运算符 描述 &amp; 按位与 ` ` ^ 按位异或 ~*表达式* 按位取反（即将 “0” 变为 “1”，“1” 变为 “0”） &lt;&lt; 位左移 &gt;&gt; 位右移 &gt;&gt;&gt; 无符号右移 级联运算符(2.12及以上版本)级联运算符可以在一个对象上连续调用多个对象的方法或变量： .. ?.. 举例如下： 1234567891011void main() { var animal = new Animal() ?..name = &quot;魔力猫&quot; ..age = 3;}class Animal{ late String name; late int age;} 运算符优先级优先级从上到下，从左到右依次递减 描述 运算符 一元后缀 exp++ exp-- () [] . ?. 一元前缀 -exp !exp ~exp ++exp --exp 乘除法 * / % ~/ 加减法 + - 位运算 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 二进制与 &amp; 二进制异或 ^ 二进制或 ` 关系和类型测试 &gt;= &gt; &lt;= &lt; as is is! 相等判断 == != 逻辑与 &amp;&amp; 逻辑或 ` 空判断 ?? 条件表达式 condition?exp1:exp2 级联 .. ?.. 赋值 = *= /= += -= &amp;= ^= 等等……","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"集合","text":"数组、无序集合、字典 数组在Dart中数组由List对象表示，也可以成为列表 数组声明1234567891011//最后一个逗号可有可无List&lt;类型&gt; list = [值1,值2,值3,];//指定类型var list = &lt;类型&gt;[];//使用const关键字创建编译时常量var list = const [值1,值2,值3];//创建指定数量，每个值一样的的列表List.generate(数量,对象); 数组操作取值123var list = [1, 2, 3];//使用下标进行索引list[0] 展开使用下面操作符可以更方便的将多个元素插入集合： 扩展操作符：...，将一个List中的元素展开； 空感知扩展操作符：...?，在...的基础上避免了list为null时产生的异常； 12345var list = [1, 2, 3];//将list中元素加入到newList1var newList1 = [0, ...list];//避免list为null时产生异常var newList2 = [0, ...?list]; if在创建时可以使用条件语句（if） 123456List&lt;int&gt; list = [ 1, 2, 3, if(true) 4]; for在创建时可以使用循环语句（for） 123456List&lt;int&gt; list = [ 1, 2, 3, for(int i=1;i&lt;10;i++) i+3]; 无序集合无序集合声明12345678//一般形式Set&lt;类型&gt; set = {值1,值2,值3};//指定类型var set = &lt;类型&gt;{}//使用const关键字创建编译时常量var set = const {值1,值2,值3}; 相关操作展开使用下面操作符可以更方便的将多个元素插入集合： 扩展操作符：...，将一个List中的元素展开； 空感知扩展操作符：...?，在...的基础上避免了list为null时产生的异常； 12345var set = {1, 2, 3};//将list中元素加入到newList1var newSet1 = [0, ...set];//避免list为null时产生异常var newSet2 = [0, ...?set]; if12345var set = { 1, 2, if(true) 3}; for12345var set = { 1, 2, for(int i=0;i&lt;0;i++) i+2}; 字典字典声明Map和Set都使用{}声明， 123456//一般声明Map&lt;key类型,value类型&gt; map = { key1:value1, key2:value2, //...} 举例如下： 12345var map = { 1:&quot;v1&quot;, &quot;k2&quot;:&quot;v2&quot;, 3.14:&quot;v3&quot;,}; 字典操作取值12//如果key不存在则会返回nullmap[key值]; 举例如下： 12345678910var map = { 1:&quot;v1&quot;, &quot;k2&quot;:&quot;v2&quot;, 3.14:&quot;v3&quot;,};print(map[1]); //v1print(map['k2']); //v2print(map[3.14]); //v3print(map[2]); //null 赋值1map[key值] = value值 举例如下： 12345var map = { &quot;k1&quot;:&quot;v1&quot;,};map['k1'] = &quot;new-v1&quot;; if1234var map = { 1:&quot;v1&quot;, if(true) &quot;k4&quot;:&quot;v4&quot;,}; for1234var map = { 1:&quot;v1&quot;, for(int i=1;i&lt;10;i++) &quot;k$i&quot;:&quot;v$i&quot;};","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"},{"title":"面向对象","text":"类、继承、抽象、接口、混合、泛型、枚举 类dart中所有对象都是类的实例，除了null外所有类都继承于Object类。使用class关键字声明一个类 12345//类声明class 类名{}//创建类对象类名(参数列表) 通过.或?.调用类对象的方法或属性，?.用于避免对象为null的情况 成员变量类中的成员变量被多个关键字修饰。可空变量（变量加?）若不初始化默认为null late：可以先不初始化 final：变量只能初始化一次 static：类的静态变量； 举例如下： 1234567891011class Animal{ //常量必须初始化 final String name1 = &quot;&quot;; late String? name2; late final String name3; static String? name4;} 构造函数构造函数名与类名相同，内部使用this引用当前对象。构造函数不能被继承： 默认构造函数：如果没有声明构造函数，那么会有一个默认无参构造函数； 命名构造函数：可以为一个类声明多个命名式构造函数来表达更明确的意图； 重定向构造函数：在一个构造函数内调用其他构造函数，可以在初始化列表部分使用this指定调用的构造函数； 常量构造函数：在类的构造函数前加const可以声明常量构造函数 常量构造函数只能用于所有成员变量都为final修饰的类； 在创建类对象时可以使用const修饰变量或构造函数，只要参数一致就会返回同一个对象； 如果不用const修饰变量或构造函数，即便调用常量构造函数，返回的也不是常量实例； 常量构造函数传递参数时，其参数也应该是字面量或常量； 工厂构造函数：使用factory关键字可以标识静态工厂构造函数，在工厂构造函数内部可以编写工厂逻辑，如在缓存中获取等； 父类构造函数：子类可以使用:指定调用父类的构造函数，子类默认的构造函数执行流程为： 初始化列表； 父类无参构造函数； 子类构造函数； 具体细节如下列代码所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Animal{ //所有未初始化的实例变量值为null String? name; int? age; Animal(String name,int age){ this.name=name; this.age=age; } //命名构造函数，格式：类名.函数名 Animal.MoLiMao(){ name = &quot;魔力猫&quot;; age = 3; } //dart为简化成员变量的赋值提供了一种语法糖 Animal.assignment(this.name,this.age); //初始化列表会在构造函数体之前执行变量的初始化 Animal.initList(name,age): this.name=name, this.age=age{ //... } //在开发模式下，可以在初始化列表上使用assert进行验证 Animal.check(String name,age):assert(name.length&gt;2,&quot;名字太短&quot;); //重定向构造函数 Animal.name(name):this(name,3); static late final Animal animal; //工厂构造函数 factory Animal.factory(){ animal ??= Animal(&quot;动力猿&quot;, 3); return animal; }}class Cat extends Animal{ //选择的父类构造函数为：MoLiMao() Cat():super.MoLiMao(){ print(&quot;子类构造函数&quot;); }}class Dog{ final String? name; //常量构造函数 const Dog(this.name);} 方法dart类中方法的定义和正常的方法定义相同，只不过在实例方法内部可以访问this、实例变量和实例方法 noSuchMethod 方法如果调用了对象上不存在的方法或实例变量将会触发 noSuchMethod 方法，可以重写该方法 123456class A { @override void noSuchMethod(Invocation invocation) { print('该方法不存在'); }} 扩展方法todo 运算符重载dart允许重载以下运算符 &lt; + | &gt;&gt;&gt; &gt; / ^ [] &lt;= ~/ &amp; []= &gt;= * &lt;&lt; ~ – % &gt;&gt; == 使用operator关键字进行进行运算符重载 123456789101112131415void main(List&lt;String&gt; arguments) { var a1 = Animal(99, 99); var a2 = Animal(100, 100); print(a1+a2);}class Animal{ int hp; int mp; Animal(this.hp,this.mp); Animal operator +(Animal animal)=&gt;Animal(hp+animal.hp, mp+animal.mp);} Getter和SetterGetter和Setter是用来读写对象属性的特殊方法，每个属性都有一个隐式的Getter方法，非final的属性还会有一个Setter方法，可以使用get和set关键字为额外的属性添加Getter和Setter方法 1234567891011class Animal{ int hp; int mp; int get total =&gt; hp + mp; set total(int value) { mp=(hp=(value/2) as int); } Animal(this.hp,this.mp);} 继承和实现使用implements关键字可以实现一个接口 使用extends关键字可以继承一个类： 子类可以使用super关键字引用父类对象； 子类可以重写父类的实例方法，包括操作符、Getter和Setter： 返回类型必须与被覆盖方法的返回类型相同（或子类型）。 参数类型必须与被覆盖方法的参数类型相同（或超类型）。 12345678910111213141516171819202122class A{ void fun(){}}//实现接口class B implements A{ @override void fun() { // TODO: implement fun }}//继承类class C extends A{ void sunFun(){ super.fun(); } @override void fun() { // TODO: implement fun super.fun(); }} 抽象类和抽象方法使用abstract关键字声明抽象类 抽象类无法被实例化，但可以定义工厂构造函数； 抽象方法： 实例方法、Getter和Setter都可以是抽象方法； 只是声明不做具体实现； 只能存在于抽象类中； 123abstract class Animal{ void cry();} 接口隐式接口定义类的时候都隐式的定义了一个接口，这个接口包含了这个类中的所有实例成员以及这个类所实现的其他接口。 123class A{}//没有继承A类，而是实现了A的接口class B implements A{} Mixin（2.1+）混入（Mixin）主要用于对类进行扩展，可以看作是。使用mixin关键字创建一个Mixin类，该Mixin类继承自Object且未声明构造函数。配合两个关键字使用： with：声明该类可以使用某些Mixin类； 12//此时通过A可以使用B的方法，相当于把B的方法注入给了Aclass A with B{} on：声明Mixin类可以被某些类使用； 123456789101112131415//限定B可以使用mixin A on B{ void aFun(){}}class B{}class C extends B with A{ void cFun(){ //使用A中方法 aFun(); }} 泛型泛型声明泛型通过&lt;占位符&gt;声明，可用在类上或者方法上 1234//泛型类class C&lt;T&gt;{}//泛型方法T fun&lt;T&gt;(T t) =&gt; t; 说明： java中的泛型会在运行时移除，也就是说在运行时无法判断对象是否为A&lt;type&gt;类型，但dart中的泛型在运行时仍然存在； 声明集合可以通过泛型声明集合类型 123456var list = &lt;String&gt;['v1', 'v2', 'v3']; var set = &lt;String&gt;{'v1', 'v2', 'v3'}; var map = &lt;String, String&gt;{ 'k1': 'v1', 'k2': 'v2', }; 泛型限制 extends：&lt;T extends Y&gt;表示T必须是Y的子类型； 1234567891011class A{}class B extends A{}//T必须是A的子类class C&lt;T extends A&gt;{}void main(List&lt;String&gt; arguments) { //调用构造函数时声明泛型 var c = C&lt;B&gt;();} 枚举枚举声明使用enum关键字声明枚举： 枚举不能被实现也不能是子类； 枚举类不能显示实例化； 123456enum Color{ red, yellow, //最后一个,可以省略 blue,} 每个枚举值都有一个名为index的成员变量的Getter方法，该方法会返回以0开始的索引的位置值","link":"/2023/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Dart/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"集合","text":"列表、元祖、关键字列表、映射 列表 列表可以包含任意个类型不同或相同的值； 内部由链表实现； 在尾部插入更快； 获取列表长度是 O(n) 的操作； 列表声明1[3.14, :pie, &quot;Apple&quot;] 列表拼接使用++进行列表的拼接 1[1, 2] ++ [3, 4, 1] # [1, 2, 3, 4, 1] 列表减法使用-- 进行列表的拼接 12[&quot;foo&quot;, :bar, 42] -- [42, &quot;bar&quot;] # [&quot;foo&quot;, :bar][1,2,2,3,2,3] -- [1,2,3,2] #[2, 3] 减去不存在的值也是安全的； 如果有重复的值只会移除一个； 这里判断重复使用的是严格比较（===）； 列表头尾 头部：列表第一个元素 尾部：除去第一个元素剩下的列表 方法名 说明 hd 列表 获取列表头部 tl 列表 获取列表尾部 [head | tail] = 列表 使用模式匹配的方式获取列表头尾 元组元组在内存中是连续存放的，可以认为是数组； 元组声明1{3.14,:pie,&quot;apple&quot;} 关键字列表列表里的内容是二元元组，拥有以下性质： 二元组的key必须是原子类型； 二元组的是有序的； 二元组的key可以不唯一； 一般用于作为参数传递给函数； 关键字列表声明1234#方式1[foo: &quot;bar&quot;, hello: &quot;world&quot;]#方式2[{:foo, &quot;bar&quot;}, {:hello, &quot;world&quot;}] 映射 映射允许任意类型的数据作为key； key可以是变量（Elixir 1.2）； 数据并不严格排序； 映射声明使用 %{} 来定义映射： 12345678#一般声明map = %{:foo =&gt; &quot;bar&quot;, &quot;hello&quot; =&gt; :world}#key只有原子的映射，可以不用 =&gt;#以下两种声明方式等价%{foo: &quot;bar&quot;, hello: &quot;world&quot;}%{:foo =&gt; &quot;bar&quot;, :hello =&gt; &quot;world&quot;} 如果key重复，则后面的值会覆盖前面的值； 更新元素12map = %{foo: &quot;bar&quot;, hello: &quot;world&quot;}%{map | foo: &quot;baz&quot;} #map变为%{foo: &quot;baz&quot;, hello: &quot;world&quot;} 获取元素12map = %{foo: &quot;bar&quot;, hello: &quot;world&quot;}map.hello #&quot;world&quot; 如果键不存在，则会抛出 KeyError 错误；","link":"/2023/12/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"},{"title":"类型系统","text":"数据类型、变量 类型系统变量Elixir 中的变量都是不可变的，在编写程序时很多情况下都有限制： 为变量赋值时 在内层代码块中为外部代码库赋值时会新生成一个变量，外部的变量不会改变 Elixir本身不涉及指针，Erlang虚拟机在其底层实现中会处理指针和内存管理 整数类型无符号整数Elixir的整数是无符号整数，也就是说整数是按照符号和原码存储的，而不是补码 1234iex&gt; 0b1117iex&gt; -0b111-7 进制表示 进制 前缀 举例 二进制 0b 0b0110 八进制 0o 0o644 十六进制 0x 0x1F 浮点类型Elixir要求小数点之前必须有一个数字，有两种表示方法： 支持64位精度 科学计数法 1234iex&gt; 3.143.14iex&gt; 1.0e-101.0e-10 布尔类型Elixir 支持 true 和 false 两种布尔值，除了 false 和 nil 之外所有的值都为真。 原子类型字符串Elixir 的字符串就是字节序列，是UTF-8编码的，用双引号包住： 12iex&gt; &quot;Hello&quot;&quot;Hello&quot; 字符串插值12name = &quot;world&quot;&quot;Hello #{name}&quot; 字符串拼接使用 &lt;&gt; 操作符进行字符串拼接： 12345string1 = &quot;Sean&quot;&quot;Hello &quot; &lt;&gt; string1 # 结果为&quot;Hello Sean&quot;string2 = &lt;&lt;104,101,108,108,111&gt;&gt;string2 &lt;&gt; &lt;&lt;0&gt;&gt;","link":"/2023/12/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"包管理器","text":"安装目录、包管理命令 目录结构一个Go工程中主要包含以下三个目录： src：存放下载的源代码文件 pkg：包文件，包含本项目的依赖，类似于maven的本地仓库路径； bin：存放下载的可以直接运行的程序； go get1go get 远程包地址 作用： 拉取远程依赖，并自动完成编译和安装； 需要安装与远程依赖包匹配的管理工具，比如github上的包要事先安装git； 下载的包会存储在gopath目录下； 选项： -d：只下载不安装； -v：显示执行的命令； -u：强制使用网络去更新包和它的依赖包 举例： 1go get github.com/gin-gonic/gin go build123go buildgo build 文件列表go build 包 作用： 编译指定的文件或包，生成可执行文件； 如果没加参数则会在当前目录中搜索入口文件进行编译； [ output] [-i] [build flags] 选项： -o：输出路径； 举例： 1go build -o ./targrt a.go b.go","link":"/2023/02/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"函数","text":"函数 函数声明12345678//函数定义func 函数名(形参列表) (返回值列表) { 函数体 return 返回值列表}//调用函数格式变量1,变量2,…… = 函数(形参) 形参列表 格式为：(变量1 类型1, 变量2 类型2, ……) 多个连续的相同类型参数只需要声明最后一个类型 1func test(x, y int, s string) (){} 返回值列表 格式为：(名称1 类型1, 名称1 类型2, ……)，其中名称是可选的，叫做命名返回值。如果定义了名称可以在函数中直接使用 命名返回参数可被同名局部变量遮蔽，此时需要显式返回 如果函数没有返回值，则返回列表可以省略 参数根据传递的类型可分为值传递和引用传递 不能用容器接收返回值，只能由多个变量或下划线 函数返回值可以直接作为其他函数的实参 return语句 格式为：返回值1, 返回值2, …… 返回值要与返回值列表对应，如果返回值列表为空则 return 可省略 return 表示跳出所在的函数 使用（_）下划线忽略某个返回值 没有参数的 return 语句会自动返回对应名字的变量，被称为裸返回 函数也是一种类型，一个函数可以赋值给变量，可通过这种方式进行传递 12345678func main() { test := Test test()}func Test() { println(&quot;Test&quot;)} 补充： 不支持函数的重载 不支持默认参数 匿名函数匿名函数是指不需要定义函数名的一种函数实现方式。在Go里面，函数可以像普通变量一样被传递或使用。定义方式和函数一样只不过不需要声明函数名 12345678910func main() { var v = 123 f := func() string { //可以访问外部局部变量 fmt.Printf(&quot;v=%d&quot;, v) return &quot;a&quot; } f()} 闭包所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 12345678910111213141516func a() func() int { i := 0 b := func() int { i++ fmt.Println(i) return i } return b}func main() { c := a() c() //1 c() //2 c() //3} 调用a()方法返回的是一个匿名函数b，并且b中引用了a中的变量i，此时就产生了一个闭包，变量i的声明周期被延长，不会因为a()执行完就被回收。底层其实是复制了原对象的指针，所以不会被回收 内置函数Go语言有一些不需要进行导入操作就可以使用的内置函数，其中针对不同数据类型的操作： append：用来追加元素到数组、slice中，返回修改后的数组、slice； close：主要用来关闭channel； delete：从map中删除key对应的value； panic：停止常规的goroutine （panic和recover：用来做错误处理）； recover：允许程序定义goroutine的panic动作； new：用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针，详细介绍； make：用来分配内存，返回Type本身(只能应用于slice, map, channel)，详细介绍； cap：capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）； copy：用于复制和连接slice，返回复制的数目； len：来求长度，比如string、array、slice、map、channel ，返回长度； print、println：底层打印函数，在部署环境中建议使用 fmt 包； 入口函数Go语言程序的默认入口函数(主函数)：func main() 1234# 一个包中只能定义一个func main(){ //函数体} main和Init在定义时不能有任何的参数和返回值，且Go程序自动调用","link":"/2023/02/03/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/"},{"title":"并发","text":"协程、管道 协程go中的协程（goroutine）类似于java多线程，但不像java中线程那样需要自己声明线程、定义任务、管理线程的调度执行。协程会在运行时自动将任务合理分配给每个CPU不需要认为管理。 声明协程只需要将需要执行的任务封装成一个func，使用go换剪子进行运行即可 123456func f(){ //异步任务执行内容}//运行协程go f() 补充： main()函数再启动时系统会默认创建一个协程，当main()的协程结束后，在其中开启的协程（包括在其他方法内间接开启的）都会结束 runtime 包runtime 包中包含很多控制协程的方法 方法 作用 runtime.Gosched() 让出CPU时间片 runtime.Goexit() 结束当前协程 runtime.GOMAXPROCS(n) 设置当前程序并发时占用的CPU逻辑核心数 管道","link":"/2023/02/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/"},{"title":"异常处理","text":"异常处理 抛出异常 panic函数用于抛出异常，panic函数之后的代码不会执行 12345func main() { println(&quot;panic前&quot;) panic(&quot;panic error!&quot;) println(&quot;panic后&quot;) //不会执行} 捕获异常recover语句用于捕获异常，一般声明在一个defer的匿名函数中，未捕获的异常会沿着调用栈向外传递 123456789func main() { defer func() { //异常只能捕获一次，第二次recover()获取不到值 if err := recover(); err != nil { println(err.(string)) } }() panic(&quot;panic error!&quot;)} 实现try-catch1234567891011121314151617181920//fun是将要执行的方法，对应try内容//handler是发生错误应该执行的方法，参数是接口，对应catch内容func Try(fun func(), handler func(interface{})) { defer func() { //如果发生错误，则进行处理 if err := recover(); err != nil { handler(err) } }() //执行方法主体 fun()}func main() { Try(func() { panic(&quot;test panic&quot;) }, func(err interface{}) { fmt.Println(err) })} 自定义error还可以使用 error 类型错误对象作为 panic 函数的参数，来表示函数调用状态。使用errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型 1234567891011121314151617181920func main() { defer func() { fmt.Println(recover()) }() switch i, err := test(); err { case nil: println(i) case myError: panic(err) } panic(myError)}var myError = errors.New(&quot;dmyError&quot;)func test() (int, error) { return 1, myError} 如果使用errors.New 无法满足需求，也可以自定义异常 1234567891011121314151617181920212223242526272829func main() { defer func() { fmt.Println(recover()) }() switch err := test(); err.(type) { case nil: println(&quot;没异常&quot;) case *myError: panic(err) }}type myError struct { code string createTime string message string}//添加名为Error，返回值为string类型的方法func (p *myError) Error() string { return fmt.Sprintf(&quot;code=%s \\ncreateTime=%s \\nmessage=%s&quot;, p.code, p.createTime, p.message)}func test() error { return &amp;myError{&quot;200&quot;, &quot;2022.1.8&quot;, &quot;我错了&quot;}} panic 和 error 区别： error为函数起到一个标识的作用不会影响执行，而panic会影响函数执行 导致关键流程出现不可修复性错误的使用 panic，其他使用 error","link":"/2023/03/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"数据类型","text":"值类型、引用类型、类型转换 值类型整数类型类型关键字 类型 有无符号 占用空间 取值范围 备注 int 有 取决于系统位数 int8 有 1Byte -128~127 int16 有 2Byte -2^15^~2^15^-1 int32 有 4Byte -2^31^~2^31^-1 int64 有 8Byte -2^63^~2^63^-1 rune 有 4Byte -2^31^~2^31^-1 同int32 uint 无 取决于系统位数 uint8 无 1Byte 0~255 uint16 无 2Byte 0~2^16^-1 uint32 无 4Byte 0~2^32^-1 uint64 无 8Byte 0~2^64^-1 byte 无 1Byte 0~255 同uint8 uintptr 无 4或8 以存储指针的 uint32 或 uint64 整数 int和uint大小与操作系统位数相同，32位操作系统为4个字节，64位操作系统为8个字节 进行类型推导时整型会被推导为int 其中rune和byte主要用来处理字符类型 uintptr由系统决定占用位大小，足够存放指针即可，和C库或者系统接口交互 字面量格式 进制 格式 二进制 0b开头 八进制 0、0o开头 十六进制 0x开头 浮点类型 类型 占用空间（字节） 取值范围 float32 4 -3.403E38~3.403E38 float64 8 -1.798E3.8~1.798E3.8 浮点数默认类型为float64； 浮点类型可以使用科学计数法表示； 复数类型 类型 占用空间（字节） 取值范围 complex64 8 complex128 16 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。 real：返回complex的实部 （complex、real imag：用于创建和操作复数）； imag：返回complex的虚部； 字符类型byte 和 rune 类型Go中没有专门的字符类型，基本所有整形都可以用来表示字符类型，但通常使用byte（uint8）型或rune（int32）型来表示字符型变量 byte： 代表了 ASCII 码的一个字符； byte 类型是 uint8 的别名； rune： 代表一个Unicode（UTF-8）字符； 处理中文、日文或者其他复合字符； 在书写Unicode字符时，需要在 16 进制数之前加上前缀\\u或者\\U,如 1var ch int = '\\u0041' 可以通过数字或者字符两种形式赋值，比如： 1234//数字var f byte = 99//字符var f byte = 'c' 转义字符字符串中可以使用转义字符来实现换行、缩进等效果 1var a string = &quot;hello \\n world&quot; 转义字符 作用 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\&quot; 双引号 \\ 反斜杠 \\\\ 反斜杠自身 \\u 或 \\U Unicode 字符 补充： UTF-8是一种变长编码规则，大小从1到4个字节不等，比如中文占三个，拉丁文占两个； 布尔类型 类型 占用空间 取值范围 bool 1Byte true/false 补充： bool一般用于逻辑运算，与条件/循环语句配合使用 字符串类型 类型 定义 string var f string = “hello world” 字符串定义1234567//可以使用&quot;&quot;来定义字符串var a string = &quot;hello world&quot;//使用反引号``来定义多行字符串//在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。var a string = `hello world` 字符串操作索引字符串的内容（纯字节）可以通过标准索引法来获取，在方括号[]内写入索引，索引从 0 开始计数： 12//最后1个字节str[len(str)-1] 拼接字符串拼接符使用“+” 12345var a string = &quot;hello &quot;var b string = &quot;world&quot;fmt.Println(a + b) //hello world//也可以使用“+=”a+=b //hello world 修改字符串要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组 12345678910s1 := &quot;hello&quot;// 强制类型转换byteS1 := []byte(s1)byteS1[0] = 'H'fmt.Println(string(byteS1))s2 := &quot;博客&quot;runeS2 := []rune(s2)runeS2[0] = '狗'fmt.Println(string(runeS2)) 字符串和切片string底层就是一个byte的数组，因此，也可以进行切片操作 12str := &quot;hello world&quot;s1 := str[0:5] //hello string本身是不可变的，因此要改变string中字符。需要转换为数组 1234str := &quot;Hello world&quot;s := []byte(str) //中文字符需要用[]rune(str)s[6] = 'G' s = s[:8] //&quot;Hello Go&quot; 常用方法 方法 功能 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.Contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 str.Join(a[]string, sep string) join操作 补充： 字符串是UTF-8字符的一个序列（当字符为ASCII码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节） 字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，或者说字符串是定长的字节数组 一般的比较运算符（==、!=、&lt;、&lt;=、&gt;=、&gt;）是通过在内存中按字节比较来实现字符串比较的 数组数组是同一种数据类型的固定长度的序列 数组定义数组声明只定义但未初始化会赋默认值 1234//len：数组的长度，必须是常量var arr [len]类型//数组无法用const声明 一维数组初始化123456789101112131415161718192021222324252627282930//全局var arr0 [5]int = [5]int{1, 2, 3}var arr1 = [5]int{1, 2, 3, 4, 5}var arr2 = [...]int{1, 2, 3, 4, 5, 6}//未指定的位置为该类型的默认值var str = [5]string{3: &quot;hello world&quot;, 4: &quot;tom&quot;}func main() { //局部 a := [3]int{1, 2} // 未初始化元素值为0 b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度 c := [5]int{2: 100, 4: 200} // 使用引号初始化元素 //结构体切片/数组 d := [...]struct { name string age uint8 }{ {&quot;user1&quot;, 10}, // 可省略元素类型。 {&quot;user2&quot;, 20}, // 最后一行需要逗号 } //通过.修改 struct array/slice 成员 d[0].name = &quot;张三&quot; arr := [...]int{1, 1, 1, 1} //获取数组底层元素的指针 p := &amp;arr[2] //通过指针直接操作数组元素 *p += 10} 多维数组初始化1234567891011//全局var arr0 [5][3]intvar arr1 [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}}func main() { //局部 a := [2][3]int{{1, 2, 3}, {4, 5, 6}} //第 2 纬度不能用 &quot;...&quot; b := [...][2]int{{1, 1}, {2, 2}, {3, 3}} c := [...][2][3]int{{{1, 2, 3}, {4, 5, 6}}, {{1, 2, 3}, {4, 5, 6}}}} 补充： 数组是值类型，赋值和传参会复制整个数组，而不是指针； 数组操作多维数组遍历12345678var f [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}}for index1, values := range f { for index2, value := range v1 { fmt.Printf(&quot;(%d,%d)=%d &quot;, index1, index2, int) } fmt.Println()} 参数传递1234567891011121314151617181920//值传递func valueParam(arr *[5]int) { arr[0] = 1}//地址传递func addrParam(arr [5]int) { arr[0] = 1}func main() { var arr [5]int //值传递不会改变值 addrParam(arr) fmt.Println(arr) //[0 0 0 0 0] //传递指针可以改变值 valueParam(&amp;arr) fmt.Println(arr) //[1 0 0 0 0]} 常用方法 方法名 作用 len(数组) 元素长度 cap(数组) 元素容量 补充： 切片的方法同样适用于数组 引用类型指针指针类型存储的是一个地址，所以不能像基本数据类型那样直接将值赋值给指针类型，也就是说指针类型无法存储数据的值，只能存储变量的地址 操作符取址操作符：&amp;12var val int = 123fmt.Print(&amp;val) //0xc0000aa058 取值操作符：*123var val int = 123var addr *int = &amp;valfmt.Print(*addr) //123 声明格式1234//声明：var 变量名 *T//赋值：变量名 = 地址值var num int = 1var ptr *int = &amp;num new 和 make对于引用类型的变量需要主动为其分配内存，而对于值类型的声明不需要主动分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。new和make是内建的两个函数，主要用来分配内存，两函数介绍如下 new func new(Type) *Type 作用： 为值类型分配内存 参数： Type：表示类型，new函数只接受一个参数，这个参数是一个类型 返回值： *Type：表示类型指针，new函数返回一个指向该类型内存地址的指针 1intPtr := new(int) //未初始化，值为默认值 make func make(t Type, size …IntegerType) Type 作用： 只用于slice、map以及channel的内存分配 参数： Type：变量类型 size：是一个可变形参。指定长度、容量 返回值： Type：返回类型本身，而不是指针 123456//类型声明，未初始化默认值为nilvar b map[string]int//分配内存/初始化b = make(map[string]int, 10) //长度为10var slice []int = make([]int,5,10) //长度为容量为10 补充： 指针类型可以先声明再赋值，但使用前必须赋值； 管道go使用CSP（Communicating Sequential Processes）并发模型，goroutine表示了程序并发的执行内容，而channel用于将不同的协程进行连接，它是让一个goroutine发送特定值到另一个goroutine的通信机制。 channel 定义1234//定义channelvar 变量 chan 传递的数据类型//初始化变量 = make(chan 元素类型, [缓冲大小]) 说明： 创建好的通道默认空值为nil 声明通道后需要使用make()函数进行初始化 举例如下： 1234567891011var ch1 chan int // 声明一个传递整型的通道var ch2 chan bool // 声明一个传递布尔型的通道var ch3 chan []int // 声明一个传递int切片的通道//初始化ch4 := make(chan int)ch5 := make(chan bool)ch6 := make(chan []int)//使用类型推断创建channelch := make(chan int) 常用操作发送发送使用&lt;-符号 123ch := make(chan int)//将数据放到channel中ch &lt;- 10 接收接收使用&lt;-进行接收 1234//接收channel中的数据，赋值给变量xx := &lt;- ch//接收channel中的数据，但不赋值&lt;-ch 关闭通过内置的close()函数关闭通道 1234567891011121314//关闭管道close(ch)//判断通道是否被关闭//方法1：通过接收oki, ok := &lt;-ch1if !ok { break}//方法2：通道关闭后会退出for range循环for i := range ch2 { fmt.Println(i)} 说明： 如果channel0不需要存取值就应该关闭； 对一个关闭的通道再发送值就会导致panic； 对一个关闭的通道进行接收会一直获取值直到通道为空，为空后再接收会获取对应类型的空值； 关闭一个已经关闭的通道会导致panic； 无缓冲 channel无缓冲channel只有在有人接收值时才可以发送，否则会发生死锁，因为没有缓冲区暂存数据。 12345678910111213func main() { //创建无缓冲channel ch := make(chan int) //启动接收者 go func(c chan int) { //接收数据 ret := &lt;-c fmt.Println(&quot;接收成功&quot;, ret) }() //发送数据 ch &lt;- 10 fmt.Println(&quot;发送成功&quot;)} 切片切片是一个可变的数组，是引用类型。与数组不同的是，切片可以添加元素，切片在定义时拥有两个属性： len：当前切片的元素个数 cap：当前切片的容量，如果添加的个数大于这个值会自动扩容成两倍 默认创建的切片len和cap是相等的，也可以通过make()函数自己指定 切片定义一维切片1234567891011121314151617//分配内存//声明切片，默认为nilvar s3 []type//分配内存s3 := make([]type, [len/cap])s3 := make([]type, len, cap)//切片声明和初始化：var 变量名 []类型 //只声明不初始化默认为空var s1 []int = []int{1, 2, 3}//短类型声明s2 := []int{}//从数组获取切片arr := [5]int{1, 2, 3, 4, 5}var s4 []int = arr[1:4] 多维切片123456//[][]T代表元素类型为[]Tdata := [][]int{ []int{1, 2, 3}, []int{100, 200}, []int{11, 22, 33, 44},} 切片操作索引 方法名 作用 s[n] 索引位置为n的项 s[:] 索引位置0到len(n)-1所获得的切片 s[low:] 索引位置low到len(n)-1所获得的切片 s[:high] 索引位置0到high所获得的切片 s[low:high] 索引位置low到high所获得的切片 s[low:high:max] 索引位置low到high所获得的切片，cap=max-low 123456789101112131415161718192021222324//全局var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}var slice0 []int = arr[start:end]var slice1 []int = arr[:end]var slice2 []int = arr[start:]var slice3 []int = arr[:]var slice4 = arr[:len(arr)-1] //去掉切片的最后一个元素func main() { //局部 arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0} slice5 := arr[start:end] slice6 := arr[:end] slice7 := arr[start:] slice8 := arr[:] slice9 := arr[:len(arr)-1] //去掉切片的最后一个元素 //结构体切片/数组 d := [5]struct { x int }{} //通过.修改 struct array/slice 成员 d[1].x = 10} slice遍历12345data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}slice := data[:]for index, value := range slice { fmt.Printf(&quot;inde : %v , value : %v\\n&quot;, index, value)} 字符串和切片string底层就是一个byte的数组，因此，也可以进行切片操作 12str := &quot;hello world&quot;s1 := str[0:5] //hello 常用方法 方法名 作用 len(s) 切片长度 cap(s) 切片容量 append(…) 向 slice 尾部添加数据，返回新的 slice 对象 copy(…) 拷贝切片 append(…)123s1 := make([]int, 0, 5)s2 := append(s1, 1)fmt.Println(s1, s2) //[] [1] copy(…)12345678910to := make([]int, 10)from := []int{1, 2, 3, 4, 5}copy(to, from)//拷贝时复制长度以len小的为准data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s1 := data[8:] //s1：[8 9]s2 := data[:5] //s2：[0 1 2 3 4]copy(s2, s1) //s2：[8 9 2 3 4]data //data：[8 9 2 3 4 5 6 7 8 9] 补充： 超出slice.cap会重新分配底层数组（原本的二倍），与原数组无关，即使原数组未填满； 切片底层都是引用着数组 映射map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用 map定义12345678910111213//未初始化默认值为nil map[KeyType]ValueType//分配内存make(map[KeyType]ValueType, [len])//类型推断testMap := make(map[KeyType]ValueType, [len])//声明时填充元素users := map[string]string{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: &quot;6&quot;,} 参数： KeyType：表示键的类型 ValueType：表示键对应的值的类型 cap：可选项，指定容量 map操作操作map元素12345678testMap := make(map[string]int, 8)//赋值testMap[&quot;张三&quot;] = 90//查看println(testMap[&quot;张三&quot;])//判断map键是否存在value, ok := testMap[&quot;张三&quot;]println(ok) map遍历 遍历map时的元素顺序与添加键值对的顺序无关 123456789101112testMap := make(map[string]int)testMap[&quot;张三&quot;] = 6testMap[&quot;李四&quot;] = 2testMap[&quot;王五&quot;] = 6//使用for range遍历map的key和valuefor k, v := range testMap { fmt.Println(k, v)}//只遍历keyfor k := range testMap { fmt.Println(k)} 指定顺序遍历map 12345678910111213141516//创建maptestMap := make(map[string]int)testMap[&quot;张三&quot;] = 6testMap[&quot;李四&quot;] = 2testMap[&quot;王五&quot;] = 6//取出key存入切片var keys = make([]string, 0, 200)for key := range testMap { keys = append(keys, key)}//对切片进行排序sort.Strings(keys)//根据排序后的切片遍历mapfor index, key := range keys { fmt.Println(index, key, testMap[key])} 常用方法 方法名 作用 delete(map, key) 删除键值对 delete(map, key)参数： map：表示要删除键值对的map key：表示要删除的键值对的键 1234testMap := make(map[string]int)testMap[&quot;张三&quot;] = 6//将key为张三的元素从map中删除delete(testMap, &quot;张三&quot;) 类型转换转换规则123456789//类型转换格式为：T(表达式)//T表示要转换的类型，数组类型//表达式包括变量、复杂算子和函数返回值等//例子b := 3.1var a int = int(b) //3str = &quot;你好&quot;s := []rune(str) 补充： GO中不存在隐式类型转换，在不同变量赋值过程时都需要显式类型转换 转换可以是小-&gt;大，也可以是大-&gt;小，小转大时不会对数据产生影响，但大转小时可能会按截断处理，出现精度丢失的情况 相同底层类型的变量之间可以进行相互转换（int16-&gt;int32），不同底层类型的变量相互转换时会引发编译错误（bool-&gt;int），类型分为：数值、布尔、字符串 int和uint转换用的是补码，比如int值为-2，转换为uint则为18446744073709551614，反之同理 字符串转换（strconv 包）string -&gt; 其他类型布尔类型 func ParseBool(str string) (value bool, err error) 作用： 返回字符串表示的bool值。它接受0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误 参数： str：字符串 1strconv.ParseBool(&quot;false&quot;) 整数类型有符号整型： func ParseInt(s string, base int, bitSize int) (i int64, err error) 作用： 返回字符串表示的整数值，接受正负号 参数： s：字符串 base：进制 bitSize：指定结果类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64 1a, _ := strconv.ParseInt(&quot;123&quot;, 10, 8) func Atoi(s string) (i int, err error) 作用： Atoi是ParseInt(s, 10, 0)的简写 1a, _ := strconv.Atoi(&quot;123&quot;) 无符号整型： func ParseUint(s string, base int, bitSize int) (n uint64, err error) 作用： ParseUint类似ParseInt但不接受正负号，用于无符号整型 参数： s：字符串 base：进制 bitSize：指定结果类型，0、8、1364 分别代表uint、uint8、uint1uint3uint64 1a, _ := strconv.ParseUint(&quot;123&quot;, 10, 8) 浮点类型 func ParseFloat(s string, bitSize int) (f float64, err error) 作用： 解析一个表示浮点数的字符串并返回其值。 参数： s：如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数 bitSize：指定结果类型，32表示float32（返回值可以不改变精确值的赋值给float32），非32表示float64 1a, _ := strconv.ParseFloat(&quot;3.14&quot;, 32) 其他类型 -&gt; string布尔类型 func FormatBool(b bool) string 作用： 根据b的值返回”true”或”false”。 1strconv.FormatBool(true) 整数类型有符号整型： func FormatInt(i int64, base int) string 作用： 返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。 参数： base：进制 1strconv.FormatInt(123, 2) func Itoa(i int) string 作用： Itoa是FormatInt(i, 10) 的简写。 1strconv.Itoa(123) 无符号整型： func FormatUint(i uint64, base int) string 作用： 是FormatInt的无符号整数版本。 1strconv.FormatUint(123, 2) 浮点类型 func FormatFloat(f float64, fmt byte, prec int, bitSize int) string 作用： 函数将浮点数表示为字符串并返回。 参数： fmt ：表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。 prec：控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。 bitSize：f的来源类型（32：float364：float64），会据此进行舍入。 1strconv.FormatFloat(300.1415926, 'e', 3, 64) //3.0e+02 数组/切片转字符串123456str := &quot;hello world&quot;array_or_slice := []byte(str)//fmt.Sprint(array_or_slice)：byte数组转换成字符串//strings.Trim(&quot;字符串&quot;,&quot;字符&quot;)：除去两边字符//strings.Replace(&quot;字符串&quot;,&quot;原字符&quot;,&quot;新字符&quot;,&quot;替换字符数&quot;)：替换字符串内字符strings.Replace(strings.Trim(fmt.Sprint(array_or_slice), &quot;[]&quot;), &quot; &quot;, &quot;,&quot;, -1) 默认值 整数类型：0 浮点类型：0 布尔类型：false 字符串：””","link":"/2023/03/07/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"模块系统","text":"包 包Go的程序是保存在多个.go文件中，文件的第一行就是package XXX声明，用来说明该文件属于哪个包(package)，package声明下来就是import声明，再下来是类型，变量，常量，函数的声明。 包的初始化（Init 函数）go语言中init函数用于包(package)的初始化，有以下特征： init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等； go文件可以拥有多个init函数，执行顺序从上到下； 每个包可以拥有多个init函数。按文件名字符串从小到大顺序调用各文件中的init()函数； 对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。 如果init函数中使用了println()或者print()执行顺序不确定； 同一个包中多个init函数的执行顺序go语言没有明确的定义； 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序； init函数不能被其他函数调用，而是在main函数执行之前，自动被调用； 包导入在Golang里，import的作用是导入其他package 12// 使用下划线，只是引用该包，仅执行导入包init()函数，无法通过包名来调用包中的其他函数import _ 包路径","link":"/2023/03/08/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"},{"title":"控制流","text":"选择语句、循环语句、跳转语句、延迟调用语句 选择语句if 语句基本语法1234567891011121314151617181920if [初始化语句;]表达式{ //条件表达式1为True时执行}else if [初始化语句;]表达式{ //条件表达式2为True时执行}else{ //否则执行}//例子s := 1if a := 3; s == 1 { println(a, &quot;1&quot;)} else if a = 2; s == 2 { println(a, &quot;2&quot;)} else { println(a, &quot;3&quot;)} 补充： else if 和 else 都是可选的 if 语句可以嵌套 不支持三元操作符 switch 语句基本语法：12345678910111213141516171819202122232425//switch后接表达式switch 表达式 {case 表达式1,表达式2,……: //表达式1或表达式2或...匹配 代码块case 表达式: //表达式匹配 代码块...//多个case语句default: //上面表达式都不匹配 代码块}//switch后不接表达式switch {case 表达式: //表达式结果为布尔类型 代码块case 表达式: 代码块default: 代码块} switch 穿透表达式后加 fallthrough 关键字会继续执行下一个 1234567891011//输出结果为 2 3switch {case false: println(&quot;1&quot;)case true: //执行完这部分后还会继续向下匹配 println(&quot;2&quot;) fallthroughdefault: println(&quot;3&quot;)} Type-Switch用来判断某个 interface 变量中实际存储的变量类型 12345678910//x必须是一个接口类型的变量switch x.(type){ //所有的case语句后面跟的类型必须实现了x的接口类型 case Type1: doSomeThingWithType1() case Type2: doSomeThingWithType2() default: doSomeDefaultThing()} 举例如下： 12345678910111213141516171819202122232425262728293031type Animal interface { shout() string}type Dog struct {}func (self Dog) shout() string { return fmt.Sprintf(&quot;汪汪&quot;)}type Cat struct {}func (self Cat) shout() string { return fmt.Sprintf(&quot;喵喵&quot;)}func main() { var animal Animal = Dog{} switch [a :=] animal.(type) { // a := 是可选的，如果想声明变量的话 case nil: //如果接口未赋值，会匹配到nil fmt.Println(&quot;animal'type is nil&quot;) } case Dog: //case后可加多个类型，以逗号分隔 fmt.Println(&quot;animal'type is Dog&quot;) case Cat: fmt.Println(&quot;animal'type is Cat&quot;) } default: // 表示a的类型是 Animal fmt.Println(&quot;default&quot;, reflect.TypeOf(a), a)} 补充： switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case 表达式或表达式结果可以是：常量、变量、有返回值的函数 default 可以省略 case 后为字面量（例如：’a’、2）时，switch 后的类型可以与case 后的不同 123456var a float64 = 97.0switch a {case 'a': //会被执行 println(&quot;a&quot;)} select 语句select 语句类似于一个用于通信的 switch 语句，每个case必须是一个通信操作（发送/接收）。select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的 基本语法123456789select { case communication clause : statement(s); case communication clause : statement(s); //... default : /* 可选 */ statement(s);} todo 循环语句for 语句go语言中没有 while 和 do…while 语句 基本语法1234567891011121314151617181920212223242526272829303132333435363738//方式1：常见for循环//循环变量初始化：此处用来对循环变量赋值，不能定义变量（var），只能使用i := 0形式//循环条件：为true则继续循环，此处结果必须是布尔值//for后面这三个部分都可以省略for 循环变量初始化; 循环条件; 循环遍历迭代 { 循环代码}//举例for i:=0;i&lt;5;i++{ println(i)}//方式2：替代while(条件){}for 循环条件 { 循环代码}//举例i := 0for i &lt; 5 { println(i) i++}//方式3：代替while(true){}for { 循环代码 ////此时需要配合break语句 break}//举例i := 0for { println(i) i++ if i &gt;= 5 { break }} for-rangefor-range类似迭代器操作，其中返回值都是从复制品取出，可以理解为先拷贝一个副本，之后遍历的是副本。值类型是值拷贝，引用类型拷贝地址，所以比较适合遍历引用类型，底层数据不会赋值，开销更小 12345678910111213141516for key, value := range map { newMap[key] = value}for index, value := range list { println(index, value)}//使用下划线(_)忽略不需要的返回值for key, _ := range map { newMap[key] = value}//如果返回值都不需要for range oldMap { } 使用range返回的值如下 string：index，str[index]（unicode编码） array/slice：index，arr[index] map：key，value channel：element 使用基本的for循环在遍历字符串时，中文会发生乱码，因为是按字节遍历的，可以使用 for-range 解决这个问题，他会按字符编码方式进行遍历 1234str := &quot;中文字符转&quot;for index, value := range str { println(index, value)} 跳转语句 break：break 用于终止某个语句块的执行，可以用来中断当前 for 和 switch 语句，并且只能在这两个语句中使用； continue：continue 关键字表示结束本次循环，继续执行下一次循环，只能在循环语句中使用； goto：goto 关键字用来无条件跳转到程序的指定位置执行； 1234567//跳转到mark位置goto mark//1不会执行println(&quot;1&quot;)//标记该位置mark:println(&quot;2&quot;) 三个语句都可以配合标签(label)使用，continue、break配合标签(label)可用于多层循环跳出，goto是调整执行位置，与continue、break配合标签(label)的结果并不相同 1tode 延迟调用语句基本用法defer关键字用于修饰语句注册延迟调用的，被其修饰的语句直到函数的return语句执行前才会被执行，并且执行的顺序是先进后出的栈结构。通常用来执行关闭资源等操作 1234567func main() { var whatever [5]struct{} for i := range whatever { defer fmt.Println(i) }} 上面代码中被defer修饰的fmt.Println(i)在main函数返回前执行并且输出顺序为4 3 2 1 0； defer 碰上闭包123456func main() { var whatever [5]struct{} for i := range whatever { defer func() { fmt.Println(i) }() }} 上面结果为 4 4 4 4 4，这是因为执行匿名函数引用了外部的变量i，在main函数返回前i被赋值为4所以输出的都是4","link":"/2023/02/05/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"类型系统","text":"选择语句、循环语句、跳转语句、延迟调用语句 变量 变量的定义包括：变量名，变量值，变量类型，如果不赋值则使用默认值，如果没有声明类型会自动进行类型推导 标识符命名规则： 首字符可以是任意的Unicode字符或者下划线； 剩余字符可以是Unicode字符、下划线、数字； 不能是关键字； 字符长度不限； 下划线（_）：空标识符，仅作为占位符使用，意思是忽略这个变量.； 可见性： 声明在函数内部，是函数的本地值，类似private 声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect 声明在函数外部且首字母大写是所有包可见的全局值,类似public 声明后不赋值，使用默认值123456789101112//方式1//标准格式var 变量名 变量类型 = 表达式//方式2//声明var 变量名 变量类型//赋值变量名 = 表达式//例子var a int = 1 声明并赋值自动推导类型123var 变量名 = 变量值//例子var a = 1 短变量声明（省略var）123变量名 := 变量值//例子a := 1 补充： 变量名应该是没有声明过的，否则编译不通过 :=不能使用在函数外； 声明多变量12345678910111213141516171819202122232425262728//方式1，若不赋值则为默认值var 变量名1,变量名2,变量名3 变量类型 = 变量值1,变量值2,变量值3//例子var a,b,c int = 1,2,3//方式2var 变量名1,变量名2,变量名3 = 变量值1,变量值2,变量值3//例子var a,b,c = 1,2,3//方式3变量名1,变量名2,变量名3 := 变量值1,变量值2,变量值3//例子a,b,c := 1,2,3//匿名变量x, _ := foo()func foo() (int, string) { return 10, &quot;dog&quot;}//批量声明var ( a string = &quot;a&quot; b int c bool d float32) 补充： 同一作用域内不支持重复声明； 并且Go语言的变量声明后必须使用； 常量常量定义常量的声明和变量声明非常类似，只是把var换成了const并且必须要有const关键字，常量在定义的时候必须赋值； 123456789101112131415161718//常量定义const pi = 3.1415//多个常量也可以一起声明const ( pi = 3.1415 e = 2.7182)const pi,e int = 1, 2const a, _ int = 1, 2//如果省略了值则表示和上面一行的值相同const ( n1 = 100 n2 n3 = 200 n4) iotaiota是go语言的常量计数器，只能在常量的表达式中使用。iota在const关键字出现时将被重置为0，const中每新增一行常量声明将使iota计数一次 1234567891011121314151617181920212223242526272829const ( n1 = iota //0 n2 //1 n3 //2 n4 //3)//使用_跳过某些值const ( n1 = iota //0 n2 //1 _ n4 //3)//iota声明中间插队const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3)const n5 = iota //0//多个iota定义在一行const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4) 值类型和引用类型 值类型：整型、浮点型、布尔型、字符串、数组、结构体 值类型变量直接存储值，在栈中分配； 引用类型：指针、切片、映射、管道、接口 引用类型必须申请内存才可以使用，make()是给引用类型申请内存空间； 变量存储的是一个地址，在堆区分配，当该地址没有被引用时会被GC回收； 值类型变量赋值是值拷贝，拷贝后原变量和新变量不会有影响 123456789101112func main() { //声明数组arr1，数组值值类型 arr1 := [3]int{1, 2, 3} //将arr1赋值给arr2 arr2 := arr1 //修改arr1元素 arr1[0] = 0 //打印数组方法 //最终打印结果不同说明是值拷贝 printArr(arr1) //0 2 3 printArr(arr2) //1 2 3} 引用类型变量赋值是地址拷贝，赋值后原遍历和新变量指向的是同一个位置 123456789101112func main() { //声明切片arr1，切片是引用类型 slice1 := [3]int{1, 2, 3} //将slice1赋值给slice2 slice2 := slice1 //修改原变量元素 slice[0] = 0 //打印切片方法 //最终打印结果相同说明是地址拷贝 printArr(slice1) //0 2 3 printArr(slice2) //0 2 3} 自定义类型和类型别名使用type关键字来定义自定义类型和类型别名 自定义类型可以基于内置的基本类型定义，也可以通过struct定义 1type 名称 类型 举例如下： 1234567type NewInt int//通过结构体定义type Animal struct { name string age int} 类型别名1type 名称 = 类型 举例如下： 12345type TypeAlias = Type//rune和byte的定义type byte = uint8type rune = int32 类型别名和自定义类型区别 自定义类型可以为类型添加方法，类型别名不行 类型别名编译时会被转成对应类型，可以与相同类型变量进行计算，自定义类型不行","link":"/2023/02/04/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"运算符","text":"算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、运算符优先级 算术运算符 运算符 说明 + 正号/字符串拼接/加号 - 负号/减号 * 乘 / 除 % 取模 ++ 自增 – 自减 关系运算符 运算符 说明 == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 逻辑运算符 运算符 说明 &amp;&amp; 与 || 或 ! 非 位运算符 运算符 说明 &amp; 按位与 | 按位或 ^ 按位异或（不同为1） &lt;&lt; 左移（乘2） &gt;&gt; 右移（除2） 赋值运算符 运算符 说明 = 赋值 += 相加赋值 -= 相减赋值 *= 相乘赋值 /= 相除赋值 %= 取模赋值 &lt;&lt;= 左移赋值 &gt;&gt;= 右移赋值 &amp;= 按位与赋值 |= 按位或赋值 ^= 按位异或赋值 其他 运算符 说明 &amp; 取址 * 取值 运算符优先级运算符优先级从高到低如下： 描述 结合性 ()、[]、-&gt; 左到右 +(正号)、-(负号)、!、*(取值)、&amp;(取址)、++、– 右到左 *(乘)、/、% 左到右 +(加)、-(减) 左到右 &gt;&gt;、&lt;&lt; 左到右 &lt;、&lt;=、&gt;=、&gt; 左到右 ==、!= 左到右 &amp;(与) 左到右 ^ 左到右 | 左到右 &amp;&amp; 左到右 || 左到右 =、+=、-=、*=、/=、%=、&gt;&gt;=、&lt;&lt;=、&amp;=、^=、|= 右到左 , 左到右","link":"/2023/03/03/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"面向对象","text":"结构体、接口 golang 中无论是字段、结构体还是变量，开头大写为 公开，小写为 私有 结构体Go中没有Class，但可以通过结构体的内嵌再配合接口，比面向对象具有更高的扩展性和灵活性。结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问） 结构体定义结构体声明123456type 类型名 struct { 字段名 字段类型 //同一类型可以写在一行 字段名,字段名 字段类型 …} 举例如下： 1234567891011//例子type Person struct { name string color string age int}//同一类型可以写在一行type Person struct { name,color string age int} 结构体实例化Go语言中有对指针类型变量求值的语法糖，使用结构体指针可以直接获取字段和方法，底层会自动进行取值（*）操作 123456789101112131415func main() { //实例化方式1：依次赋值 var a1 Animal //go支持对结构体指针的直接使用，可以通过.来访问 a1.name = &quot;迪莫&quot; a1.age = 3 //初始化方式2：使用new关键字 //返回的是结构体的地址 var a1 = new(Animal) //初始化方式3：使用&amp;对结构体进行取地址操作 //相当于对该结构体类型进行了一次new实例化操作 a2 := &amp;Animal{}} 结构体初始化1234567891011121314151617func main() { //&amp;是可选项，写了代表返回结构体的指针 a1 := [&amp;]Animal{ //未列出的字段会赋默认值 //字段名如果不写需要按结构体定义顺序列出所有字段的赋值 [字段名:] 字段值, ... } //&amp;是可选项 a := [&amp;]Animal{ name: &quot;迪莫&quot;, age: 3, } a.name=&quot;迪莫&quot; a.age=3} 匿名结构体基本语法123456789101112var 变量名 struct { //如果在字符按同一行需要加; 字段名 字段类型[;] ...}//举例func main() { var a struct {name string;age int} a.name = &quot;迪莫&quot; a.age = 3} 构造函数Go语言的结构体没有构造函数，但可以自己实现。因为struct是值类型，拷贝开销可能比较大，所以下面函数返回的是指针 123456func newAnimal(name string, age int) *Animal { return &amp;Animal{ name: name, age: age, }} 方法Go中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver） 方法定义123func (接收者 接收者类型) 方法名(参数列表) (返回参数) { 函数体} 举例如下： 123func (a Animal) cry() { println(&quot;我喜欢唱跳rap篮球&quot;)} 方法和函数区别就是：方法是属于特定的类型，二函数不属于任何类型 接收者接收者就像java中的this，可以分为T 或 *T： 指针类型的接收者 值类型的接收者 123456789//值类型接收者func (a Animal) cry() { a.name = &quot;皮卡丘&quot;}//指针类型接收者func (a *Animal) cry() { a.name = &quot;皮卡丘&quot;} 因为值类型是值拷贝，所以通过值类型接收者修改数据不会作用到原结构体变量上，但如果是指针类型的接收者，传递的是指针，通过它可以更改原结构体变量的数据。所以对于以下情况，需要使用指针类型的接收者： 需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者 如果没有使用接收者，那么可省略接收者参数名 1func (Animal) cry() {} 向任意类型添加方法接收者可以是任意类型的，所以可以向任意类型添加方法 123456func (a MyInt) test() { println(a)}//调用var i MyInt = 1i.test() 方法调用方式根据调用者不同，方法的调用有两种方式 instance.method(args...)； &lt;type&gt;.func(instance, args...)； 这两种方式区别是如果使用实例调用会自动绑定receiver，而通过类型调用需要显式传递receiver 123456789101112131415161718192021222324252627282930type Animal struct {}//值传递func (a Animal) test() { fmt.Printf(&quot;%s&quot;, a)}//地址传递func (a *Animal) testP() { fmt.Printf(&quot;%s&quot;, a)}func main() { a := Animal{} f1 := a.test f1() //隐式传递 f2 := Animal.test //参数为T类型 f2(a) //显示传递receiver f3 := (*Animal).test //参数为*T类型 f3(&amp;a) //显示传递receiver fp1 := a.testP fp1() fp3 := (*Animal).testP fp3(&amp;a)} 方法集如果使用类型T的实例来调用方法则对应*T和T的接收者都能调。但使用类型来调用方法需要遵循以下规则： 类型 T 方法集包含全部 receiver T 方法 类型 *T 方法集包含全部 receiver T + *T 方法。 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。 验证代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type T struct {}type SPT struct { *T}type S struct { T}//receiver T 方法func (receiver T) tf() { fmt.Printf(&quot;%s \\n&quot;, receiver)}//receiver *T 方法func (receiver *T) tfp() { fmt.Printf(&quot;%s \\n&quot;, receiver)}func main() { t := T{} //T 调用 receiver T T.tf(t) //T 调用 receiver *T T.tfp(t) //报错：invalid method expression //*T 调用 receiver T (*T).tf(&amp;t) //*T 调用 receiver *T (*T).tfp(&amp;t) s := S{t} //S{T} 调用 receiver T S.tf(s) //S{T} 调用 receiver *T S.tfp(s) //报错 //*S{T} 调用 receiver T (*S).tf(&amp;s) //*S{T} 调用 receiver *T (*S).tfp(&amp;s) spt := SPT{&amp;t} //S{*T} 调用 receiver T SPT.tf(spt) //S{*T} 调用 receiver *T SPT.tfp(spt) //*S{*T} 调用 receiver T (*SPT).tf(&amp;spt) //*S{*T} 调用 receiver *T (*SPT).tfp(&amp;spt)} 本质上来说是GO对于结构体指针进行操作会自动进行取值操作，所以&amp;T可以传递到receiver T的方法中，但T不能传递到receiver *T中 匿名字段匿名字段就是在定义时只提供字段类型，而不提供字段名 12345678910111213type Name = stringtype Age inttype Animal struct { //内置类型 string //自定义类型 Name //指针类型匿名字段 *Age //其他字段} 补充： 匿名字段类型可以是所有的内置类型和自定义类型 同一个类型的匿名字段结构体中不能重复定义 嵌套结构体一个结构体中可以嵌套包含另一个结构体或结构体指针 12345678910111213141516171819202122//动物结构体type Animal struct { name string age int color Color}//颜色结构体type Color struct { color string}func main() { //初始化 a := Animal{ name:&quot;迪莫&quot;, age:3, color:Color{color:&quot;blue&quot;}, } //调用内部结构体字段需要多个. println(a.color.color)} 结构体继承通过嵌套匿名结构体实现继承 12345678910111213141516171819202122232425func main() { d := Dog{ age: 3, Animal: &amp;Animal{name: &quot;张三&quot;}, }}//Animal 动物type Animal struct { name string}func (a *Animal) cry() { fmt.Printf(&quot;未知动物&quot;)}//Dog 狗type Dog struct { age int *Animal //通过嵌套匿名结构体实现继承}func (d *Dog) wang() { fmt.Printf(&quot;汪汪&quot;)} 结构体标签可以通过反引号(`)为结构体的字段定义标签。可以使用这个特性进行数据绑定和校验格式如下 123type tag struct { name string `key1:&quot;value1&quot;,key2:&quot;value2&quot;`} JSON与结构体相互转换结构体–&gt;JSON格式的字符串12//data：达到的json字符串data,err := json.Marshal(结构体指针) JSON格式的字符串–&gt;结构体123//c：结构体指针变量//str：json字符串json.Unmarshal([]byte(str),c) 接口接口是一种抽象类型，只定义方法声明没有实现，没有数据字段 1234567891011所谓对应方法，。当然，该类型还可以有其他方法。接口可以匿名嵌入其他接口，或嵌入到结构中。对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。只有当接口存储的类型和对象都为nil时，接口才等于nil。接口调用不会做receiver的自动转换。接口同样支持匿名字段方法。接口也可实现类似OOP中的多态。空接口可以作为任何类型数据的容器。一个类型可实现多个接口。 接口定义1234567//接口命名习惯以 er 结尾type 接口名 interface{ //当方法名首字母是大写且这个接口名首字母也是大写时，这个方法可以被接口所在的包之外的代码访问。 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 …} 举例如下： 123type Animal interface { cry()} 实现接口实现接口方法任何类型的方法集中只要实现了接口中的全部方法（方法名称、参数列表 (不包括参数名) 以及返回值都要相同），那么就算是实现了这个接口，无需显示的使用关键字声明是实现了哪个接口 1234567891011121314151617type Animal interface { cry()}type Dog struct {}func (c Dog) cry() { println(&quot;汪汪&quot;)}type Cat struct {}func (c Cat) cry() { println(&quot;喵喵&quot;)} 上面代码中Dog和Cat实现了cry()方法，所以他们都实现了Animal接口，使用Animal的变量可以引用任何实现了这个接口的实例，也可以引用实现类型的指针 1234567891011func main() { var a Animal //接收实现类型 a = Cat{} a.cry() a = Dog{} a.cry() //接收实现类型的指针 a = &amp;Cat{} a.cry()} 和结构体的方法集规则一样，*T可以传递给receiver T，但T不能传递给receiver *T 12345678910111213type Animal interface { cry()}func (c *Cat) cry() { println(&quot;喵喵&quot;)}func main() { var a Animal a = Cat{} //报错 a = &amp;Cat{}} 嵌入类型不一定需要一个类型完全实现接口的全部方法，可以通过嵌入其他类型的方式来实现接口，下面的例子中Cat实现了cry()方法，并且内嵌了一个Leg类型，Leg实现了run()方法，所以Cat的方法集就包含了cry()和run()，也就实现了Animal接口 123456789101112131415161718192021222324type Animal interface { cry() run()}type Leg struct {}func (l Leg) run() { println(&quot;跑起来，哒哒哒&quot;)}type Cat struct { Leg}func (c Cat) cry() { println(&quot;喵喵&quot;)}func main() { var a Animal a = Cat{}} 嵌套类型接口还可以嵌套接口，下面例子Animal接口内嵌了Mouth和Leg接口，相当于声明了这两个接口定义的方法 1234567891011121314151617181920212223242526272829303132func main() { var a Animal = Cat{} a.run() a.cry()}// Animal 动物接口type Animal interface { Mouth Leg}// Mouth 嘴type Mouth interface { cry()}// Leg 腿type Leg interface { run()}type Cat struct {}func (c Cat) cry() { println(&quot;喵喵&quot;)}func (c Cat) run() { println(&quot;跑起来，哒哒哒&quot;)} 空接口空接口定义空接口是指没有定义任何方法的接口，可以存储任意类型的变量 1234567891011/定义空接口类型type x interface{}func main() { //空接口类型变量 var x x = 2 println(x) //匿名空接口 var y interface{} y = 2 println(y)} 空接口应用用来作为可以接收任何类型的函数参数 123func test(a interface{}) { } 声明保存任何类型值的字典 12//该map的值可为任意类型var testMap = make(map[string]interface{}) 类型断言类型断言语法格式如下 123//x：空接口（interface{}）的变量//T：可能是的类型x.(T) 类型断言返回值有两个 x转化为T类型后的变量 布尔值，若为true代表断言成功，反之失败 举例如下： 123456789func main() { var x interface{} x = &quot;aaa&quot; v, ok := x.(string) println(v, ok) //结果：aaa true v1, ok1 := x.(int) println(v1, ok1) //结果：0 false} 只有在swith语句中可以使用 1x.(type) 这样写只会返回第一个值：x转化为T类型后的变量","link":"/2023/03/04/%E6%8A%80%E6%9C%AF%E6%A0%88/Go/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"函数","text":"整数类型、浮点类型、布尔类型、字符类型、字符串、数组 函数定义定义方式123fun 方法名(参数: 类型, 参数: 类型, ...): 返回值类型 { return 返回值;} 当函数返回单个表达式时，可以省略大括号并在=符号后指定主体 123fun double(x: Int): Int = x * 2//编译器可以推断出返回类型时，可以不声明返回值类型fun double(x: Int) = x * 2 函数必须指定返回值类型，如果不指定默认为Unit，也就是没有返回值，Unit是一种只有一个值的类型，此值不必显式返回 123return Unit//等价于return 定义位置 文件顶层：可以声明在文件顶层，不一定在类中，和java不同 局部函数：声明在其他函数的内部，局部函数可以访问外部函数的局部变量 成员变量：定义在在类或对象的内部 参数列表参数默认值1234//格式：参数: 类型 = 默认值fun 方法名(a: ByteArray, b: Int = 1, c: String = &quot;cc&quot;): 返回值类型 { return 返回值;} 重写方法时需要省略默认值，子类会继承父类的默认值 12345678910111213open class A { open fun foo(i: Int = 10) {}}class B : A() { override fun foo(i: Int) { println(i) }}fun main(){ B().foo() //10} 命名参数当调用一个函数时，可以命名他的一个或多个参数，这样就可以自由更改他们的列出顺序，也可以跳过某个有默认值的参数。kotlin允许一个有默认值的参数，其右边的参数没有默认值，但这样就必须使用命名参数，如下所示 12345678fun foo( a: Int = 0, b: Int) { println(&quot;&quot; + a + &quot;:&quot; + b)}fun main(){ foo(b = 5) //0:5} 如果默认参数最后一个是lambda，可以将其作为命名参数在括号外传递 123456789101112fun foo( a: Int = 0, b: Int = 1, l: () -&gt; Unit) { l() }fun main(){ //调用方式 foo { println(&quot;hello&quot;) } foo(l = { println(&quot;hello&quot;) } ) foo(1){ println(&quot;hello&quot;) }} 可变形参可以使用vararg修饰符标记函数的参数（只能指定一个参数，一般是最后一个，否则需要使用命名参数），这样就可以将可变数量的参数传递给函数，参数是一个Array类型 12345678910111213fun &lt;T&gt; test(vararg arr: T){ println(arr.size)}fun main(){ test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) //如果传递的是一个数组，需要在数组钱加 *，否则会将整个数组看成是一个元素 val list = arrayOf(1, 2, 3) test(*list) //基本类型数组需要调用toTypedArray()方法 val list = intArrayOf(1, 2, 3) test(*list.toTypedArray())} 可选参数传递可选参数有两种方式： 使用vararg关键字修饰参数名（推荐） 使用数组类型接收实参 12345fun test(vararg args:String){}test(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)//等效于fun test(args:Array&lt;String&gt;){}test(arrayOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) 补充： 不能使用命名参数的格式传递可变参数 中缀函数用infix关键字标记的函数可以使用中缀符号调用，该函数应该满足如下要求： 必须是成员函数或扩展函数 必须有一个参数 参数没有可变形参和默认值 12345678910111213141516171819202122class InfixTest{ var str:String = &quot;&quot; //方法前加 infix 关键字 infix fun add(s:String){ str+=s } fun f1(s: String){ //其他函数调用中缀函数使用 this add xxx 方式 this add s }}fun main(){ val infixTest = InfixTest() //使用方式 infixTest add &quot;a&quot; infixTest.f1(&quot;b&quot;) println(infixTest.str) //ab} 中缀函数优先级低于算符运算符、类型转换和rangeTo运算符； 中缀函数优先级高于布尔运算符&amp;&amp;和||、is- 和 -in检查以及其他一些运算符的优先级； 尾递归函数对于使用递归算法的函数可以用tailrec关键字修饰，称为尾递归函数，不会有栈溢风险，会一直递归下去 1234567fun main(){ println(testTailRec(2))}//返回2的i次方//函数必须将自身作为执行的最后一个操作调用tailrec fun testTailRec(i:Int,x:Int=1):Int = if (i&gt;0) testTailRec(i-1,x*2) else x 高阶函数高阶函数是将函数作为参数或返回值的函数","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/"},{"title":"异常处理","text":"声抛出异常、捕获异常、异常检测 在kotlin中所有的异常类都继承于Throwable类，每个异常类都包括了信息、调用栈和选择原因 抛出异常抛出异常使用throw 1throw Exception(&quot;Hi There!&quot;) throw是一个表达式，它返回的类型是 Nothing。此类型没有值，主要用于标记永远无法到达的代码位置。可以使用Nothing 标记一个没有返回值的函数： 123fun fail(message: String): Nothing { throw IllegalArgumentException(message)} 当调用这个函数时，编译器会知道在调用之后不再继续执行 123456try { fail(&quot;try&quot;) println(&quot;aa&quot;) //这一句不会执行}catch (e: Exception){ println(&quot;catch&quot;)} 异常捕获基本语法1234567try { // some code} catch (e: SomeException) { // handler} finally { // optional finally block} 可能有零个或多个 catch 块，并且 finally 块也可以省略，但最后必须要有一个catch或finally try 表达式try 是一个表达式，这说明他会返回一个值，这个值时 try 或 catch 中最后一个表达式。finally 不影响表达式的结果 1val a: Int? = try { input.toInt() } catch (e: NumberFormatException) { null } 异常检测java 中抛出异常需要在方法上使用throws关键字进行声明，如果不这样做就必须要用 try-catch 进行处理，这会导致代码中到处都是try-catch 的代码，生产力低下，代码质量也没有提高，所以 kotlin 中不包含异常检查。如果想在其它语言中调用 kotlin 代码可以使用 @Throws 注解提醒调用者可能发生的异常。","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"数据类型","text":"整数类型、浮点类型、布尔类型、字符类型、字符串、数组 整数类型 类型 大小（位） 最小值 最大值 Byte 8 -128 127 Short 16 -32768 32767 Int 32 -2,147,483,648 (-2^31^ ) 2,147,483,647 (2^31^-1) Long 64 -9,223,372,036,854,775,808 (-2^63^) 9,223,372,036,854,775,807 (2^63^ - 1) UByte 8 0 255 UShort 16 0 65535 UInt 32 0 2^32^-1 ULong 64 0 2^64-^1 jvm中数字使用int,double进行存储，如果使用的是数字引用，则保存为Integer、Double 示例： 123456fun main(){ var b : Byte = 1 var s : Short = 1 var i : Int = 1 var l : Long = 1L} 字面量格式 说明 格式 二进制 0b0000_1011 八进制 不支持 十进制 1000_0000_0000 十六进制 0x开头（0x0F） 字节 (仅限于 u8) b'A' 指定类型 100_i8 数字间可以使用_分割，增强可读性 无符号字面量后缀u、U、uL来标记无符号类型： 123456789//有期望类型时，根据期望确定类型val b: UByte = 1u // UByteval s: UShort = 1u // UShortval l: ULong = 1u // ULong//无期望类型val a1 = 42u // UInt（默认）val a2 = 0xFFFF_FFFF_FFFFu // ULong（超出UInt范围时）val a = 1UL // ULong 整数字面量 使用数字字面量进行类型推断时，默认为Int类型，如果超出Int最大值，则为Long类型 1234fun main(){ var v = 1 //Int val threeBillion = 3000000000 // Long} Long类型的字面量需要在字面量后加L（100L） 浮点类型 类型 大小（位） 有效位 指数位 精确小数位数 Float 32 24 8 6-7 Double 64 53 11 15-16 浮点类型字面量默认是Double类型，要显式声明Float字面量可以加f和F后缀 12var f : Float = 3.14fvar d : Double = 3.141592653 浮点类型底层通过科学计数法形式存储，分为三部分： 符号位：始终是1位，1代表负号，0代表正号； 有效位：科学计数法的底数部分，决定了精确度； 指数位：指数部分，决定了数据最大范围； 浮点数字面量有如下写法： 默认是Double：3.14，123.5e10 声明Float类型：3.14f ，3.14fF 使用下划线：3_14.15_92653 布尔类型 类型 取值 Boolean true / false 1var b: Int = true 字符类型 类型 占用空间 编码 Char 2byte Unicode 示例： 1val aChar: Char = 'a' 字符串Kotlin 中的字符串由String类型表示 123val str = &quot;abcd&quot;//字符串是不可变类型，改变字符串的操作会生成一个新的字符串str = &quot;123&quot; 索引访问123for (c in str) { println(c)} 拼接12345//使用 + 进行连接var str = &quot;a&quot; + &quot;b&quot;//也可以和其他类型连接（推荐使用字符串模板或原始字符串）//最前面必须有字符串str = &quot;ss&quot; + 123 原始字符串原始字符串由三重引号 (&quot;&quot;&quot;)分隔，不包含转义，并且可以包含换行符和任何其他字符： 1234val text = &quot;&quot;&quot; for (c in &quot;foo&quot;) print(c)&quot;&quot;&quot; 原始字符串不会解析转义字符，如果需要解析可以使用模板表达式 1234val price = &quot;&quot;&quot;\\n_9.99&quot;&quot;&quot;println(price) // \\n_9.99 模板字符串字符串文字可能包含模板表达式 ，模板表达式以美元符号 ($)开头 12val i = 10println(&quot;i = $i&quot;) // prints &quot;i = 10&quot; 在花括号中声明表达式 12val s = &quot;abc&quot;println(&quot;$s.length is ${s.length}&quot;) // prints &quot;abc.length is 3&quot; 在原始字符串中使用模板表达式和转义字符 123456789//使用$符val price = &quot;&quot;&quot;${'$'}_9.99&quot;&quot;&quot;//使用转义字符price = &quot;&quot;&quot;${'\\n'}_9.99&quot;&quot;&quot; 数组Kotlin 中的数组由Array类表示 数组是不可变类型 不允许将不同泛型的数组相互赋值 创建 使用arrayOf()函数创建数组 12// 将数组的值传入方法中var arr:Array&lt;String&gt; = arrayOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) 使用Array构造器 123//指定数组sizeval arr = Array(5) { i -&gt; (i * i).toString() }arr.forEach { println(it) } 使用arrayOfNulls()创建一个由null元素填充的给定大小的数组 1val arr = arrayOfNulls&lt;String&gt;(3) 读写数组 通过get和set方法访问数组 12arr.set(0,&quot;a&quot;) //设置索引为0的位置值为&quot;a&quot;println(arr.get(0)) //获取索引为0位置的值 通过 [] 访问 12arr[0] = &quot;a&quot;println(arr[0]) 原始类型数组 使用原始类型数组没有装箱的开销，原始类型数组与Array没有继承关系，但它们具有相同的方法和属性集； 原始类型数组的类型名格式为：xxxArray，其中xxx为原始类型； 每个原始类型数组都有其对应的工厂函数，格式为：xxxArrayOf(); 12345678910111213//intArrayOf()方法val x: IntArrayintArrayOf()方法 = intArrayOf(1, 2, 3)// 创建size为5的数组，值为：[0, 0, 0, 0, 0]val arr = IntArray(5)// 创建时设置默认值// 创建size为5的数组，值为：[42, 42, 42, 42, 42]val arr = IntArray(5) { 42 }// 创建时使用lambda表达式初始化// 创建size为5的数组，值为：[0, 1, 2, 3, 4] (根据索引对值进行初始化)var arr = IntArray(5) { it * 1 } 无符号数组（Beta）每个无符号类型都有一个对应的类型来表示该类型的数组： UByteArray: 一个无符号字节数组 UShortArray: 一组无符号短裤 UIntArray: 一个无符号整数数组 ULongArray: 一个无符号长整型数组 有符号整数数组一样，它们提供了一个类似于Array类的 API，没有装箱开销。 类型转换显式转换kotlin中使用as进行类型转换 非空类型转换 12//类型转换失败会报错val x: String = y as String 可空类型转换 12//转换失败会返回nullval x: String? = y as? String 数字类型转换Kotlin对数字不支持隐式类型转换，想要将数值转换为不同类型需要使用显式转换 所有数字类型都支持转换为其他类型： toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char 变量和字面量都可以调用上面的方法 1234//字面量3.14.toFloat()//变量d.toFloat() 较大的数值类型转化为较小的数值类型是可能出现数据溢出和精度损失的情况 1234567//精度损失var f : Float = 3.141592653.toFloat()println(f) //3.1415927//数据溢出，舍弃高位var s : Short = 123456.toShort()println(s) //-7616","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"模块系统","text":"声明包、导入包 声明包一个kotlin文件如果未指定包，则默认属于没有名称的默认包。如果想要指定，可以在文件开头使用package关键字声明所属包 1234package org.examplefun printMessage() { /*...*/ }class Message { /*...*/ } 这样文件中的所有内容，如类和函数等就都被包含在这个包中。在上面的例子中，printMessage()全名是org.example.printMessage，Message类的全名是org.example.Message。 导入包除了默认导入的包外，还可以通过 import 语句主动导入 导入方法导入单个名称 1import org.example.Message 导入所有可访问内容 1import org.example.* 如果存在冲突，使用 as 重命名包 12import org.example.Messageimport org.test.Message as testMessage 导入的内容可以导入的内容包括： 顶级函数和属性 枚举常量 对象声明中声明的函数和属性 上面的内容如果被 private 修饰则表示是文件私有的，无法导入。 默认导入默认情况下，kotlin文件会被自动导入如下包： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 根据目标平台导入的包： JVM： java.lang.* kotlin.jvm.* JS： kotlin.js.*","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"},{"title":"流程控制","text":"条件语句、循环语句、跳转语句 条件语句if 语句基本语法1234567if(条件表达式){ }else if (条件表达式){ }else{ } if 作为表达式if 表达式会返回一个值，所以kotlin 没有三元运算符，使用if 语句就可以达到三元运算符的效果 12345var result = if (条件表达式){ 3 //返回值}else{ &quot;false&quot; //返回值，返回值可以是不同类型} 补充： 如果没有返回值则默认赋值kotlin.Unit； 最为表达式只能包含一个 if和else； 返回的是代码块最后一句的执行结果 when 语句when 语句类似于 switch 语句 基本语法when 将依次匹配所有分支，直到找到一个满足条件的分支 12345678910when (value) { //参数 1 -&gt; print(&quot;x == 1&quot;) //只有一条语句时可省略{} 2 -&gt;{ print(&quot;x==2&quot;) print(&quot;x == 2&quot;) } //多条语句时不能省略 else -&gt; { print(&quot;no match&quot;) //前面分支条件都没有匹配走else }} when 的参数如果是只读变量，它可以直接在括号内声明，此变量的作用域就是when内 1234when (val value = &quot;a&quot;) { is String -&gt; println(&quot;value&quot;) else -&gt; println(&quot;else&quot;)} 分支条件分支条件可以为任意表达式，对比的只是表达式的结果 1234when (x) { s.toInt() -&gt; print(&quot;s encodes x&quot;) else -&gt; print(&quot;s does not encode x&quot;)} 可以使用 in 或 !in 匹配一个范围或集合 123456when (x) { in 1..10 -&gt; print(&quot;匹配范围&quot;) in validNumbers -&gt; print(&quot;匹配集合&quot;) !in 10..20 -&gt; print(&quot;&quot;) else -&gt; print(&quot;&quot;)} 可以使用 is 或 !is 匹配特定类型，这里存在只能强制转换，在匹配到的代码块中可以直接访问该类型的方法和属性 12345fun whatType(x: Any) = when(x) { is String -&gt; print(&quot;String&quot;) is Int -&gt; print(&quot;int&quot;) else -&gt; print(&quot;i do not know&quot;)} when 作为表达式when 作为表达式会返回第一个匹配到分支最后一句的结果 123456789var x = 1var result = when (x) { 1 -&gt; &quot;11&quot; 2 -&gt; { //... &quot;22&quot; } else -&gt; 33} 并且一般情况下else是必须存在的，除非编译器能证明所有可能的条件都包含（例如，将enum作为参数） 12345678enum class Bit { ZERO, ONE}val numericValue = when (getRandomBit()) { Bit.ZERO -&gt; 0 Bit.ONE -&gt; 1} when 表达式中以下情况下 else 是必须的 ： 参数为Boolean、enum 或sealed类型，或者它们为空的同类； when 不能覆盖所有可能的条件； 要为多个匹配项共用一个代码块 1234when (x) { 0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;) else -&gt; print(&quot;otherwise&quot;)} when 可以不填写参数，此时可以用来代替 if 语句，这里分支条件结果必须是布尔类型 12345when { x.isOdd() -&gt; print(&quot;x is odd&quot;) y.isEven() -&gt; print(&quot;y is even&quot;) else -&gt; print(&quot;x+y is odd&quot;)} 循环语句for 语句for 语句主要是用来遍历各种集合数组等数据 基本语法123for (item: 类型 in collection) { // ...（只有一条语句时可省略{}）} for 循环可以变例任何可以提供迭代器的对象： 具有一个成员或 iterator() 扩展方法返回 Iterator&lt;&gt;； 有成员或 next()扩展方法； 有成员或hasNext()扩展方法，返回布尔类型 迭代数字1234567for (i in 1..3) { println(i)}for (i in 6 downTo 0 step 2) { println(i)} 根据索引遍历数组根据索引遍历数组，此时不会创建迭代器对象 123456789//获取索引for (i in array.indices) { println(array[i])}//获取索引和值for ((index, value) in array.withIndex()) { println(&quot;the element at $index is $value&quot;)} while 和 do-while 循环while 和 do-while 循环都是在满足条件时执行其注意，区别只是条件检查的时间 1234567while (条件表达式) { //条件表达式结果为布尔类型 //...}do { //...} while (条件表达式) 跳转语句跳转表达式有三个： break：结束最近的循环； continue：跳过本轮循环进入下一次循环； return：从最近的函数或匿名函数返回 标签kotlin 中的任何表达式都可以被标记，形式为标识符后加 @，标签可以配合break、continue和return使用 配合break、continue使用1234567891011121314151617//配合break//外层只会执行一轮，当内层j==3时直接跳出外层循环loop@ for (i in 1..100) { for (j in 1..100) { println(&quot;[${i},${j}]&quot;) if (j==3) break@loop }}//配合continue//外层会执行100次，当内层j==3时结束外层本轮循环继续下轮循环loop@ for (i in 1..100) { for (j in 1..100) { println(&quot;[${i},${j}]&quot;) if (j==3) continue@loop }} 配合 return 使用标签配合 return 语句使用时 todo","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"类型系统","text":"变量、类型别名、空安全 变量普通变量12345678910//使用var声明变量：var 变量名 : 类型 = 值var a :Int = 3//类型推断var b = 1//不初始化需要声明类型var c : Int//变量赋值c = 2 只读变量只读变量声明后只能赋值一次，并且之后不能改变其值 1234//声明只读变量val a : Inta = 1//适用于普通变量的声明方式等也同样适用于只读变量 变量声明位置1234567891011//变量可以声明在顶层var common = 1//只读变量val readOnly = &quot;只读&quot;fun main(){ //局部变量 common = 2 println(readOnly) println(common)} 编译时常量如果只读变量的值在编译时已知，可以使用const将其标记为常量，需要满足以下要求： 必须是顶级属性、伴生对象、或单例对象中 必须被一个字符串或者基本类型初始化 不能自定义getter 1234const val c:String = &quot;常量&quot;fun main(){ println(c)} 类型别名可以为类、函数指定类型别名 123456789101112//类别名typealias ClassAlias = ClassName&lt;String&gt;//类型转换typealias Alias&lt;T&gt; = (T)-&gt;Boolean//内部类别名typealias InnerAlias&lt;T&gt; = ClassName&lt;T&gt;.Innerclass ClassName&lt;T&gt;{ inner class Inner{ }} null 安全可空类型和非空类型kotlin中变量默认不接受null值，这样可以保证无论怎么调用a都不会发生空指针 12var a: String = &quot;abc&quot; a = null // 编译错误 想要允许null值需要在类型后加 ?，调用b可能出现空指针 12var b: String? = &quot;abc&quot;b = null // 正确 安全调用在调用时想要确保不会发生空指针，可以在变量后加 ? 12val b: String? = nullprintln(b?.length) 在调用时如果b为null则会直接返回null，不会发生空指针 Elvis 表达式1val l: Int = if (b != null) b.length else -1 可简写为 1val l = b?.length ?: -1 !! 操作符非空断言运算符（!!），将任何值转换为非空理想，如果值为null，则抛出异常 1val l = b!!.length 如果b为空则抛出异常","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"面向对象","text":"类、继承、扩展、委托、接口、泛型、抽象类、内联类、数据类、密封类、枚举类、单例、对象表达式、可见性修饰符 类类定义1234567891011121314151617class ClassName [可见性修饰符] [注解] constructor(var age:Int,val name:String){ constructor(age:Int, name:String, sex:String):this(age,name){ println(&quot;辅助构造函数，名字:$name,年龄:$age,性别:$sex&quot;) } init { println(&quot;初始化，name=$name,age=$age&quot;) }}//创建类实例//kotlin不需要new关键字fun main(){ val c = ClassName(实参列表)} 类初始化主构造函数可以有一个主构造函数和一个或多个辅助构造函数，主构造函数使用constructor关键字声明 123class ClassName constructor(age:Int,name:String){} 如果主构造函数没有任何注释或可见性修饰符，则可以省略constructor关键字 123class ClassName(age:Int,name:String){} 初始化器主构造函数中不能包含任何代码，初始化代码需要放在以init关键字修饰的初始化块中，主构造函数的参数可以在初始化块和类中声明的属性初始化器追踪使用。如果有多个初始化块，会按声明顺序执行 12345678class ClassName(age:Int,name:String){ var myName = name init { println(&quot;类初始化&quot;) println(&quot;age=$age,name=$name&quot;) println(&quot;name=$myName&quot;) }} kotlin可以在主构造函数中声明类属性并进行初始化 123class ClassName(var age:Int,val name:String){} 入股主构造函数有注释或可见性修饰符，则需要声明constructor关键字 123class ClassName public @Bean constructor(){} 即使没有主构造函数，init代码块也会执行 辅助构造函数辅助构造函数必须直接或间接的委托给主构造函数，使用this关键字完成对另一个构造函数（可以是辅助/主构造函数）的委托 1234567891011class ClassName(var age:Int,val name:String){ constructor(age:Int, name:String, sex:String):this(age,name){ println(&quot;辅助构造函数，名字:$name,年龄:$age,性别:$sex&quot;) } init { println(&quot;初始化，age=$age,name=$name&quot;) } } 上面代码执行的顺序是：init初始化块-&gt;辅助构造函数，因为初始化代码块会组为辅助构造器的第一条语句执行，初始化程序总是最早执行的。如果没有主构造函数，会生成一个不带参数的主构造函数（默认public），此时辅助构造函数不用使用this 1234567891011class ClassName{ constructor(age:Int, name:String, sex:String){ println(&quot;辅助构造函数，名字:$name,年龄:$age,性别:$sex&quot;) } init { println(&quot;初始化&quot;) }} 类成员class中可以生命的成员包括： 构造函数和初始化块：详细介绍 方法 属性：可以声明var和val变量，使用时直接通过名称访问，详细介绍 嵌套类和内部类 对象声明 属性声明属性的完整格式如下： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 可选参数说明： PropertyType：如果可以从property_initializer或 getter 的返回类型推断出属性类型，则PropertyType是可选的 property_initializer：如果getter和setter中的需要使用field关键字，否则可能无法赋初始值 getter：如果自定义了getter，每次获取值都会触发getter setter：如果自定义了setter，每次赋值都会触发，除了初始化。val属性不允许设置setter 1234567891011class Dog(name: String){ var name:String = name get() { println(&quot;getter&quot;) return field } set(value) { println(&quot;setter value=$value&quot;) field = value }} field 关键字表示当前操作的字段，并且只能在getter和setter中使用。因为我们需要在getter和setter中对属性进行获取和赋值，如果直接使用原属性就可能出现递归，循环的调用原属性，所以才需要使用field 操作属性 lateinit 关键字一般声明为非空类型的属性必须在构造函数中初始化，但有时我们希望通过依赖注入等方式进行初始化，在这种情况下无法在构造函数将那些初始化，可以使用lateinit关键字标记var属性避免null检查 12345678910111213class MyTest{ //这里不加lateinit编译不通过 //作用在var属性上，不在主构造函数中，没有自定义getter和setter //变量必须是非空的，并且不能是原始类型（Int等） lateinit var s:String fun f1(){ //判断变量是否已经初始化 //此检查只适用于访问类内、外部类以及顶层属性 this::s.isInitialized }} 内部类嵌套类接口和类可以任意嵌套 1234567891011121314class Outer{ private val value:String = &quot;123&quot; //类可以嵌套类 class InnerClass{ } //类可以嵌套接口 interface InnerInterface{ //接口可以嵌套类 class IClass{ } }} 内部类被标记为inner的内部类可以访问外部类的成员 12345678class Outer{ private val value:String = &quot;123&quot; inner class InnerClass{ fun f1() = value }} 匿名内部类1234567891011interface TestClass{ fun f1()}fun main() { object :TestClass{ override fun f1() { println(&quot;匿名内部类&quot;) } }} this 关键字this表示当前接收者，用于 在类成员中，指的是该类当前对象，此时如果没有命名冲突可以不用写this 在扩展函数或function literal with receiver中，this表示在 . 左侧对象 在外部的作用域使用this（类、扩展函数、function literal with receiver），需要写this@label，@label是this的作用域 123456789101112131415161718192021class A { //label @A inner class B { // label @B fun Int.foo() { // label @foo val a = this@A // A's this val b = this@B // B's this val c = this // foo()'s receiver, an Int val c1 = this@foo // foo()的接收者：Int val funLit = lambda@ fun String.() { val d = this // funLit's receiver } val funLit2 = { s: String -&gt; // foo()的接收者, since enclosing lambda expression // doesn't have any receiver val d1 = this } } }} 继承kotlin中的所有类都有一个父类Any，如果没有声明父类，那他就是默认父类。Any有三个方法： equals() hashCode() toString() 默认情况下，kotlin中的类是不能被继承的，如果希望可继承，需要使用open关键字。子类继承父类需要将父类放在类头的冒号之后 1234567open class Animal{}class Dog() :Animal(){} 补充： kotlin是单继承； 如果继承的基类和接口中有同名的成员，那么派生类应该对其提供自己的实现； 构造函数如果派生类具有主构造函数，则必须根据主构造函数的参数初始化基类 123456open class Animal(var name:String){}class Dog(name: String,age: Int) :Animal(name){ } 如果派生类没有主构造函数，则每个辅助构造函数都需要用super关键字初始化基类，或者委托给另一个构造函数。初始化基类时可以调用基类不同的构造函数 123456789open class Animal(var name:String){}class Dog :Animal{ constructor(name: String):super(name){ println(&quot;name=$name&quot;) }} 覆盖成员kotlin需要使用open关键字显示声明可覆盖的成员，子类使用override关键字声明覆盖的成员。另外override修饰的成员默认是可覆盖的，如果想要进制之后的覆盖，需要使用final 覆盖方法123456789101112131415open class Animal(var name:String){ open fun f1(){ println(&quot;父类方法&quot;) }}//可以在主构造函数参数中覆盖属性class Dog(name: String) : Animal(name) { //覆盖方法，禁止再次覆盖 final override fun f1(){ println(&quot;覆盖父类方法&quot;) }} 覆盖属性可以在构造函数参数和成员中覆盖基类属性，可以使用var覆盖val，反之不行 1234567891011open class Animal(var name:String) { open val age: Int = 0 open var sex: String = &quot;雌性&quot;}//可以在主构造函数参数中覆盖属性class Dog(name: String,num:Int,override var sex:String) : Animal(name) { //覆盖属性 override var age:Int = num} 派生类初始化顺序父类的参数和初始化块都执行完毕后才会进行子类的初始化，所以在父类的初始化过程中不应该使用子类的覆盖了的成员。因此，在设计基类时，应避免将open放在构造函数、属性初始值设定项或init块上。 下面是验证初始化顺序的代码： 123456789101112131415open class Animal(name: String){ open var name:String = name.also { println(&quot;初始化父类参数&quot;) } init { println(&quot;执行父类初始化块&quot;) }}class Dog(name: String) : Animal(name) { init { println(&quot;执行子类初始化块&quot;) } override var name:String = name .also { println(&quot;初始化子类参数&quot;) }} 打印结果： 1234初始化父类参数执行父类初始化块执行子类初始化块初始化子类参数 调用基类成员派生类中通过super关键字可以调用积累的成员 1234567891011open class Animal(var name: String){ fun f1(){}}class Dog(name: String) : Animal(name) { fun f2(){ super.name super.f1() }} 扩展Kotlin 提供了使用新功能扩展类的能力，而无需从类继承或使用诸如装饰者之类的设计模式 扩展方法1234fun 类型.方法名(参数列表):返回值{ //通过this操作对象 println(&quot;为A扩展方法 name:${this.name}&quot;)} 例子： 12345678910open class A{ var name:String = &quot;张三&quot; fun f1(){ println(&quot;A-&gt;f1&quot;) }}fun A.addFun(){ println(&quot;为A扩展方法 name:${this.name}&quot;)} 扩展属性扩展属性语法如下： 12val &lt;T&gt; 类型&lt;T&gt;.变量名: 变量类型 [get()] 因为扩展实际上不会将属性加入到类中，所以不能使用field，不能初始化，只能通过getter/setter来定义 123val &lt;T&gt; List&lt;T&gt;.lastValue:Tval &lt;T&gt; List&lt;T&gt;.lastValue:Tget() = this[size-1] 将扩展声明为成员可以在另一个类中声明一个类的扩展 123456789101112131415161718class A{}//允许继承可以加openclass AExtensions{ fun A.f1(){ println(&quot;f1&quot;) } val A.a : String get() = &quot;aaa&quot; fun f2(){ this.toString() //A.toString() this@AExtensions.toString() //AExtensions.toString() }} 将扩展类声明为open表示可覆盖，可以重写方法 123456789101112131415161718192021222324252627282930313233open class Base { }class Derived : Base() { }open class BaseCaller { open fun Base.printFunctionInfo() { println(&quot;Base extension function in BaseCaller&quot;) } open fun Derived.printFunctionInfo() { println(&quot;Derived extension function in BaseCaller&quot;) } fun call(b: Base) { b.printFunctionInfo() //调用扩展方法 }}class DerivedCaller: BaseCaller() { override fun Base.printFunctionInfo() { println(&quot;Base extension function in DerivedCaller&quot;) } override fun Derived.printFunctionInfo() { println(&quot;Derived extension function in DerivedCaller&quot;) }}fun main() { BaseCaller().call(Base()) // &quot;in BaseCaller&quot; DerivedCaller().call(Base()) // &quot;in DerivedCaller&quot; DerivedCaller().call(Derived()) // &quot;in DerivedCaller&quot;} 解析方式扩展并不是将新成员插入到类中，只是让新函数可以以对象.成员的方式进行调用。它是静态的，在编译时就已经确定，所以不具备类的多态的概念，执行的方法仅由类型决定 12345678910111213open class Parentclass Child: Parent()fun Parent.getName() = &quot;&quot;fun Child.getName() = &quot;添加子类方法&quot;fun printClassName(s: Parent) { println(s.getName())}fun main(){ printClassName(Child()) //结果：添加父类方法} 如果添加的方法与类中原有的方法参数和类型相同，则会调用原方法，但可以重载原方法 123456789101112131415161718class Test{ fun f1(){ println(&quot;原方法&quot;) }}fun Test.f1(){ println(&quot;添加方法&quot;)}//重载fun Test.f1(i:Int){ println(&quot;添加方法2：int=$i&quot;)}fun main(){ Test().f1() //结果：原方法} 可空接收器使用可空接收器，即使其值为空也可以调用方法 1234567class Test{}fun Test?.f2() { if (this == null) return println(&quot;不为空&quot;)} 委托委托就是派生类不全部实现接口的方法，而是选择委托给了其他派生类，运行时根据当前派生类和其他派生类的方法生成真正的方法 委托方法基本语法一个Derived类可以实现一个Base接口通过委托其的全部的public成员对于指定的对象 1234567891011121314interface Base { fun print()}class BaseImpl(val x: Int) : Base { override fun print() { print(x) }}class Derived(b: Base) : Base by bfun main() { val b = BaseImpl(10) Derived(b).print() //10} by关键字是指b会被存储在Derived的对象中并且编译器会构造全部的Base方法转发到b，意思就是，将Base委托给b，根据b的真实类型构造实现方法，然后调用。 覆盖委托实现的接口成员可以在委托上实现接口方法，生成方法时会使用自己实现的 12345678910111213141516171819interface Base { fun printMessage() fun printMessageLine()}class BaseImpl(val x: Int) : Base { override fun printMessage() { print(x) } override fun printMessageLine() { println(x) }}class Derived(b: Base) : Base by b { override fun printMessage() { print(&quot;abc&quot;) }}fun main() { val b = BaseImpl(10) Derived(b).printMessage() //abc Derived(b).printMessageLine() //10} 但这种方式在委托对象中无法调用本类中重写的方法，委托对象只能调用自己实现的方法 委托变量kotlin支持委托属性，用于保存常见属性，以免每次使用都需要声明 惰性属性：首次访问时计算 可观察属性：监听有关此属性的更改 存储在map中的属性，代替声明每个属性都单独字段 基本语法属性委托用于将属性的行为委托给另一个对象 1val/var &lt;属性名&gt;: &lt;Type&gt; by &lt;表达式&gt; 使用operator关键字标记委托函数： 对于只读属性 (val) ，委托者应该提供getValue()； 对于可变属性 ( var)，委托必须另外提供setValue()； 方法详细介绍如下 1234567891011121314151617181920212223242526272829class Value{ //将value委托给了Delegate()对象，对于value的操作都会调用该对象中的方法 var value:String by Delegate()}class Delegate{ /** * thisRef：读取的对象（Value@7eda2dbb） * property：属性描述信息（var Value.value: kotlin.String） */ operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;):String{ return &quot;thisRef：$thisRef，property：$property&quot; } /** * thisRef：读取的对象（Value@7eda2dbb） * property：属性描述信息（var Value.value: kotlin.String） * value：设置传入的值（aaa） */ operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String){ println(&quot;thisRef：$thisRef，property：$property，value：$value&quot;) }}fun main() { val v = Value() v.value = &quot;aaa&quot; println(v.value)} 通过使用接口ReadOnlyProperty和ReadWriteProperty，可以在不创建新类的情况下将委托创建为匿名对象 1234567891011121314151617181920212223242526272829303132333435fun main() { var readWriteProperty = object :ReadWriteProperty&lt;Any?,String&gt;{ var curValue:String = &quot;&quot; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { println(&quot;thisRef：$thisRef，property：$property&quot;) //thisRef：null，property：var readWrite: kotlin.String，value：123 return curValue } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) { curValue = value println(&quot;thisRef：$thisRef，property：$property，value：$value&quot;) //thisRef：null，property：var readWrite: kotlin.String } } var readWrite:String by readWriteProperty readWrite = &quot;123&quot; println(readWrite) //123 val readOnlyProperty = object : ReadOnlyProperty&lt;Any?, String&gt; { var curValue:String = &quot;默认值&quot; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { println(&quot;thisRef：$thisRef，property：$property&quot;) //thisRef：null，property：val readOnly: kotlin.String return curValue } } val readOnly:String by readWriteProperty //等同 //val readOnly:String by readOnlyProperty println(readOnly)//默认值} 标准委托Kotlin 标准库为几种有用的委托提供工厂方法 惰性属性lazy()是一个方法，它接受一个lambda表达式并返回一个Lazy&lt;T&gt;类型实例，他在第一次get时执行，之后每次调用返回记住的结果 1234val lazyValue: String by lazy { println(&quot;第一次执行&quot;) &quot;Hello&quot;} 可观察属性每次赋值时都会调用对应处理程序。 123456class ObservableValue { var value: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) { prop, old, new -&gt; println(&quot;$old -&gt; $new&quot;) }} 参数： prop：属性（property name (Kotlin reflection is not available） old：旧值 new：新值 委托给另一个属性一个属性可以将它的 getter 和 setter 委托给另一个属性，委托属性可以是： 顶级属性 同一类的成员或属性 另一个类的成员或属性 语法格式 123456//委托给顶级属性::顶级属性名//委托给本类属性this::属性名//委托给其他类属性ClassName::属性名 举例如下 1234567891011121314151617//顶级属性var topLevelInt: Int = 0class ClassWithDelegate(val anotherClassInt: Int)class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) { //委托给本类属性 var delegatedToMember: Int by this::memberInt //委托给顶级属性 var delegatedToTopLevel: Int by ::topLevelInt //委托给其他类属性 val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt}//委托给顶级属性var MyClass.extDelegated: Int by ::topLevelInt 在map中存储属性将属性委托给map，将常用于解析Json等动态任务中 123456789101112131415161718192021222324//只读class Value(val map: Map&lt;String, Any?&gt;) { val value:String by map}//可读可写class MutableValue(val map: MutableMap&lt;String, Any?&gt;) { var value:String by map}fun main() { //构造函数传递map val v1 = Value(mapOf( &quot;value&quot; to &quot;迪莫&quot;, )) //会从map中获取对应的值 println(v1.value) val v2 = MutableValue(mutableMapOf( &quot;value&quot; to &quot;阿布&quot;, )) v2.value = &quot;瞌睡王&quot; println(v2.value)} provideDelegate通过定义provideDelegate操作符，用于自定义委托实现的逻辑，如果by右侧定义了provideDelegate作为一个成员或扩展方法，这个方法会被调用去创建委托实例 1todo 接口接口定义接口中可包含抽象方法声明，以及方法的实现。接口不能存储状态，但可以具有属性。使用interface关键字定义接口，接口中声明的属性可以是抽象的，也可以为getter提供实现，但不能有backing field。 12345678910111213141516171819202122232425interface Animal{ //抽象,接口中var不能初始化，不能有getter和setter var age:Int //val变量也不能初始化，但可以有getter val name:String get() = &quot;张三&quot;.also { println(&quot;name-getter&quot;) } //方抽象法，由子类实现 fun f1() //方法实现 fun f2(){ println(&quot;接口实现&quot;) }}//可以实现多个接口class Dog() :Animal{ override var age: Int = 3 override fun f1(){ println(&quot;子类实现&quot;) }} 接口继承接口可以相互继承，也就是说，接口可以为其他接口提供实现 123456789101112131415161718192021222324interface Animal{ //方抽象法，由子类实现 fun f1() //方法实现 fun f2(){ println(&quot;接口实现&quot;) }}interface Color{ var color:String}interface Cat:Animal,Color{ //覆盖属性 override var color:String //实现方法 override fun f1(){ println(&quot;Cat实现f1()&quot;) }} 继承方法冲突继承多个接口时可能从不同接口继承了同一方法的多个实现，这时需要自己实现这些冲突的方法（无论派生类是class还是interface） 123456789101112131415161718192021222324252627282930interface Cat{ fun f1() fun f2(){ println(&quot;Cat-&gt;f2&quot;) }}interface Dog{ fun f1(){ println(&quot;Dog-&gt;f1&quot;) } fun f2(){ println(&quot;Dog-&gt;f2&quot;) }}class CatAndDog:Cat,Dog{ override fun f1() { //调用Dog接口实现的f1 super&lt;Dog&gt;.f1() } override fun f2() { //调用Cat接口实现的f2 super&lt;Cat&gt;.f2() }} 函数式接口只有一个抽象方法的接口称为函数式接口或SAM接口。函数式接口可以有对各非抽象成员，但只能有一个抽象成员，使用fun声明函数式接口 12345678910111213141516171819fun interface MySAM{ fun invoke(i:Int):Int}fun main(){ //匿名内部类的方式调用 val s = object :MySAM{ override fun invoke(i: Int): Int { return i+1 } } println(s.invoke(2)) //sam调用 val s2 = MySAM{it+1} println(s2.invoke(2))} 类型别名泛型泛型类kotlin中的类和方法可以有泛型 12345678910interface Animal&lt;T&gt;{ fun cry(t:T):T}class Cat&lt;T&gt; :Animal&lt;T&gt;{ //返回t本身 override fun cry(t:T): T { return t }} 协变 out&lt;out T&gt;代表可以接收T类型的父类，但T不能作为参数，只能作为方法的返回值 1234567interface Production&lt;out T&gt; { fun produce(): T}fun demo(a: Production&lt;String&gt;) { val objects: Production&lt;Any&gt; = a} 逆变 in&lt;in T&gt;代表可以接收T类型的子类，但T不能作为返回值，只能作为方法的参数 1234567interface Consumer&lt;in T&gt; { fun consume(item: T)}fun demo(a: Consumer&lt;Number&gt;) { val objects: Consumer&lt;Double&gt; = a} 通用约束约束类型的上限，对应于java的extends关键字，冒号后指定类型上限 1class Test&lt;T:String&gt;(){} 如果没有指定上限，默认上限是Any?，一个尖括号内只能指定一个上限，如果需要指定多个，需要使用where子句 123456fun &lt;T&gt; test(t: T)where T : CharSequence, T : Comparable&lt;T&gt; { //...} 上面代码T必须实现CharSequence和Comparable&lt;T&gt; 类型投影类型预测in和out可以加到方法的参数中，用来限定传入的参数。 上面的in和out分别用来声明接收子类和父类，但他们都有限制，out不能作为参数，in不能用作返回值。当泛型T在一个类中既需要作为参数也需要作为返回值时，in和out就都无法使用了。如下代码所示 12345678910111213141516171819202122232425262728interface Projections&lt;T&gt; { var t:T fun consume(item: T) fun product():T}class Value&lt;T&gt;(override var t: T):Projections&lt;T&gt;{ override fun consume(item: T) { t = item } override fun product(): T { return t }}fun copy(from:Value&lt;Any&gt;,to:Value&lt;Any&gt;){ to.consume(from.product())}fun main() { val f:Value&lt;Any&gt; = Value(&quot;哈哈哈&quot;) val t:Value&lt;Any&gt; = Value(&quot;啦啦啦&quot;) copy(f,t) println(t.product())} 上面代码中Value类存储一个值，这个值是泛型的，通过copy函数可以将一个Value传递给另一个Value，但这样from和to的泛型就必须一致，比如，如果将 1val f:Value&lt;Any&gt; = Value(&quot;哈哈哈&quot;) 改为 1val f:Value&lt;String&gt; = Value(&quot;哈哈哈&quot;) 就会报错，想要解决可以将from声明为out，虽然问题解决了，但这样的话from就无法调用参数为T的方法 1234fun copy(from:Value&lt;out Any&gt;,to:Value&lt;Any&gt;){ to.consume(from.product()) from.consume(&quot;3&quot;)//编译不通过} 同理，如果使用in，锁门from中的T需要是Any子类，这样就不能赋值给to中的T 123fun copy(from:Value&lt;in Any&gt;,to:Value&lt;Any&gt;){ to.consume(from.product()) //编译不通过} 综上所述，可以通过in和out预测所传入的类型，但存在一定限制 星映射todo 对于Foo&lt;out T : TUpper&gt;，其中T是具有上限的协变类型参数TUpper，Foo&lt;*&gt;等效于Foo&lt;out TUpper&gt;。这意味着当T未知时，您可以安全地读取TUpperfrom 的值Foo&lt;*&gt;。 对于Foo&lt;in T&gt;，其中T是逆变类型参数，Foo&lt;*&gt;等效于Foo&lt;in Nothing&gt;。这意味着当未知时，您无法以安全的方式写入任何内容。Foo&lt;*&gt;``T 对于Foo&lt;T : TUpper&gt;，其中T是具有上限的不变类型参数TUpper，Foo&lt;*&gt;相当于Foo&lt;out TUpper&gt;用于读取值和Foo&lt;in Nothing&gt;用于写入值。 对于interface Function&lt;in T, out U&gt; Function&lt;*, String&gt;是指Function&lt;in Nothing, String&gt;。 Function&lt;Int, *&gt;是指Function&lt;Int, out Any?&gt;。 Function&lt;*, *&gt;是指Function&lt;in Nothing, out Any?&gt;。 6、函数泛型函数也可以声明泛型 123fun &lt;T&gt; test(t:T):T{ return t} 调用时指定泛型 1test&lt;Int&gt;(5) //返回5 抽象类可以使用abstract修饰一个类和类的成员。抽象成员在抽象类中没有实现 12345678910111213141516171819202122232425abstract class Animal{ //要么初始化要么使用abstract val name:String = &quot;名字&quot; abstract val age:Int //声明open表示该方法可以被覆盖 open fun f1(){ println(&quot;方法1&quot;) } //抽象方法 abstract fun f2()}class Dog(override val age: Int) :Animal(){ //覆盖方法需要override关键字 override fun f1(){ println(&quot;覆盖f1&quot;) } override fun f2(){ println(&quot;f2实现&quot;) }} 内联类todo 有时必要的业务逻辑，需要将基本数据类型、String 等等参数封装在一个 Model 中，然后在 Model 中封装一些方法，对这个参数做检查、验证等等操作。参数被封装之后，需要创建包装对象，对象的创建在堆中进行分配，数据量很大的情况，对性能的损耗也非常大 内联类定义Kotlin 1.5废弃了 inline 修饰符，引入了 value class，现在不推荐使用inline，应该使用value关键字声明内联类。value class是inline class的超集 1value class Password(private val s: String) 在类声明之前使用value修饰符和@JvmInline注释： 12@JvmInlinevalue class Password(private val s: String) 现阶段 value classes 和 inline classes 一样，只能在构造函数中传入一个参数，参数需要用 val 声明，将来可以在构造函数中添加多个参数，但是每个参数都需要用 val 声明 成员内联类可以声明属性、函数和init块，内联类属性不支持field，不支持lateinit/delegated 属性 12345678910111213@JvmInlinevalue class Password(val s: String){ init { } val key:String get() = &quot;123&quot; fun printPass(){ println(s) }} 继承内联类可以实现其他接口，但不能被继承 12345678interface Key{ }@JvmInlinevalue class Password(val s: String):Key{} 数据类数据类定义数据类用来保存数据，数据类必须保证以下条件： 主构造函数至少有一个参数 所有主构造函数都需要标记为val或var 数据类不能是抽象的、开放的、密封的、内部的 123data class Cat(var name:String,val age:Int){ } 编译器会自动从主构造函数中声明的所有属性派生以下成员： equals()/hashCode() Cat(name=迪莫, age=3)形式的toString() copy() componentN()与声明顺序中的属性相对应的函数 如果自己实现或是基类中有equals()、hashCode()、toString()，则不会生成这些函数 不允许为componentN()和copy()函数提供显式实现 如果基类有componentN()并且时open的，数据类会生成和覆盖响应方法，如果无法覆盖就会报错 主体中声明属性如果需要从生成的实现中排除属性，需要在数据类主体声明属性 123data class Cat(var name:String){ val age:Int = 3} 上面代码中只有name在内部会生成toString()，equals()，hashCode()，和copy()和component1()，这些方法都会忽略age属性。两个Cat的age属性不同也会被视为相等 copy()copy()函数用于复制对象，允许更改某些主函数声明的属性，同时其余属性保持不变 12345678data class Cat(var name:String){ val age:Int = 3}fun main(){ val c = Cat(&quot;迪莫&quot;) val c1 = c.copy(name = &quot;阿布&quot;)} 解构声名为数据类提供的组件函数可以使用结构声名 1234val c = Cat(&quot;迪莫&quot;,3)val (name,age) = cdata class Cat(var name:String,val age:Int){} 密封类密封类用来限制类的继承关系，子类数量是固定的 密封类定义使用sealed关键字定义密封类 定义时他的子类都在密封类内部定义，并且都是单例的 密封类构造函数可见性为protected（默认）或private 密封类类似于一个枚举类，不同之处在于枚举类的实例时唯一的，而密封类可以有很多实例 密封类本身是抽象的，可以定义抽象方法，不能实例化 1234567891011121314151617interface Animal{ fun cry()}sealed class Test(var name:String,var age:Int) :Animal{ //声明了多个匿名内部类 object Cat:Test(&quot;迪莫&quot;,3) { override fun cry() { println(&quot;迪莫叫&quot;) } } object Dog:Test(&quot;音速犬&quot;,2) { override fun cry() { println(&quot;音速犬叫&quot;) } }} 应用环境： 对象需要是有限集合的类型之一，但不能具有任何其他类型时，使用密封类 配合when语句12345var a:Animal = Test.Catwhen(a){ is Test.Cat -&gt;{} is Test.Dog -&gt;{}} 这样就不需要使用else 枚举类枚举类定义使用enum关键字修饰枚举类，内部每个枚举类常量用逗号分隔 123enum class Animal{ Cat,Dog,Rabbit} 每个枚举类常量都是对象，可以进行初始化 12345enum class Color(val rgb: Int) { RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)} 覆盖方法枚举常量可以使用相应的方法以及覆盖基本方法来声明自己的匿名类 1234567891011enum class ProtocolState { WAITING { override fun signal() = TALKING }, TALKING { override fun signal() = WAITING }; abstract fun signal(): ProtocolState} 实现接口枚举类可以实现接口，但不允许被继承 12345678910enum class IntArithmetics : BinaryOperator&lt;Int&gt;, IntBinaryOperator { PLUS { override fun apply(t: Int, u: Int): Int = t + u }, TIMES { override fun apply(t: Int, u: Int): Int = t * u }; override fun applyAsInt(t: Int, u: Int) = apply(t, u)} 枚举类使用枚举类提供了两个方法： EnumClass.valueOf(value:String)：返回对应名字的枚举类对象 EnumClass.values()：返回全部枚举类列表 12345678910111213141516enum class Color(val rgb: Int) { RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)}fun main() { //枚举对象直接调用 Color.BLUE //枚举类常量名称 Color.valueOf(&quot;RED&quot;).name //RED //枚举类常量位置 Color.valueOf(&quot;RED&quot;).ordinal //0 //枚举类常量列表 Color.values().size //3} 使用enumValues&lt;T&gt;()和enumValueOf&lt;T&gt;()函数以通用方式访问枚举类中的常量： todo 单例对象kotlin中通过object关键字可声明一个单例对象。省去了私有化构造函数、创建对象的过程。 12345678910111213//创建单例object singleObject{ val name:String = &quot;魔力猫&quot;; fun cry(){ println(&quot;喵&quot;) }}//使用单例对象fun main() { singleObject.name singleObject.cry()} 说明： 单例对象可以声明在顶级位置，也可以声明在类、接口等位置中 对象表达式对象表达式用于创建匿名对象，在第一次使用时被初始化 对象表达式定义对象表达式以object关键字开头 123456789101112131415161718fun main() { //如果没有任何非基本类型对象，可以直接object加{} val t1 = object { var hello:String = &quot;hello&quot; override fun toString() = &quot;$hello&quot; } //从超类型继承匿名对象 val t2 = object :TestClass{ override fun f1() { println(&quot;匿名内部类&quot;) } }}interface TestClass{ fun f1()} 匿名对象类型： 如果没有声明基类：Any 如果只有声明一个基类：基类 如果声明多个基类：需要显式声明类型 123456789101112131415161718class C { //Any类型 fun getObject() = object { val x: String = &quot;x&quot; } //A类型 fun getObjectA() = object: A { override fun funFromA() {} val x: String = &quot;x&quot; } //显式声明B类型 fun getObjectB(): B = object: A, B { override fun funFromA() {} val x: String = &quot;x&quot; }} 匿名对象做为返回值12345class c{ fun test() = object { val x: String = &quot;x&quot; }} 对象声明对象声明在第一次访问时被初始化 基本语法声明方式： 1234object 类名:基类,... { 属性声明 方法声明} 使用方式： 12类名.属性类名.方法 举例如下： 123456789101112131415161718interface AnimalList{ fun printAnimals()}object AnimalManager:AnimalList{ fun addAnimal(a: String) { } val Animals: LinkedList&lt;String&gt; = LinkedList&lt;String&gt;() override fun printAnimals() { println(Animals) }}fun main() { AnimalManager.addAnimal(&quot;猫&quot;)} 相当于使用object关键字声明一个类的同时创造一个对象，这个对象是单例的 伴生对象类中的对象声明可以使用companion关键字标记，这样就可以直接通过类名调用内部的对象声明中的成员，包括私有 12345678910111213141516171819class Animals{ //可省略伴生对象名称：AnimalManager companion object AnimalManager{ fun addAnimal(a: String) { } val Animals: LinkedList&lt;String&gt; = LinkedList&lt;String&gt;() }}//半生对象扩展方法fun Animals.AnimalManager.printAnimals(){ println(Animals)}fun main() { Animals.addAnimal(&quot;猫&quot;)} 可见性修饰符函数、属性、类、对象和接口可以直接在包内的“顶级”声明 顶级声明可见性修饰符如下： private：只在同一文件中可见 protected：不能用来修饰顶层声明 internal：同一模块中可见 public：默认可见性，在任何地方都可见 类成员可见性修饰符如下： private：类内可见 protected：类内和子类可见 internal：同一模块中可见 public：默认可见性，在任何地方都可见 覆盖类成员时规则： 方法覆盖时未声明可见性，则覆盖成员与原始成员可见性相同 private成员不可覆盖 子类覆盖父类方法可见性要相同或更大 补充： 局部变量、函数和类不能有可见性修饰符","link":"/2021/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"IO流","text":"I/O流用于对磁盘文件进行读写。 介绍Java中IO流分为两种： 字节流 InputStream：字节输入流 OutputStream：字节输出流 字符流 Reader：字符输入流 Writer：字符输出流 文件流 最初始的流，用于文件的读取和写入，其他的流都是对文件流的包装 FileInputStream 文件字节输入流，按字节读入文件 FileOutputStream 文件字节输出流，按字节写入文件 FileReader 文件字符输出流，按字符读入文件 FileWriter 文件字符输出流，按字符写入文件 转换流 用于将字节流转换为字符流 InputStreamReaderOutputStreamWriter缓冲流 带有缓冲区的IO流 BufferedReaderBufferedWriterBufferedInputStreamBufferedOutputStream数据流DataInputStreamDataOutputStream标准输出流PrintStream对象流 将对象进行序列化，然后读取或写入 使用transient关键字修饰的变量不会被序列化； ObjectInputStreamObjectOutputStream","link":"/2019/08/03/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/IO%E6%B5%81/"},{"title":"Optional","text":"Optional是Java中一种用来防止空指针问题的类。 传统解决空指针问题的方法是判断返回的对象是否为null 1234String name = Dog.getName();if(name != null){ //...} 这种方式在每次返回值时都需要判断一次对象是否为null，正常编写代码时很容易漏掉这个判断 创建 Optional123456789// 1. of方法：传入的值不能为null，否则抛出空指针1异常 Optional&lt;Integer&gt; a = Optional.of(1); // 2. empty方法：表示内部维护的值为null Optional&lt;Integer&gt; b = Optional.empty(); // 3. ofNullable方法：传入null，则返回的值为Optional.empty()，否则返回Optional.of(v) Integer v = 1; Optional&lt;Integer&gt; c = Optional.ofNullable(v); 获取 Value1234567891011121314Integer v = 1;Optional&lt;Integer&gt; optional = Optional.ofNullable(v); // 1. 如果value != null 返回value，否则返回other的执行结果 Integer c1 = optional.orElseGet(() -&gt; 0); // 2. 如果value != null 返回value，否则返回T Integer c2 = optional.orElse(0); // 3. 如果value != null 返回value，否则抛出参数返回的异常 Integer c3 = optional.orElseThrow(NullPointerException::new); // 4. value为null抛出NoSuchElementException，不为空返回value Integer c4 = optional.get(); 用途正常来看Optional好像没什么用，明明可以直接判断返回值是否为空为什么要包一层Optional，好像多此一举，但其实Optional主要是在处理链式调用时发挥作用 12345678910111213141516//这里声明一个字符串，假设这个字符串可能是null值，并且MyString类的toLowerCase和toUpperCase方法也可能返回Optional.empty()值String s = &quot;可能为空&quot;; // 1. 一般写法 if (s != null) { s = MyString.toLowerCase(s); if (s!=null){ s = MyString.toUpperCase(s); if (s!=null){ s = MyString.toLowerCase(s); } } } // 2. 使用Optional的链式写法 Optional&lt;String&gt; stringOptional = Optional.ofNullable(s); Optional&lt;String&gt; i = stringOptional.map(MyString::toLowerCase).map(MyString::toUpperCase).map(MyString::toLowerCase); 上面两种写法中实现的功能是相同的，第一种每次判断返回值是否为空然后进行操作，第二种使用链式调用，每次MyString的方法如果返回了Optional.empty()，那么之后的操作就都会直接返回Optional.empty()。","link":"/2019/08/06/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/Optional/"},{"title":"Stream","text":"Stream可以通过一系列链式方法调用处理集合数据，这些方法可以与Lambda或者方法引用配合使用。 基本概念 Stream由一组中间操作和一个终止操作组成； 一个Stream只能执行一次终止操作，再次使用会报错； Stream会在调用终止操作时开始执行； Stream不会改变源对象，会返回一个拥有新结果的的Stream； 实例化123456789101112131415// 1. list.stream()，通过集合获取Stream LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 获取流 Stream&lt;Integer&gt; stream1 = list.stream(); // 获取并行流 Stream&lt;Integer&gt; parallelledStream1 = list.parallelStream(); // 2. Arrays.stream()，通过数组获取Stream // 2.1. 通过引用类型数组获取 Integer[] arr1 = {1, 2, 3}; Stream&lt;Integer&gt; stream2 = Arrays.stream(arr1); // 2.2. 通过基本类型数组 int[] arr2 = {1, 2, 3}; IntStream stream3 = Arrays.stream(arr2); // 3. 通过Stream.of()，这里也可以传递一个数组 Stream&lt;Integer&gt; stream4 = Stream.of(1, 2, 3, 5, 4); 中间操作12345678910111213141516Stream&lt;Integer&gt; stream = Stream.of(1, 4, 2, 3, 5, 6, 6, 7, 8, 9); // 1. 筛选 stream.filter(a-&gt;a&gt;2).forEach(System.out::print); // 2. 切片 stream.limit(5).forEach(System.out::print); // 3. 跳过 stream.skip(5).forEach(System.out::print); // 4. 去重 stream.distinct().forEach(System.out::print); // 5. 排序：// 内部对象需要实现Comparable接口stream.sorted().forEach(System.out::print); // 自定义排序方法stream.sorted((a, b) -&gt; b - a).forEach(System.out::print); // 6. 映射：分别对每个数据进行处理 stream.map(i-&gt;Integer.toString(i)).forEach(System.out::print); 终止操作12345678910111213141516171819202122Stream&lt;Integer&gt; stream = Stream.of(1, 4, 2, 3, 5, 6, 7, 8, 9); // 1. 匹配 // 至少有一个满足 boolean any = stream.anyMatch(i -&gt; i &gt; 4); // 所有都满足 boolean all = stream.allMatch(i -&gt; i &gt; 4); // 2. 返回第一个元素 Optional&lt;Integer&gt; first = stream.findFirst(); // 3. 获取元素个数 long count = stream.count(); // 4. 获取最大值，实现comparable接口方法 Optional&lt;Integer&gt; max = stream.max((a1, a2) -&gt; a1 - a2); // 5. 获取最小值，实现comparable接口方法 Optional&lt;Integer&gt; max = stream.max((a1, a2) -&gt; a1 - a2); // 6. 内部迭代 stream.forEach(System.out::print); // 7. 归约 Integer reduce = stream.reduce(1, (pre, cur) -&gt; pre + cur); Optional&lt;Integer&gt; reduce1 = stream.reduce(Integer::sum); // 8. 收集：创建新的集合列表保存数据，转化为的类型使用Collectors内的方法引用指定 List&lt;Integer&gt; collect = stream.collect(Collectors.toList()); Map&lt;Integer, Integer&gt; collect1 = stream.collect(Collectors.toMap(i -&gt; i, i -&gt; i + 1));","link":"/2019/08/07/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/Stream/"},{"title":"包装类","text":"包装类 包装类八种包装类分别对应八种基本数据类型 基本类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类型都是用 final 修饰了，不可以被继承重写； 编译器会自动的将基本数据类型装箱成对象类型，或者将对象类型拆箱成基本数据类型； 自动装箱编译器在自动装箱的过程会调用 Integer.valueOf() 方法 缓冲池在使用基本类型的包装类时，如果范围在缓冲池范围之内时则可以直接使用缓冲池中的对象： new Integer() 会创建一个对象， Integer.valueOf() 会从缓存池中对象获取对象的引用 基本类型的缓冲池如下： 类型 取值 boolean true、false byte 全部byte的取值 short -128~127 int -128~127（上界可调整） char \\u0000~\\u007F","link":"/2019/08/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"title":"字符串","text":"字符串 String 不可变字符串 线程安全 版本 底层存储类型 java 8 及之前 char数组 java 9 及以后 byte数组存储数据，使用coder(byte)记录编码格式 String类型是不可变的，也就是说一旦String对象被创建，其字符串值就不能再更改，同样hash值也不会变化； 一个String类型的对象会在字符串池中创建，然后返回一个引用，再之后用到相同的字符串的对象就可以直接引用字符串池中的对象。 StringBuffer 可变字符串 线程安全 StringBuilder 可变字符串 线程不安全 字符串常量池字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 1234567//创建一个String对象，同时&quot;aaa&quot;字面量会被放到字符串String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s2.intern();System.out.println(s3 == s4); // true 使用字面量形式声明字符串会自动将字符串字面量放入字符串常量池中 123String s5 = &quot;bbb&quot;;String s6 = &quot;bbb&quot;;System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。","link":"/2019/08/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"日期","text":"Date-&gt;Calendar-&gt;LocalDateTime Date（Java1.1之前，已废弃）Date 表示特定的瞬间，精确到毫秒，是Java早期处理时间的类，现在已经不推荐使用。 构造方法1234567// 1. 构造一个日期对象，默认为当前系统时间 Date date1 = new Date(); // 2. 构造一个日期对象，时间为自 &quot;1970-1-1-00：00：00GMT&quot; 起至指定参数date的毫秒数所代表的日期 Date date2 = new Date(0L); // 3. 通过SimpleDateFormat解析并创建Date类型对象SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date3 = simpleDateFormat.parse(&quot;2000-10-21&quot;); 格式化使用SimpleDateFormat类对Date对象进行格式化 12345Date date2 = new Date(0L);// 创建SimpleDateFormat并指定时间格式SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String format = simpleDateFormat.format(date2); System.out.println(format); Calendar（Java1.1引入）Calendar类可以看作是对Date类的一个升级，它将日期分为多个部分：年、月、日、时、分、秒、星期等，添加了对每个部分进行运算的功能。 构造方法12// 获取当前时间:Calendar c = Calendar.getInstance(); 日期运算获取每个部分 12345678int y = c.get(Calendar.YEAR);int m = 1 + c.get(Calendar.MONTH);int d = c.get(Calendar.DAY_OF_MONTH);int w = c.get(Calendar.DAY_OF_WEEK);int hh = c.get(Calendar.HOUR_OF_DAY);int mm = c.get(Calendar.MINUTE);int ss = c.get(Calendar.SECOND);int ms = c.get(Calendar.MILLISECOND); 设置日期时间 12345678910// 设置2019年:c.set(Calendar.YEAR, 2019);// 设置9月:注意8表示9月:c.set(Calendar.MONTH, 8);// 设置2日:c.set(Calendar.DATE, 2);// 设置时间:c.set(Calendar.HOUR_OF_DAY, 21);c.set(Calendar.MINUTE, 22);c.set(Calendar.SECOND, 23); 转化为Date利用Calendar.getTime()可以将一个Calendar对象转换成Date对象 时区（TimeZone）Calendar和Date相比，它提供了时区转换的功能。时区用TimeZone对象表示： 123456TimeZone tzDefault = TimeZone.getDefault(); // 当前时区TimeZone tzGMT9 = TimeZone.getTimeZone(&quot;GMT+09:00&quot;); // GMT+9:00时区TimeZone tzNY = TimeZone.getTimeZone(&quot;America/New_York&quot;); // 纽约时区System.out.println(tzDefault.getID()); // Asia/ShanghaiSystem.out.println(tzGMT9.getID()); // GMT+09:00System.out.println(tzNY.getID()); // America/New_York 有了时区，我们就可以对指定时间进行转换： 12345678910111213// 当前时间:Calendar c = Calendar.getInstance();// 清除所有:c.clear();// 设置为北京时区:c.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));// 设置年月日时分秒:c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);// 显示时间:var sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));System.out.println(sdf.format(c.getTime()));// 2019-11-19 19:15:00 Date 和 Calendar 的局限性 可变性：日期和时间这样的类是不应该被随意修改的； 偏移性：Date中的年份是从1900开始的，而Date中的月份都从0开始，不利于表示； 格式化：Calendar类没有提供格式化日历的方法； 线程安全性：Date和Calendar类都不是线程安全的，也不能处理闰秒等问题。 LocalDateTime Java8引入 Java8引入了LocalDateTime、LocalDate、LocalTime三个时间类 获取时间1234567891011121314// 日期+时间 LocalDateTime localDateTime = LocalDateTime.now(); // 2024-04-20T17:03:04.656139201 System.out.println(localDateTime); // 日期 LocalDate localDate = LocalDate.now(); // 2024-04-20 System.out.println(localDate); // 时间 LocalTime localTime = LocalTime.now(); // 17:03:04.656213844 System.out.println(localTime); 格式化使用DateTimeFormatter对LocalDateTime、LocalDate、LocalTime进行格式化 12DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh-mm-ss&quot;); String format = dateTimeFormatter.format(LocalDateTime.now());","link":"/2019/08/05/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/%E6%97%A5%E6%9C%9F/"},{"title":"集合","text":"CollectionListArrayList 动态数组 CopyOnWriteArrayList 高并发List实现 LinkedList 动态链表 Vector 线程安全数组 Stack 栈 SetHashSet 无序列表 TreeSet 底层是红黑树的有序Set LinkedHashSet 用链表扩展HashSet，可以按照规则顺序提取元素 QueueArrayDeque 队列 MapHashMap 线程不安全Map TreeMap 底层使用红黑树实现的Map LinkedHashMap 用链表扩展HashMap，可以按照规则顺序提取元素 ConcurrentHashMap 高并发Map实现","link":"/2019/08/04/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E6%A0%87%E5%87%86%E5%BA%93/%E9%9B%86%E5%90%88/"},{"title":"Scrapy 基础知识","text":"介绍scrapy框架核心租价、基本命令、代码编写、以及各个组件的执行顺序 Scrapy 基础知识常用命令如果没有安装过scrapy应先执行 1$ pip install scrapy 创建爬虫工程该命令会在spiders下新建爬虫文件 1$ scrapy startproject 工程名 举例： 1$ scrapy genspider bilibili_test 创建爬虫文件该命令会在spiders下新建爬虫文件 1$ scrapy genspider 爬虫文件名 目标网站 举例： 1$ scrapy genspider bilibili www.bilibili.com 执行爬虫该命令会在spiders下新建爬虫文件 1$ scrapy crawl 爬虫文件名(不需要后缀) 参数： **–nolog:**不输出日志 **-o:**将parse()方法的返回值存储到指定输出文件，可以选择下列文件格式： csv json xml jl jsonlines marshal pickle 举例： 1$ scrapy crawl bilibili 项目结构创建爬虫工程后得到目录结构如下; 1234567891011- 工程名: spiders: #爬虫文件目录 __init__.py 爬虫文件.py #爬虫网站数据以及数据解析逻辑，将数据封装成item __init__.py items.py #数据封装对象 middlewares.py pipelines.py #管道，用于处理item类型对象，进行持久化 settings.py #爬虫配置- main.py- scrapy.cfg 项目包含的py文件中初始化了对应的类，在这些类中实现重写相应方法的逻辑代码，scrapy会按照顺序调用这些方法 核心组件 上面组件包括： 引擎(Scrapy Engine)：用来处理整个系统的数据流处理, 触发事务(框架核心)； 调度器(Scheduler)：用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址； 下载器(Downloader)：用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)； 爬虫(Spiders)：爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面； 项目管道(Pipeline)：负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据； 代码编写代码编写流程如下: 编写item用于封装解析到的数据； 编写spider用于指定访问的url和解析请求到的数据并将数据封装成item对象； 编写pipeline用于对item进行处理，一般是持久化； 编写middleware，一般用于配置代理以及user-agent等； 数据封装对象根据自身需求定义item类，封装需要的数据 下面例子是将文章封面图的link以及文章的title封装成item 12345678910# 封装文章数据class ArticleItem(scrapy.Item): # 属性的定义方式如下: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field()# 封装文章图片地址class ArticleImageItem(scrapy.Item): src = scrapy.Field() 爬虫文件爬虫文件中定义了将要请求的url以及页面数据的解析逻辑 下面是用于爬取b站某页专栏的代码，省略了解析表达式和网址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class BilibiliSpider(scrapy.Spider): name = 'bilibili' allowed_domains = ['www.bilibili.com'] # url方式一：初始请求数组 # start_urls = ['https://www.xxx.com/xxx'] # url方式二：start_requests()方法发起请求 def start_requests(self): print('Spider--start_requests()') # 爬取多页数据 for page in range(1, 2): print('Spider--start_requests()--for') # 手动发起请求，每次请求一个url，使用模板字符串拼接页数 yield scrapy.Request(f'https://search.bilibili.com/article?vt=67519417&amp;keyword=%E5%A4%8F%E6%97%A5%E9%87%8D%E7%8E%B0&amp;from_source=webtop_search&amp;spm_id_from=333.1007&amp;search_source=2&amp;page={page}') def parse(self, response: HtmlResponse): print('Spider--parse()') list_items = response.css('body &gt; #server-search-app .body-contain .article-item') for list_item in list_items: article_item = ArticleItem() # css()和xpath()方法返回的是selector列表 # extract()方法将selector列表解析成字符串列表 # extract_first()方法将selector列表中第一个数据解析成字符串并返回该字符串 article_item['link'] = list_item.css('a img::attr(src)').extract_first() article_item['title'] = list_item.css('.content &gt;.headline&gt;a::attr(title)').extract_first() article_url = &quot;https:&quot; + list_item.css('.content &gt;.headline &gt; a::attr(href)').extract_first() print('Spider--parse()--for') # 将article_item信息发送到管道 yield article_item # 调用parse_article()方法解析详细信息 # 请求传惨：通过meta参数传递一个map，目标方法可以接收 yield scrapy.Request(article_url, self.parse_article_image, meta={'article_item': article_item}) # 自定义解析文章详情页的方法，用于提取图片 def parse_article_image(self, response): # 获取传递的参数 article_item = response.meta['article_item'] print(f&quot;获取文章《{article_item['title']}》的图片&quot;) figure_list = response.css('#article-content &gt; #read-article-holder figure') for figure_item in figure_list: image_url = &quot;https:&quot; + figure_item.css('::attr(data-src)').extract_first() image_item = ArticleImageItem() image_item['src'] = image_url yield image_item 管道需要先配置开启管道 1234567# 开启管道# 可以配置任意个管道类，会按照优先级从小到大进行执行ITEM_PIPELINES = { # 管道类全类名: 优先级 'bilibili_test.pipelines.MysqlPipeline': 300, 'bilibili_test.pipelines.ArticleImagePipeline': 301,} 下面定义了两个管道： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 将文章信息存储到mysql数据库class MysqlPipeline: # 数据库连接 conn = None # 数据库游标多谢 cursor = None # 该方法会在爬虫开始时被调用并且只会被调用一次 def open_spider(self, spider): print('mysql管道--open_spider()') self.conn = pymysql.Connect( host='127.0.0.1', port=3306, user='root', password='123456', db='scrapy_test', charset='utf8', ) # 接收爬虫文件传递过来的item对象 def process_item(self, item: ArticleItem, spider): print('mysql管道--process_item()') if not isinstance(item, ArticleItem): # 如果不是需要的类型，直接发送到下一个管道 return item # 写入文件 self.cursor = self.conn.cursor() # 插入到mysql try: self.cursor.execute('insert into article(title,link) values(&quot;%s&quot;,&quot;%s&quot;)' % (item[&quot;title&quot;], item[&quot;link&quot;])) self.conn.commit() except Exception as e: print(e) self.conn.rollback() return item # 爬虫结束后会调用一次 def close_spider(self, spider): print('mysql管道--close_spider()') self.conn.close()# 声明父类是ImagesPipeline# ImagesPipeline是scrapy提供的专门用于图片存储的管道类class ArticleImagePipeline(ImagesPipeline): # 根据图片地址进行图片数据的请求 def get_media_requests(self, item, info): print('图片下载管道--get_media_requests()') if not isinstance(item, ArticleImageItem): # 如果不是需要的类型，直接发送到下一个管道 return item # 获取图片 yield scrapy.Request(item['src']) # 指定文件存储位置 def file_path(self, request, response=None, info=None, *, item=None): print('图片下载管道--file_path()') imageName = request.url.split('/')[-1] return imageName # 用于该管道执行结束向下一个将要执行的管道传递数据 # 如果不需要传递数据，则这个方法可以不重写 def item_completed(self, results, item, info): print('图片下载管道--item_completed()') # 把当前的item传递给下一个管道类 return item 中间件需要先配置开启管道 123456789# 开启爬虫中间件SPIDER_MIDDLEWARES = { 'bilibili_test.middlewares.BilibiliTestSpiderMiddleware': 543,}# 开启下载中间件DOWNLOADER_MIDDLEWARES = { 'bilibili_test.middlewares.BilibiliTestDownloaderMiddleware': 543,} 中间件有两个 爬虫中间件 下载中间件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192proxy_ip_list = [ '47.92.113.71:80', '117.157.197.18:3128', '111.23.16.250:3128',]user_agent_list = [ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot; # ......]# 爬虫中间件class BilibiliTestSpiderMiddleware: @classmethod def from_crawler(cls, crawler): print('爬虫中间件--from_crawler()') s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_spider_input(self, response, spider): print('爬虫中间件--process_spider_input()') # 返回None或一个异常 # 如果是None,就继续调用其他的spider middleware。 # 如果是一个异常，调用request里的errback()方法，再抛出异常是交给process_spider_exception(response, exception, spider)处理 return None def process_spider_output(self, response, result, spider): print('爬虫中间件--process_spider_output()') # 必须返回一个包括request或item对象的可迭代对象 for i in result: yield i # 当spider或其他中间件的process_spider_input()报错时被调用 def process_spider_exception(self, response, exception, spider): print('爬虫中间件--process_spider_exception()') # 应该返回 None 或一个可迭代的 Request 或 item 对象 pass # 爬虫启动请求 def process_start_requests(self, start_requests, spider): print('爬虫中间件--process_start_requests()') # 只能返回request对象 for r in start_requests: yield r def spider_opened(self, spider): print('爬虫中间件--spider_opened()') spider.logger.info('Spider opened: %s' % spider.name)# 下载中间件class BilibiliTestDownloaderMiddleware: @classmethod def from_crawler(cls, crawler): # Scrapy 使用此方法来创建爬虫 print('下载中间件--from_crawler()') s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s # 拦截请求，当每个request通过下载中间件时，该方法被调用 def process_request(self, request, spider): print('下载中间件--process_request()') # 随机选择user-agent ua = random.choice(user_agent_list) # 设置请求的ua request.headers['User-Agent'] = ua return None # 拦截响应， def process_response(self, request, response, spider): print('下载中间件--process_response()') return response # 拦截发生异常的请求 def process_exception(self, request, exception, spider): print('下载中间件--process_exception()') # 请求失败就设置代理ip if request.url.split(':') == 'https': # 设置代理ip request.meta['proxy'] = 'https//' + random.choice(proxy_ip_list) else: request.meta['proxy'] = 'http//' + random.choice(proxy_ip_list) # 返回request会重新进行请求发送 return request def spider_opened(self, spider): print('下载中间件--spider_opened()') spider.logger.info('Spider opened: %s' % spider.name) 执行顺序下面的爬虫中间件和下载中间件均的优先级相同；下列执行步骤中如果定义了多个管道，则会按照设置的优先值从小到大执行，并且位置是相邻的 初始化执行部分： 下载中间件–from_crawler() 爬虫中间件–from_crawler() 管道–open_spider() 下载中间件–spider_opened() 爬虫中间件–spider_opened() 爬虫开始部部分： 爬虫中间件–process_start_requests() Spider--start_requests() Spider--start_requests()--for 下载中间件–process_request() 下载中间件–process_response() 爬虫中间件–process_spider_input() 爬虫中间件–process_spider_output() Spider--parse() Spider--parse()--for 管道process_item() Spider--parse()--for 管道–process_item() 下载中间件–process_request()（调用scrapy.Request()触发该方法） Spider--parse()--for ……","link":"/2023/01/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/Scrapy/Scrapy%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"模块系统","text":"所有权、生命周期、智能指针 内存管理所有权所有权是rust的一个特性，它让Rust无需垃圾回收器即可保证内存安全 基本概念对于字面量，所需要的大小可以直接确定，编译过程中会被硬编码进最终的可执行文件中，直接分配在栈中，这样变量就可以随着作用域的结束而被回收。 但对于可变类型（比如String类型），在运行时长度是可变的，所以在编译阶段无法确定应该为其分配多大的内存空间。这意味着我们需要将其分配到堆中，如此我们就需要如下两个步骤对内存进行管理： 必须在运行时向内存分配器请求内存； 使用完后将内存返还给内存分配器； 不同语言管理内存的方式不同，这里难点在于内存回收，比如java通过GC实现垃圾回收，而C++通过手动分配和释放来管理内存。而rust选择了所有权系统管理内存，简单来讲就是：内存在拥有它的变量离开作用域后就被自动释放。 所有权规则 Rust中的每一个值都有一个被称为其 所有者（owner）的变量。 值在任一时刻有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 在变量离开作用域时（也就是在Rust结尾处的}），Rust会调用一个特殊的函数drop()，在这个方法内可以放置变量类型对应的内存释放代码。但这样明显有一个问题：当多个变量引用了堆上的一个对象时，如果其中一个变量调用drop()进行回收，其他的变量怎么办呢？ 变量与数据交互方式浅拷贝12let s1 = String::from(&quot;hello&quot;);let s2 = s1; 上面代码并不会复制堆中的数据，只是将s1指向的地址和目标对象长度赋值给s2，执行完毕后得到的结果为：s1和s2最终都指向堆中的数据。此时如果释放s1和s2都希望释放内存，那么就会产生二次释放的问题，造成安全漏洞。 为确保内存安全，此时rust会在let s2 = s1后使s1失效，因此在之后不能使用s1，否则会报错，这样就解决了二次释放的问题 123let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;{}&quot;,s2) //报错 深拷贝通过clone()函数进行深拷贝，他会在堆上新分配一个相同的对象，这样不会存在多次释放的问题，但非常消耗资源 12let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone(); 栈数据的拷贝栈中的数据没有深浅拷贝的区别，或者说都是深拷贝，因为栈上的数据都是可以确定大小的，所以宝贝值是很快速的。所以下面代码中的x还是有效的 123let x = 5;let y = x;println!(&quot;x = {}, y = {}&quot;, x, y); Rust 有一个叫做 Copy trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 标注，将会出现一个编译时错误。 所有权与函数参数将值作为参数传递给函数在语义上与变量赋值相似 123456789fn main() { let s = String::from(&quot;hello&quot;); test(s); print!(&quot;{}&quot;,s); //报错}fn test(s1:String){//s无效 println!(&quot;调用方法&quot;)}//s1指向的数据被回收 上面代码将s传递给方法后，变量s就无效了，所以在之后访问s就会报错。方法执行过程中，首先s被赋值给s1，s失效，然后方法执行结束后s1指向的空间被回收。 返回值返回值一样可以转移所有权 123456789fn main() { let s = test(); print!(&quot;{}&quot;,s);}fn test()-&gt;String{ let s1 = String::from(&quot;hello&quot;); s1} 上面代码中test()方法创建一个变量s1，然后返回。主函数中通过变量s接收，之后所有权就转移到了s，后面可以访问s。并且因为s1的所有权被转移，所以在作用域结束后也不会释放堆空间中的内存。 引用和借用引用当我们需要将变量作为参数传递给函数，并且在之后还需要使用这个变量时，需要使用引用，引用不会导致所有权的转移。声明格式为：在传值和声明类型时都在前面添加&amp;符号 123456789fn main() { let s = String::from(&quot;hello&quot;); test(&amp;s); print!(&quot;{}&quot;,s); //不会报错}fn test(s1:&amp;String){ println!(&quot;调用方法&quot;)} 此时的指向为：s1-&gt;s-&gt;data，所以用一个对象的引用作为参数不会获取对象的所有权，因此在离开作用域时也不会丢弃指向的数据。这个引用的行为被称为借用，就像变量s1借用了变量s的数据，但变量s1只能用，不能改，因为数据不是他的，没有所有权，用完后必须还回去。 可变引用引用的值是无法更改的 12345678fn main() { let s = String::from(&quot;hello&quot;); test(&amp;s);}fn test(s1:&amp;String){借用的值 s1.push_str(&quot;,world&quot;) //编译不通过，无法修改} 如果希望可以更改引用的值只需要如下更改 1234567891011fn main() { //声明为可变变量 let mut s = String::from(&quot;hello&quot;); //传递时前面加上&amp;mut test(&amp;mut s);}//类型前加上&amp;mut fn test(s1: &amp;mut String){ s1.push_str(&quot;,world&quot;)} 数据竞争数据竞争表示同一时间，对同一数据进行多个可变引用的限制允许可变性。数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复。它可由以下行为造成： 两个或更多指针同时访问同一数据。 至少有一个指针被用来写入数据。 没有同步数据访问的机制。 为了防止数据竞争，可变引用有如下限制： 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。 引用必须总是有效的。 生命周期生命周期主要用于避免悬垂引用。rust 中每个引用都有其生命周期 悬垂引用 悬垂指针是指其指向的内存可能已经被分配给其它持有者 Rust 的编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域（引用存在，数据就绝对还存在）。 12345678910{ let r; { let x = 5; r = &amp;x; } println!(&quot;r: {}&quot;, r);//编译错误} 上面代码会报错，因为r的作用域大于x，在访问r时，x所引用的值已经被释放掉了。总结来说就是被引用的数据比引用者更早的被释放 泛型生命周期标注1234567fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str { if x.len() &gt; y.len() { x } else { y }} 上述代码会编译报错，因为rust不知道最终返回的是x的引用还是y的引用。rust使用泛型生命周期标注解决这个问题，生命周期标注格式如下： 1234'a //标注&amp;类型 // 引用&amp;'a 类型 // 带有显式生命周期的引用&amp;'a mut 类型 // 带有显式生命周期的可变引用 生命周期参数标注泛型生命周期标注用于标注函数返回值的生命周期参数与一个参数的生命周期参数相匹配： 12345678//'a必须要去至少一个参数相关联，否则无法确认返回值的生命周期fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str { if x.len() &gt; y.len() { x } else { y }} 上面代码表示被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。因为我们用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。 结构体生命周期标注结构体生命周期标注用于标注结构体中的引用 12345678910fn main() { let cat_name = String::from(&quot;魔力猫&quot;); let c = Cat{name: &amp;cat_name,age:&amp;3}; println!(&quot;{}&quot;,c.name)}struct Cat&lt;'a&gt;{ name:&amp;'a str, age:&amp;'a i32} 上面代码表示Cat的实例的生命周期需要比name和age的生命周期更短，main()方法中的cat_name和3的生命周期都要大于cat实例 方法生命周期标注12345impl&lt;'a&gt; 结构体&lt;'a&gt; { fn fun(&amp;self,s: &amp;str) -&gt; &amp;str { s }} 实现方法时，结构体字段的生命周期必须总是在 impl 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。对象方法返回的引用都被赋予self生命周期 生命周期标注省略一般来说对于每个返回的引用都应该使用生命周期标注，但rust的借用检查器可以在可预测的模式下自动推断出生命周期标注，所以就不需要开发正显示增加标注了， 生命周期省略规则： 每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo&lt;'a&gt;(x: &amp;'a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)，依此类推。 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32。 如果方法有多个输入生命周期参数并且其中一个参数是 &amp;self 或 &amp;mut self，说明是个对象的方法，那么所有输出生命周期参数被赋予 self 的生命周期。 静态生命周期静态生命周期：'static，其生命周期能够存活于整个程序期间。所有的字符串字面量都拥有 'static 生命周期，也可以手动标注出来 1let s: &amp;'static str = &quot;字符串字面量&quot;; 生命周期标注结合泛型123fn fun&lt;'a,T&gt;(t:&amp;T)-&gt;&amp;'a T{ t} 智能指针","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"函数","text":"函数 函数声明函数使用fn关键字声明 123456fn 函数名(参数1:类型,参数2:类型,...)-&gt;返回值类型 { //函数体 //return和;可以省略 return 返回值;} 补充： Rust 代码中的函数和变量名使用下划线命名法； 返回值写在函数最后一句，不需要写return； 举例如下： 123fn test(p1:i32,p2:i32) -&gt; i32 { p1+p2} 返回多个值rust可以通过声明和返回元祖类型实现返回多个值，代码如下： 123fn test(p1:i32,p2:i32) -&gt; (i32,i32) { (p1,p2)}","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/"},{"title":"复合类型","text":"元组、数组、切片 元组元组声明元组中值的类型可以不同，值的类型要和前面声明的类型相对应。如果省略类型声明，编译器会自动进行类型推断 123let tup:(类型1,类型2,...) = (值1,值2,...)//省略声明类型let tup = (值1,值2,...) 补充： 组的长度是固定的，声明后，就无法增长或缩小； 没有任何值的元组 () 是一种特殊的类型，被称为单元类型，该值被称为单元值。如果表达式不返回任何其他值，就隐式地返回单元值； 举例如下： 1234567fn main() { let cat:(String,i32,bool) = (String::from(&quot;魔力猫&quot;),2,true); //类型推断 let dog = (String::from(&quot;音速犬&quot;),2,true); //输出第一个 println!(&quot;{}&quot;,cat.1)} 解构使用模式匹配可以解构元组中的值 12let tup = (11, 22, 33);let (x, y, z) = tup; 访问使用var.n可以取出变量var种索引为n的元素 1234let tup = (11, 22, 33);println!(&quot;{}&quot;,tup.0); //11println!(&quot;{}&quot;,tup.1); //22println!(&quot;{}&quot;,tup.2); //33 数组数组声明12345let arr:[类型,长度] = [值1,值2,...]//省略类型声明let arr = [值1,值2,...]//初始化相同元素的数组，指定初始值let arr = [元素; 数量]; 说明： 数组的每个元素必须具有相同的类型，并且具有固定长度； 举例如下： 123fn main() { let arr = [1, 2, 3, 4, 5];} 访问使用[]访问数组元素 123let arr = [1, 2, 3, 4, 5];println!(&quot;{}&quot;,arr[0]); //1println!(&quot;{}&quot;,arr[1]); //2 补充： 如果索引超出数组边界会发生运行时错误 切片切片声明slice允许你引用字符串、集合中一段连续的元素序列，而不用引用整个集合 1&amp;变量[开始索引..结束索引] 说明： 切片索引的取值范围是左闭右开区间； 省略开始索引默认从索引0开始，省略结束索引默认到最大的索引，可以同时省略两个； 举例如下： 12345678fn main() { //集合切片 let arr = [1,2,3]; let slice1 = &amp;arr[1..2]; //字符串 let s = &quot;123&quot;; let slice2 = &amp;s[1..2];} 字符串切片字符串字面量就是切片的引用（&amp;str），可以发现他是个不可变引用，所以说字符串字面量是不可变的 1let s: &amp;str = &quot;字符串字面量&quot;; 字符串字面量会被硬编码写入二进制文件，程序执行时会存放在全局字面量区。执行上面代码时会将字面量的引用地址传递给变量s。 如果通过集合或字符串获得切片，当集合或字符串发生改变时，会导致内存重新分配，此时切片就无效了。比如下列代码会报错： 123456let mut s = String::from(&quot;1234546&quot;);let sli = &amp;s[2..4];println!(&quot;{}&quot;, sli);s.insert(3, 'a');// 这里会报错，因为s被更改，sli就无效了println!(&quot;{}&quot;, sli); 可变字符串rust中可变字符串使用String表示，创建代码如下： 1let s = String::from(&quot;字符串字面量&quot;); 上面代码运行时会将字面量拷贝到堆空间，然后将堆空间的地址传递给变量s。","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"},{"title":"宏","text":"声明式宏、 过程宏 rust中宏的目的就是一系列用来在编译阶段替换和生成目标文本的一种抽象的表达形式。可以减少编写的代码量，会根据预定义的规则堆代码进行展开。宏包括： 声明式宏； 过程宏； 声明式宏声明式宏允许我们编写一些类似match表达式的代码。宏会将一个值和包含相关代码的模式进行比较，通过匹配来复用代码。 宏定义每个声明式宏有一个名称和一或多条规则。每条规则包括匹配器和转码器两部分： 匹配器：描述匹配的规则； 转码器：描述匹配后执行的替代语句； 1234567891011121314//使用macro_rules!定义宏，后接宏的名称macro_rules! macro_name { //匹配器 =&gt; 转码器 (匹配模式) =&gt; ({ 代码 }); //匹配器声明时可以使用 ()、{}、[] 中任意一种 {匹配模式} =&gt; ({ 代码 }); //最后一个表达式的;可以省略； (匹配模式) =&gt; ({ 代码 })[;]}//调用类函数宏macro_name!(参数)//可以使用 ()、{}、[] 中任意一种调用，作用完全相同macro_name!{参数} 说明： 宏被调用时会根据声明从上到下依次匹配； 元变量在匹配器中可以使用 $名称:匹配段选择器 声明元变量，该语法格式匹配符合指定句法类型的rust句法段，并将其绑定到元变量名称上。格式如下 12345macro_rules! test { //元变量名称为name，匹配段选择器为tt //如果不加 $ 则 name:tt 会被识别成一个 tt 类型的整体 ($name:tt) =&gt; { ... }} 匹配段选择器包括 匹配段类型 匹配句法段 item 程序项，如函数定义，常亮声明等 block 块表达式，如 {…} stmt 语句（不匹配句尾的分号，会被当成分隔符，item语句除外），如let表达式 pat 匹配语句中的模式，模式匹配中的模式，如Some(a) expr 表达式，如Vec::new() ty 数据类型，如i32 ident 标识符或关键字，如 if path 类型表达式形式的路径， tt 一个token，是rust宏中的any类型，定界符为 ()、[] 或{} meta 属性，形如#[…]的属性中的内容 lifetime 生存期token，如`static vis 可能为空的可见性修饰符，如pub literal -?字面量表达式 由于宏定义式会使用到 {、}、(、)、[、]、=、&gt;等符号，如果在给宏传入的参数内容中也包含这些符号时，宏应该知道这些符号是否是界定符，所以对于各种类型添加了限制，以避免语义冲突： 匹配段选择器 允许的标记 stmt/expr =&gt;、;、, pat =&gt;、,、=、` ty/path {、[、=&gt;、,、&gt;、=、:、;、 vis , 其他 没有限制 补充： 可以表示类型开始的 token 有：{(, [, !, \\*,&amp;, &amp;&amp;, ?, 生存期, &gt;, &gt;&gt;, ::, 非关键字标识符, super,self, Self, extern, crate, $crate, _, for, impl, fn, unsafe,typeof, dyn} 上面的标记规则不一定绝对正确，因为宏还在发展 重复元有时我们可能需要像可变参数一样给宏传递多个类型相同的token，这时就需要用到重复元。重复元声明方式为： $(…) [分隔符] 重复运算符 首先需要重复的 token 放到 $(...) 中，然后可以选择性的后接一个分隔符，这个分隔符可以是除了定界符和重复运算符外的任何token，常用的有 ; 和 ,。最后添加一个重复运算符，重复元就声明完成了。重复运算符包括： *：表示任意数量的重复元； +：至少有一个重复元； ?：一个可选的重复元，可以出现零或一次，不能和分隔符一起使用； 举例如下： 1234//匹配以,分隔的任意数量个expr形式的token$( $i:expr ),*//匹配任意数量个expr,形式的token$( $i:expr, )* 宏的作用域声明式宏的作用域有两种： 文本作用域（text scope）：直接位于模块下，父模块可以覆盖/进入子模块； 基于路径的作用域（base-path scope）：使用 use 关键字后接路径引入的宏； 在调用宏时，如果不加限定符，那么首先会从文本作用域中寻找，如果找不到再从基于路径的作用域中寻找。如果使用限定符，则只在路径作用域中寻找，具体请看如下示例： 12345678use lazy_static::lazy_static; // 基于路径的导入.macro_rules! lazy_static { // 文本定义. (lazy) =&gt; {};}lazy_static!{lazy} // 首先通过文本作用域来查找我们的宏.self::lazy_static!{} // 忽略文本作用域查找，直接使用基于路径的查找方式找到一个导入的宏. 补充： 宏定义时如果调用与自身同名的宏，此时他只会调用自身，不会根据作用域寻找； 宏的导出和导入[macro_use][macro_use] 的作用有两个： 声明在模块上表示在该模块内定义的宏的作用域在模块关闭是不会结束 12345678#[macro_use]mod inner { macro_rules! m { () =&gt; {}; }}m!(); 声明在 extern crate 前表示从另一个 crate 中导入宏，导入的宏会被导入到 [macro_use] 预装入包里，可以被任何其他同名宏屏蔽，所以最后的那个宏才是最终会生效的 1234567//导入指定宏#[macro_use(lazy_static)] // 或者使用 #[macro_use] 来导入所有宏（不支持将 #[macro_use] 应用于模块上的情况）extern crate lazy_static;lazy_static!{}self::lazy_static!{} // 报错: lazy_static 没在 `self` 中定义，因为路径导入的已经被覆盖了 补充： 使用[macro_use]导入的宏必须被[macro_export]修饰 [macro_export]宏默认是不能被外部位置的，除非使用 [macro_export] 声明导出，相当于在当前 crate 顶部声明该宏 1234567891011121314self::m!();m!(); // OK: 基于路径的查找发现 m 在当前模块中有声明.mod inner { super::m!(); crate::m!();}mod mac { #[macro_export] macro_rules! m { () =&gt; {}; }} 卫生性一个宏在定义时可能会引用到其他的宏，这时会在该宏的调用位置上寻找。如果调用位置不包含引用到的宏，那么可能出现错误。为了解决这个问题，可以在路径的开头使用元变量 $crate，这会强制在宏的定义位置寻找引用的宏 12345678910111213141516171819//// 在 `helper_macro` crate 中.#[macro_export]macro_rules! helped { // () =&gt; { helper!() } // 这可能会导致错误，因为 'helper' 在当前作用域之后才定义. () =&gt; { $crate::helper!() }}#[macro_export]macro_rules! helper { () =&gt; { () }}//// 在另一个 crate 中使用.// 注意没有导入 `helper_macro::helper`!use helper_macro::helped;fn unit() { helped!();} $crate 指的是当前 crate，因此在引用非宏程序项时需要使用全限定模块路径 1234567891011#![allow(unused)]fn main() {pub mod inner { #[macro_export] macro_rules! call_foo { () =&gt; { $crate::inner::foo() }; } pub fn foo() {}}} 过程宏过程宏用于标注结构体、函数等，为其生成代码。过程宏包括： 函数式宏 属性宏 派生宏 定义过程宏必时须在定义过程宏的 crate 配置文件中声明： 12[lib]proc-macro = true proc-macro 提供了编写过程宏所需的各种类型和工具，使编写更加容易 类函数宏类属性宏自定义宏","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E5%AE%8F/"},{"title":"基础类型","text":"整数类型、浮点类型、布尔类型、字符类型 整数类型 长度（位） 有符号 无符号 8 i8 u8 16 i16 u16 32 i32（默认） u32 64 i64 u64 128 i128 u128 与计算机架构相同，若使用 64 位架构系统则为 64 位 isize usize 字面量格式 格式 格式 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 (仅限于 u8) b'A' 指定类型 100_i8 数字间可以使用_分割，增强可读性 浮点类型 类型 大小（位） 精度 f32 32 单精度 f64（默认） 64 双精度 布尔类型 类型 取值 大小（位） bool true/false 1 字符类型 类型 大小（字节） 编码 char 4 Unicode 由于使用Unicode编码，所以可以表示ASCII、中日韩文字、emoji等 类型转换as转换（数值类型）使用as关键字进行类型转换 12345678910111213//常规转换let a = 3.1 as i8;let b = 100_i8 as i32;let c = 'a' as u8; // 将字符'a'转换为整数，97//指针转换let p1: *mut i32 = ...;let first_address = p1 as usize; // 将p1内存地址转换为一个整数let second_address = first_address + 4; //i32类型占用4个字节，因此将内存地址 + 4let p2 = second_address as *mut i32; // 访问该地址指向的下一个整数p2unsafe { *p2 += 1;}assert_eq!(values[1], 3); TryInto转换（数值类型）rust内置的类型转换可能不满足情况，这时可以使用try_into()方法，try_into()方法会尝试进行一次转换，并返回一个 Result。 12345678910111213fn main() { let b: i16 = 1500; let b_: u8 = match b.try_into() { //类型转换成功 Ok(b1) =&gt; b1, //类型转换错误 Err(e) =&gt; { println!(&quot;{:?}&quot;, e.to_string()); 0 } };}","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"title":"控制流","text":"分支语句、循环语句、模式匹配 if 语句1234567if 布尔表达式 { //...}else if 布尔表达式 { //...}else { //...} if 表达式if作为表达式使用，需要有返回值。根据布尔表达式的结果返回值 1let v = if 布尔表达式 { 值1 } else { 值2 }; if let 控制流if let用于处理只match匹配一个模式的只而忽略其他模式的情况 12345678910let value = Some(5);if let Some(5) = value{ println!(&quot;匹配到值为5&quot;)}//等同于下面代码match value { Some(i) =&gt; {println!(&quot;匹配到值为5&quot;)} _ =&gt; {}} 说明： 可以认为 if let 是 match 的一个语法糖； match 语句match用于和enum类型结合使用。当 match 表达式执行时，它将结果值按顺序与每一个分支的模式相比较，如果匹配就执行 123456match rgb { 匹配模式 =&gt; { /**默认代码*/ }, //... //使用_占位符作为通配模式，可以匹配任意值 _ =&gt; { /**默认代码*/ }} 说明： 不需要使用break代码执行后会自动跳出； 枚举的参数不同，也会影响模式的匹配 举例如下： 1234567891011121314151617181920212223fn main() { let rgb = Color::RGB(255,255,255); match rgb { //匹配模式时参数也必须完全相同 Color::RGB(255,255,255) =&gt; { println!(&quot;RGB&quot;) }, Color::RGBA(255,255,255,0.5) =&gt; { println!(&quot;RGBA&quot;) }, Color::HSL(100,0.23,0.5) =&gt; { println!(&quot;HSL&quot;) }, Color::HSLA(100,0.23,0.5,0.5) =&gt; { println!(&quot;HSLA&quot;) }, _ =&gt; { println!(&quot;RGBA&quot;) } }}enum Color{ //红、绿、蓝 RGB(i32,i32,i32), //红、绿、蓝、透明度 RGBA(i32,i32,i32,f32), //色调、饱和度、亮度 HSL(i32,f32,f32), //色调、饱和度、亮度、透明度 HSLA(i32,f32,f32,f32)} match 表达式match可以当作表达式使用，只需要在语句最后加上一个返回值即可，接上上面例子 123456789101112let rgb = Color::RGB(255,255,255);let res = match rgb { Color::RGB(255,255,255) =&gt; { println!(&quot;RGB&quot;); 1 }, Color::RGBA(255,255,255,0.5) =&gt; 2, Color::HSL(100,0.23,0.5) =&gt; 3, Color::HSLA(100,0.23,0.5,0.5) =&gt; 4, _ =&gt; 5}; 补充： 返回值可以是任意类型； 如果只有一个返回值，可以省略{}； 因为是表达式，所以表达式后必须要加一个;符号； 匹配 Option&lt;T&gt;123456789let option = Some(5);let res = match option { None =&gt; None, //此处i指代Option&lt;T&gt;中存储的类型为T的变量，在后面可以使用变量i Some(i) =&gt; { println!(&quot;option内部的值为{}&quot;,i); Some(i+1) },}; loop 循环基本语法123loop { //...} 补充： loop循环默认情况下不会跳出，需要配合break和continue使用 break：结束循环； continue：跳过这个循环迭代中的任何剩余代码，并转到下一个迭代； 举例如下： 123456789101112fn main() { let mut number = 0; loop { //打印数字 println!(&quot;{}&quot;,number); number = number+1; if number&gt;=5 { //跳出循环 break } }} 循环标签循环标签声明在loop前面，格式为 1'标签名 多层循环时可以使用循环标签配合break和continue达到跳出循环的目的 123456789'mark:loop { loop { println!(&quot;{}&quot;,number); number = number+1; if number&gt;=5 { break 'mark } }} for 循环for循环主要用来遍历集合中的元素 123for 变量 in 集合 { //...} 补充： 使用while也可以遍历数组，不过for循环遍历集合速度更快，也更安全； 举例如下： 123456fn main() { let arr = [1, 2, 3, 4, 5]; for element in arr { println!(&quot;{}&quot;,element) }} 遍历区间使用 (start...end)遍历start~end-1之间的数 12345678910fn main() { //可以省略 for element in 1..3 { println!(&quot;{}&quot;,element) } //反向遍历 for element in (1..3).rev() { println!(&quot;{}&quot;,element) }} while 循环123while 条件表达式 { //...} 举例如下： 1234567fn main() { let mut number = 0; while number &lt; 5 { println!(&quot;{}&quot;,number); number += 1; }}","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"模块系统","text":"package、crate、模块 一个package分为多个crate 一个crate分为多个模块 模块通过路径相互引用 packagepackage是Cargo 的一个功能，它允许你构建、测试和分享 crate。一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate。 package 的内容一个package中 至多包含一个库crate（ lib crate）； 可以包含任意个可执行 crate； 可以包含任意多个二进制 crate； 至少包含一个 crate； crate一个crate包含多个模块，这些模块会形成一个树结构，这个树的根称为crate root crate rootCargo遵循如下规则：src/main.rs 和 src/lib.rs 被称为 crate root。crate root文件将由 Cargo 传递给 rustc 来实际构建库或者二进制项目。Cargo会根据这两个文件生成与其同名的二进制 crate 。 crate 分类main crate：可执行 crate ，包含main函数的可执行的crate，一般为main.rs文件，用来编写程序启动执行的代码； lib crate：库 crate 最终会被编译为一个可被连接的库，一般为lib.rs文件，用于组装模块树。 模块一个crate中的模块会呈现一个树状的结构，使用时通过::符号进行引用。模块默认是私有的，其他位置想要引用需要先暴露模块。 创建模块使用 cargo new --lib 包名命令创建一个package，并在其 lib.rs 文件下写入如下代码 123456789101112131415//通过mod定义一个模块mod model { //子模块1 mod sub_model_1 { //定义项包括函数、结构体、枚举、常量、trait等 fn fun1() {} struct S {} } //子模块2 mod sub_model_2 { fn fun2() {} //... }} src/main.rs 和 src/lib.rs 这两个文件中任意一个的内容会构成名为 crate 的模块，且该模块位于 crate 的被称为 模块树 的模块结构的根部。上述代码创建的 模块树 结构如下： crate model sub_model_1 fun1 S sub_model_2 fun2 其中sub_model_1和sub_model_2模块互为兄弟，他们的父辈是model。整个模块树都是在一个名为crate的隐式模块下。 引入模块通过以下关键字引入和暴露模块： 暴露模块：pub 模块名； 引入模块：use 模块路径 [as 新名称]； 模块重命名：use 模块路径 as 新名称； 嵌套路径：use 模块路径::[self,路径1,...]，用于省略多个路径的相同部分。内部路径可以使用self，表示当前路径； 重导出名称：pub use 模块路径，通过use导入模块后在新作用域是私有的，通过pub暴露给外部； 路径是用来给例如结构体、函数或模块等项命名的，分为： 绝对路径：从 crate root 开始，以 crate 名或者字面量 crate 开头； 相对路径：从当前模块开始，以 self、super 或当前模块的标识符开头； glob 运算符：如果希望将一个路径下所有的公有定义全部引入，可以在路径后加::*； 单文件模块举例如下： 12345678910111213141516171819202122232425262728mod model { mod sub_model_1 { //设置为pub pub fn fun1() {} } //子模块2 mod sub_model_2 { //将sub_model_1模块引入作用域 use crate::model::sub_model_1; //为模块重命名 use super::sub_model_1 as model1; fn fun2(){ //绝对路径，调用同一个文件中crate::可以省略 crate::model::sub_model_1::fun1(); //直接引用模块名，需要先使用use语句引入模块 sub_model_1::fun1(); //引用重命名后的模块 model1::fun1(); //super父模块 super::sub_model_1::fun1(); //self兄弟模块 self::sub_model_1::fun1() } }} 说明： 直接通过引用模块名来引用模块内容时，被引用的内容必须使用 pub 暴露； 多文件模块放在不同文件的模块是没有关系的，想要相互调用或进行模块的组合可以使用mod关键字声明，以此来组装模块树。为了项目结构简介一般会使用lib.rs组装模块，外部可以使用包名访问呢lib暴露出的模块。 src/model1.rs 1234567pub mod model1_sub1{ pub fn fun(){}}pub mod model1_sub2{} src/model2.rs 1234567pub mod model2_sub1{}pub mod model2_sub2{} main 组装示例src/main.rs： 123456789101112//声明两个模块，其具体内容在src/model1.rs和src/model2.rs文件中mod model1;mod model2;//引入模块use model1::model1_sub1::fun as fun;use model1::model1_sub2;fn main() { fun()} lib 组装示例src/lib.rs： 123//必须使用pub声明外部才能调用pub mod model1;pub mod model2; 外部通过包名调用 12//包名为 HelloHello::model1::model1_sub1::fun() crate 相互调用lib.rs 的 crate 默认为包名，所以 main.rs 可以通过包名来引入 lib.rs 中的 mod src/main.rs： 1use 包名::XXX","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"},{"title":"类型系统","text":"变量、常量 变量rust中默认变量时不可变的，如果希望变量可变需要使用mut关键字 1234567891011121314fn main() { //声明不可变变量 let v1 = 0; println!(&quot;{}&quot;,v1); //声明可变变量 let mut v2 = 0; //赋值 v2 = 1; println!(&quot;{}&quot;,v2); //声明类型 let v3:i32 = 0;} rust中输出使用{}作为占位符； 变量使用let声明，可以省略变量类型的声明； 不可变变量不能被二次赋值； 遮蔽当前后两次定义了同名变量时，我们使用的是第二个值，这种现象称为遮蔽 12345fn main() { let v = 0; let v = 1; println!(&quot;{}&quot;,v) //1} 遮蔽只适用于变量，而不是常量； 常量常量使用const关键字声明 123456789fn main() { //声明常量 const c1:u32 = 0; //常量表达式 const c2:u32 = 60 * 60 * 3; //报错，因为表达式中存在变量a let a = 0; const c3:u32 = 60 * 60 * a;} rust中常量必须注明类型； 常量只能被赋值为常量表达式，否则会报错；","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"错误处理","text":"不可恢复错误、可恢复错误 不可恢复的错误：panic!不可恢复错误一般指的是数组越界等bug。panic! 宏用来处理错误。执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。 12345//手动执行panicpanic!(&quot;crash and burn&quot;);//遇到错误后会自动执行paniclet v = vec![1, 2, 3];v[99]; 可恢复错误：Result可恢复错误指的是没有严重到需要停止程序的错误，例如打开文件不存在。使用Result枚举来处理 12345678// T 代表成功时返回的数据类型// E 代表失败时返回的数据类型enum Result&lt;T, E&gt; { //成功返回 Ok(T), //失败返回 Err(E),} 错误处理1234567891011121314151617181920212223242526272829303132let result : Result&lt;File,Error&gt; = File::open(&quot;test.txt&quot;);//处理错误方式1let t = match result { Ok(file) =&gt; file, Err(error) =&gt; { panic!(&quot;错误为：{}&quot;,error) }};//处理错误方式2：匹配不同类型错误let t = match result { Ok(file) =&gt; file, Err(error) =&gt; match error.kind(){ //通过ErrorKind::XXX匹配不同类型错误 ErrorKind::NotFound =&gt; {//匹配到文件未找到错误 //处理错误：创建文件 match File::create(&quot;hello.txt&quot;) { Ok(fc) =&gt; fc, Err(e) =&gt; panic!(&quot;文件创建失败&quot;), } }, //其他错误 other_error =&gt; panic!(&quot;其他错误&quot;), }};//处理错误方式3：失败时调用panic!可以简写为：unwrap 和 expect//unwrap：如果Result值是Ok，则返回Ok中的值。否则调用 panic!。let f = File::open(&quot;hello.txt&quot;).unwrap();//expect：expect与unwrap类似，只不过expect可以自定义错误信息let f = File::open(&quot;hello.txt&quot;).expect(&quot;自定义错误信息&quot;); 错误传播当编写一个可能会失败的函数时，除了在函数中处理错误外，还可以选择将错误暴露出出去，这称为 传播错误 ，有两种方式： 使用match表达式 使用 ? 运算符 12345678910111213141516171819202122232425262728//错误传播方式1：使用match表达式fn error_one(s:String) -&gt; Result&lt;String,Error&gt;{ //读文件 let f = File::open(&quot;hello.txt&quot;); //失败返回错误，成功获取file对象 let mut f = match f { Ok(file) =&gt; file, Err(e) =&gt; return Err(e), }; let mut s = String::new(); //失败返回错误，成功返回OK（包含文件内容） match f.read_to_string(&amp;mut s) { Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), }}//错误传播方式2：使用 ? 运算符fn error_two(s:String) -&gt; Result&lt;String,Error&gt;{ //失败返回错误，成功获取file对象 let mut f = File::open(&quot;hello.txt&quot;)?; let mut s = String::new()?; //失败返回错误，成功返回文件内容 f.read_to_string(&amp;mut s)?; Ok(s)} 补充： main()函数的返回值有类型限制，包括()和Result&lt;T, E&gt;；","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"title":"集合","text":"Vector、String、Map VectorVector的类型为Vec&lt;T&gt;，用来存储一系列类型相同的值的列表。 创建12345//创建空的Vector，因为没有值，所以无法推断类型，必须显式声明let v: Vec&lt;i32&gt; = Vec::new();//使用宏传创建，这里会进行类型推断，可以不声明类型let v = vec![1, 2, 3]; 添加想要改变 vector 的值，变量必须使用 mut 声明； 123let mut v = Vec::new();//在结尾天添加新值v.push(5); 如果push()方法的参数为具有所有权的类型，那么所有权也会转移给vector 12345let mut v = Vec::new();let d = String::from(&quot;123&quot;);//在结尾天添加新值v.push(d);println!(&quot;{}&quot;,d);//这里会报错 读取12345let v = vec![1, 2, 3, 4, 5];//取索引为2的值let i = &amp;v[2];//返回一个Option&lt;&amp;T&gt;，如果正常取出，其内部保存着索引为2的值，否则会其内部是Nonelet i = v.get(2) 获取的 vector 中元素的不可变引用会在添加元素后失效，因为在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况 1234567let mut v = vec![1, 2, 3, 4, 5];let first = &amp;v[0];v.push(6);//上面代码都正常执行println!(&quot;The first element is: {}&quot;, first);//这一句会报错 遍历1234567891011//只访问不用声明mutlet v = vec![100, 32, 57];for i in &amp;v { println!(&quot;{}&quot;, i);}//想要修改值，需要声明mutlet mut v = vec![100, 32, 57];for i in &amp;mut v { *i += 50;} 存储多种类型因为 Vector 只能存储一种类型，如果想要存储多种类型，可以结合枚举来使用，因为枚举中的值都是当前枚举类型 123456789fn main() { let vec = vec![Color::Green, Color::Yellow, Color::Blue];}enum Color{ Yellow, Blue, Green,} 常用方法 方法 参数 返回值 说明 vec.pop() 无 移除最后一个元素 StringRust中字符串（String）是由标准库提供的。和字符串切片有所不同，字符串切片类型为str，类似于字面量，是被存储到程序的二进制输出中的。他们的共同点是都是 UTF-8 编码。str一般是定长的，而String是变长的并且具有所有权。标准库中提供了很多字符串类型，他们都由String或str结尾：比如 OsString、OsStr、CString 和 CStr，他们用于以不同形式存储内容 创建字符串12345678//创建一个空字符串let mut s = String::new();//通过字符串切片创建字符串let s = &quot;abc&quot;.data.to_string();//根据字面量创建字符串let s = String::from(&quot;字符串&quot;); 追加123456789101112let mut s = String::from(&quot;字符串&quot;);//追加字符串切片s.push_str(&quot;ab&quot;);//追加字符s.push('c');//使用+let s1 = String::from(&quot;Hello, &quot;);let s2 = String::from(&quot;world!&quot;);//相当于调用了add(mut self, other: &amp;str)函数//self没有使用&amp;，执行完后s1会被释放，&amp;s2会被解引用强制转换为&amp;str类型let s3 = s1 + &amp;s2;println!(&quot;{}&quot;,s3); 索引Rust不支持索引，其原因如下： String 不能保证O(1)的性能，因为必须从开头到索引位置遍历来确定有多少有效的字符； 每个utf-8类型的字符长度不同，如果根据字节返回的话可能没有意义； 遍历12345678//按utf-8字符返回for c in &quot;नमस्ते&quot;.chars() { print!(&quot;{} &quot;, c);//न म स ् त े}//按照字节返回for b in &quot;नमस्ते&quot;.bytes() { print!(&quot;{} &quot;, b); //224 164 165 135} MapHashMap&lt;K, V&gt;用来存储键值对数据，通过哈希函数来实现映射 创建12345678//创建空的maplet map = HashMap::new();//使用vector创建maplet keys = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];let values = vec![10, 50];//这里HashMap&lt;_, _&gt;是必要的，用于向collect()声明返回类型，因为collect()方法可以返回多种不同数据类型let map: HashMap&lt;_, _&gt; = keys.iter().zip(values.iter()).collect(); 插入对于i32这种实现了Copy trait 的类型可以拷贝进HashMap，但是拥有所有权的类型在插入到HashMap中时，所有权也会被转移给HashMap 12345let mut map = HashMap::new();//插入或覆盖map.insert(&quot;key&quot;,&quot;value&quot;);//在key不存在的时候插入map.entry(&quot;key&quot;).or_insert(value); 遍历12345678let mut map = HashMap::new();map.insert(String::from(&quot;k1&quot;), 1);map.insert(String::from(&quot;k2&quot;), 52);for (key, value) in &amp;map { println!(&quot;{}: {}&quot;, key, value);}","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"},{"title":"面向对象","text":"结构体、泛型、trait、枚举类 结构体结构体声明定义12345//定义结构体struct 结构体名 { 变量名:类型, //...} 举例如下： 1234struct Cat{ name:String, age:i32,} 初始化初始化结构体需要为每个字段进行赋值 12345678910111213//初始化let s = 结构体名{ 变量名: 值 //...}//使用其他结构体对象初始化let s = 结构体名{ 变量名: 值 //... //.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。 ..结构体对象} 补充： 初始化结构体时初始化参数的所有权也会被传递进结构体，所以之后都无法使用； 如果希望初始化参数不丧失所有权，可以使用数据的引用，并且要加上声明周期。如果不指定声明周期，则是无效的； 举例如下： 1234567891011let c = Cat{ name:String::from(&quot;魔力猫&quot;), age:3,};//使用其他结构体对象初始化let c2 = Cat{ name:String::from(&quot;喵呜&quot;), ..c};println!(&quot;{}&quot;, c2.name); //喵呜 字段调用字段通过.调用结构体的字段 123456let c = Cat{ name:String::from(&quot;魔力猫&quot;), age:3,};//访问结构体字段值c.name 字段简写初始化结构体时，如果变量名和字段名相同，可以简写 123456let name = String::from(&quot;魔力猫&quot;);let c = Cat{ //相当于name:name name, age:3,}; 方法定义123456789101112131415//impl表示与结构体关联impl 结构体名称 { //&amp;self类似于this，等同于self: &amp;Self //&amp;表示拿到的是引用，也可以不指定，但这会导致方法执行完后对象被回收 fn 方法名(&amp;self,其他参数){ //... } //如果不指定self，调用时需要通过如下形式调用 结构体名称::方法(...) fn 方法名(参数列表){ //... } //其他方法...} 补充： rust不需要像c++必须使用-&gt;调用指针上的方法，rust有自动引用和解引用功能，会在对象前自动添加&amp;、&amp;mut 或 *； 所有在 impl 块中定义的函数被称为关联函数，因为它们与 impl 后面命名的类型相关； 举例如下： 12345678910111213141516171819202122232425262728fn main() { let c = Cat{ name:String::from(&quot;魔力猫&quot;), age:3, }; c.call(); Cat::call2(String::from(&quot;魔力猫&quot;))}struct Cat{ name:String, age:i32,}//impl表示与Cat关联impl Cat { //声明&amp;self fn call(&amp;self){ println!(&quot;{}在喵喵叫&quot;,self.name); } //不声明&amp;self fn call2(name:String){ println!(&quot;{}在喵喵叫&quot;,name); }} 元组结构体元组结构体用于给整个元组起一个名字，并使元组成为与其他元组不同的类型： 元组结构体没有具体的字段名，只有字段的类型 元组结构体对象通过.index取值 1struct 名称(类型, 类型, ...); 举例如下： 1234567struct Color(i32, i32, i32);fn main() { let black = Color(0, 0, 0); //通过索引取值 println!(&quot;{}&quot;,black.0)} 单元结构体没有任何字段的结构体称为单元结构体 类似于元组的() 类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用 1struct 名称; 举例如下： 12345struct Name;fn main() { let name = Name;} 泛型泛型的声明格式为：&lt;占位符&gt;其中占位符可以有多个。泛型有如下形式： 泛型函数 泛型结构体 泛型枚举 泛型方法（结构体或枚举的声明方法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748fn main() { //泛型函数 fun(3); //泛型结构体 let p = Point{ x:5, y:5 }; //泛型方法 let r = p.x(); //泛型枚举 Response::Success(&quot;成功&quot;);}//泛型函数fn fun&lt;T&gt;(t:T) -&gt; T{ //... return t;}//泛型结构体struct Point&lt;X,Y&gt;{ x:X, y:Y, //...}//泛型方法//声明泛型impl&lt;X,Y&gt; Point&lt;X,Y&gt; { fn x(&amp;self) -&gt; &amp;X { &amp;self.x }}//使用具体类型impl Point&lt;i32,i32&gt; { //相加 fn add(&amp;self) -&gt; i32 { self.y+self.y }}//泛型枚举enum Response&lt;T&gt;{ Success(T), Failure(T)} traittrait 用于定义一个实现某些目的所需的行为（方法）的集合，类似于接口 声明 trait使用 trait 关键字来声明一个 trait，后面是 trait 的名字。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名 12345trait 名字{ //方法前面，没有实体 fn fun(&amp;self,s:String)-&gt;String; //其他方法前面...} 实现 trait使用impl实现trait，格式为：impl trait名 for 类型 相干性：只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait； 12345678910111213141516171819202122//声明traittrait CatBehavior{ fn get_name(&amp;self)-&gt;String; fn get_age(&amp;self)-&gt;i32;}//声明结构体struct Cat{ name:String, age:i32,}//为结构体实现traitimpl CatBehavior for Cat { fn get_name(&amp;self) -&gt; &amp;String { &amp;self.name } fn get_age(&amp;self) -&gt; i32 { &amp;self.age }} 默认实现可以在trait声明默认实现，这样在impl中就可以根据需求进行覆盖 1234567891011121314151617181920trait CatBehavior{ //提供默认实现 fn get_name(&amp;self)-&gt;String{ String::from(&quot;你滴名字&quot;) } fn get_age(&amp;self)-&gt;i32;}struct Cat{ name:String, age:i32,}impl CatBehavior for Cat { fn get_age(&amp;self) -&gt; i32 { self.age } //get_name方法没有重写} trait boundtrait 可以作为类型，可作为以下内容： 函数参数类型 函数返回值类型 使用+指定多个trait 使用泛型指定多个trait 使用where指定泛型，优化可读性 1234567891011121314151617181920212223242526272829303132333435363738//定义traittrait Behavior{ fn fun1(&amp;self)-&gt;String;}trait Idea{ fn fun2(&amp;self)-&gt;String;}//trait作为函数参数fn print_name1(b:impl Behavior){ println!(&quot;{}&quot;,b.fun1())}//等同于fn print_name2&lt;b: Behavior&gt;(c:T){ println!(&quot;{}&quot;,b.fun1())}//返回trait类型fn return_name(ib: impl Behavior)-&gt;impl Behavior{ ib}//通过+指定多个trait，表示两个都要实现fn print_name3(ib: impl Behavior + Idea){ println!(&quot;{}&quot;,ib.fun2())}//通过泛型指定多个traitfn print_name4&lt;T:Behavior + Idea&gt;(ib: T){ println!(&quot;{}&quot;,ib.fun2())}//使用where指定泛型fn print_name5(ib: T,b:B)-&gt;Stringwhere T:Behavior + Idea, B:Behavior{ ib.fun2(); b.fun2()} 枚举类枚举声明123456789enum 枚举名称{ //可以将任意类型的数据放入枚举成员中，甚至是另一个枚举 成员名称(类型,类型,...) //...}impl 枚举的名称 { //定义方法} 说明： 类型是可选项，如果没有类型可以省略()； 如果写了类型可以在声明时传入参数，也可以不传递； 可以使用impl为枚举类型声明方法； 举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344fn main() { //通过 :: 获取枚举类的字段 let c = Animal::Cat; //类型为 Color let d = Animal::Dog; //调用方法 c.test(); //带参数的枚举 let rgb = Color::RGB(255,255,255); let rgba = Color::RGBA(255,255,255,0.5); let hsl = Color::HSL(100,0.23,0.5); let hsla = Color::HSLA(100,0.23,0.5,0.5);}//颜色表示形式不同，参数也不同enum Color{ //红、绿、蓝 RGB(i32,i32,i32), //红、绿、蓝、透明度 RGBA(i32,i32,i32,f32), //色调、饱和度、亮度 HSL(i32,f32,f32), //色调、饱和度、亮度、透明度 HSLA(i32,f32,f32,f32)}//为Color声明方法impl Color { fn test(&amp;self){ //... }}enum Animal{ Cat, //() Dog(),}//声明枚举类型的方法impl Animal { fn fun(){}} Option 类型rust中没有空值，但有一个可以表示存在或不存在概念的类型：枚举Option&lt;T&gt;，标准库中定义如下： 123456enum Option&lt;T&gt; { //存在一个值，该值类型为T Some(T), //该值不存在 None,} Rust会确保我们使用值之前就明确处理过了为空的情况，所以使用时我们不需要该值是否为空。","link":"/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Rust/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"原始类型","text":"数字类型、布尔类型、字符串、标识 数字类型 类型 取值范围 number 5×10^-324^ ~ 1.79×10^308^ ts中所有数字都是浮点数 1let n:number = 3.1415926 进制表示： 二进制：0b开头 八进制：0o开头 十六进制：0x开头 布尔类型 类型 取值范围 boolean true/false 1let b:boolean = true 字符串字符串声明使用单引号和双引号声明，可以混合使用 12let 字符串名:string = &quot;字符串&quot;let 字符串名:string = '字符串' 举例如下 1let str:string = &quot;hello&quot; 模板字符串使用反引号声明模板字符串，可以使用${expr}形式内嵌表达式 12let name: string = `马牛逼`;let sentence: string = `Hello, my name is ${ name } 标识symbol是ES6引入的类型，因为ES5中对象的属性名和方法名都是字符串，很容易造成属性名或方法名的冲突，所以引入了symbol类型。每个symbol都是独一无二的 symbol声明symbol通过symbol()创建，前面不能加new 1234567891011121314151617181920212223242526//创建symbollet s = Symbol(&quot;sss&quot;)//作为属性和方法的名称时需要声明为常量const propName = Symbol()const funName = Symbol()//每个symbol对象都是唯一的console.log(propName==funName) // falseclass ClassName{ //作为方法名 [funName](){ console.log(&quot;方法&quot;) } //作为属性名 propName:String = &quot;属性&quot;}//使用对象let c = new ClassName()//调用属性c[propName]//调用方法c[funName]() 内置方法 方法名 说明 Symbol.hasInstance 用来识别一个对象是否是其实例 Symbol.match 正则表达式用来匹配字符串 Symbol.iterator 被for-of语句调用。返回对象的默认迭代器 Symbol.replace 正则表达式用来替换字符串中匹配的子串 Symbol.search 正则表达式返回被匹配部分在字符串中的索引 Symbol.split 正则表达式来用分割字符串 Symbol.toPrimitive 把对象转换为相应的原始值 Symbol.toStringTag 返回创建对象时默认的字符串描述 内置属性 属性名 说明 Symbol.species 函数值，为一个构造函数。用来创建派生对象 Symbol.isConcatSpreadable 布尔值，表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开 Symbol.unscopables 对象，它自己拥有的属性会被with作用域排除在外","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/"},{"title":"复杂类型","text":"数组、字典、元祖、对象、函数 数组数组声明123let 数组名:类型[] = [?,?,...]let 数组名:Array&lt;类型&gt; = [?,?,...] 举例如下 1let is:number[] = [1,2,3] 访问数组使用索引访问 1array[index] 举例如下： 1number[0] 解构解构语法 123456let input = [1, 2];//数组解构赋值let [first, second] = input;//相当于let first = input[0];let second = input[1]; 可以作用在函数参数上 12345function f([first, second]: [number, number]) { console.log(first); console.log(second);}f(input); 可以使用...接收剩余变量 123456//other为[2,3,4]let [first, ...other] = [1, 2, 3, 4];//忽略后面元素let [first] = [1, 2, 3, 4];//跳过元素let [, second, , fourth] = [1, 2, 3, 4]; 展开展开可以将一个数组中的元素取出来 123let first = [1, 2];let second = [3, 4];let both = [0, ...first, ...second, 5]; //[0,1,2,3,4,5] 只读数组TypeScript具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改 123let readOnlyArr:ReadonlyArray&lt;number&gt; = [1,2,3,4]readOnlyArr[0] = 1 //报错 字典字典声明1234567let map = new Map();//可以以数组的格式来传入键值对let map = new Map([ [&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]); 常用方法 方法名 说明 map.clear() 移除 Map 对象的所有键/值对 map.set() 设置键值对，返回该 Map 对象 map.get() 返回键对应的值，如果不存在，则返回 undefined map.has() 返回一个布尔值，用于判断 Map 中是否包含键对应的值 map.delete() 删除 Map 中的元素，删除成功返回 true，失败返回 false map.size 返回 Map 对象键/值对的数量 map.keys() 返回一个 Iterator 对象， 包含了 Map 对象中每个元素的键 map.values() 返回一个新的Iterator对象，包含了Map对象中每个元素的值 元组元组表示一个一致数量和类型的数组，个元素类型不必相同 元组声明1let 元组名:[类型1,类型2,...] = [?,?,...] 举例如下 1let x: [string, number] = ['hello', 10] 访问1元组名[索引] 举例如下 12//x是一个长度为2的元组x[0] = 'world' 枚举枚举类型类似于定义了一组常量 枚举声明使用enum关键字声明枚举类型 12345[declare] [const] enum 枚举名{ 值[=编号], 值[=编号], //...} 枚举的值可以分为数字枚举和字符串枚举，两者可以混合使用： 数字枚举：枚举值若没有赋值则默认为数字，编号从0开始顺序递增，也可以手动赋值 字符串枚举：值为字符串，字符串枚举不能放在未初始化的数字枚举前面 举例如下 123456789101112131415enum Color { Red = 1, Green, //2 Blue, //3 name = &quot;颜色&quot;}//多次声明可以在外部对已存在的枚举进行扩展//在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式enum Color{ //必须初始化 name = &quot;颜色&quot;}let c: Color = Color.Green; 说明： 可以通过表达式对枚举进行初始化，会在编译阶段求值，若求得的值为NaN或Infinity则会报错 常量枚举使用const关键字声明常量枚举，常量枚举不能通过表达式进行初始化 123456const enum Color { Red=2*2, //报错 Green, Blue, name = &quot;颜色&quot;,} 外部枚举使用declare关键字声明外部枚举，在外部枚举内没有初始化。 12345678enum Color { Red, Green, Blue,}declare enum Color{ name = &quot;颜色&quot;} 访问枚举可以使用.或者[编号]访问枚举类型 123456789enum Color {Red = 1, Green, Blue}//通过属性或索引方式获取值let c1: Color = Color.Green;let c2: Color = Color[2] //获取值为2的枚举//反向映射let red = Color.Redlet c3 = Color[red] 对象对象声明1let o:object = {属性:值,...} 举例如下： 1let cat:object = {name:&quot;迪莫&quot;,age:3} 访问123let cat = {catName:'迪莫',age:3}cat.catNamecat['catName'] 解构解构语法 123456let cat = {catName:'迪莫',age:3}//这里变量要与对象的key相同let {catName,age} = cat//手动指定类型let {catName,age}:{catName:string,age:number} = cat 属性重命名 12//分别命名为n和alet {catName:n,age:a} = {catName:'迪莫',age:3} 使用...接收剩余变量 12//other为{ age: 3, weight: 20 }let {catName,...other} = {catName:'迪莫',age:3,weight:20} 函数函数声明1234function 方法名(参数名:类型,...)[:返回值类型]{ //... [return ...]} 说明： 如果不声明返回值类型，会根据return语句自行推断； 如果函数没有返回值，默认返回undefined； 参数列表可以使用解构； 举例如下 1234567function fun(name: string){ console.log(&quot;hello&quot;) return name}let res = fun(&quot;你好&quot;)console.log(res) 参数列表可选参数可以通过?声明可选参数，可选参数必须在必须参数后面； 123456function fun(name: string,age?:number ){ console.log(&quot;hello&quot;)}fun(&quot;你好&quot;) 剩余参数可以使用...接收剩余参数 12345function fun(name: string,...other:any[]){ console.log(&quot;hello&quot;)}fun(&quot;你好&quot;,1,2,&quot;3&quot;) this方法中的this的值根据调用的位置而定 12345678let o = { data:&quot;o-data&quot;, creatFun:function(){ console.log(this.data) }}//此时内部的this是oo.creatFun() 将return的值改为一个方法 1234567891011let o = { data:&quot;o-data&quot;, creatFun:function(){ return function(){ console.log(this.data) } }}let f = o.creatFun()//此时this指的是windowf() 综上所述，方法写完后我们并不确定调用时this的值究竟会是多少，如果想确定this值需要使用箭头函数 箭头函数 箭头函数能保存函数创建时的 this值，而不是调用时的值 12345678910111213let o = { data:&quot;o-data&quot;, creatFun:function(){ return ()=&gt;{ //此时this值永远都指向o console.log(this.data) //object console.log(typeof this) } }}let f = o.creatFun()f() 匿名函数匿名函数声明方式和普通类型类似，只不过不需要写方法名 1234let f:Function = function (name: string):string{ console.log(&quot;hello&quot;) return name} 函数重载ts中函数的重载不只发生在类中，在顶级区域下也可以重载。但ts中的函数重载是个垃圾东西，他需要让参数的个数一样才可以，然后声明多个函数最终在一个函数里编写函数实现 12345function fun(p1:string,p2:number):any;function fun(p2:number,p1:string):string;function fun(p1:any,p2:any):any{ //函数实现} 可以变化的地方有参数类型和返回值类型","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/"},{"title":"断言","text":"类型断言、非空断言 类型断言使用as或&lt;类型&gt;两种形式声明类型断言。类型断言类似于类型转换目的是让编译器知道结果是什么类型，在编译时会被删除，所以运行时是没有类型断言的 1234//&lt;&gt;方式&lt;目标类型&gt;变量//as方式变量 as 目标类型 举例如下： 1234let s:any = &quot;123&quot;let s1 = s as stringlet s2 = &lt;string&gt;sconsole.log(typeof s1,typeof s2) //string string 非空断言 在变量前加?，表示该变量可以不赋值，若不赋值默认为undefined； 在变量前加!，表示该变量不可为nullor undefined； 1234567//y是可选的function funName(obj: { x!: number, y?: number }) { console.log(obj.x) console.log(obj.y)}funName({x:3})","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E6%96%AD%E8%A8%80/"},{"title":"控制流","text":"判断语句、循环语句、跳转语句 判断语句if 语句基本语法1234567if(布尔表达式){ //...}else if(布尔表达式){ //...}else{ //...} switch 语句基本语法12345678910111213//表达式必须是一个整型或枚举类型switch(表达式){ //常量表达式必须是一个常量或字面量，必须和上面表达式中的类型相同 case 常量表达式: //... break case 常量表达式: //... break //default可选 default: //...} 循环语句for 循环123for(初始化;条件;迭代){ //...} for..in 循环和for..of 循环for..in和for..of作用都是遍历可迭代的对象 （一些内置的类型如 Array，Map，Set，String，Int32Array，Uint32Array等都已经实现了各自的Symbol.iterator），区别就是for..of遍历的是对象的value，而for..in遍历的是对象的key 12345678910111213141516171819let arr = [1,2,&quot;s&quot;]let map = new Map([ [&quot;k1&quot;,&quot;v1&quot;], [&quot;k2&quot;,&quot;v2&quot;],])//offor(let [key,value] of map){ console.log(key,value)}for(let entry of arr){ console.log(key,value)}//infor(let entry in arr){ console.log(entry) //0,1,2} forEach和every循环1234567891011121314151617let arr = [1,2,3,&quot;s&quot;]arr.forEach((value,index,col)=&gt;{ // value: 当前值 // index：当前索引或key // col: 遍历对象 console.log(value,index,array)})arr.every((value,index,col)=&gt;{ // value: 当前值 // index：当前索引 // col: 遍历对象 console.log(value,index,array) return true //是否继续，返回false会停止迭代}) while 循环1234while(条件){ //...} do 循环1234do{ //...}while(条件); 跳转语句break 语句 终止并跳出循环 它可用于终止 switch 语句中的一个 case continue 语句 continue 会跳过当前循环中的代码，强迫开始下一次循环","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E6%B5%81/"},{"title":"模块系统","text":"模块、命名空间 外部模块：模块 内部模块：命名空间 模块定义在一个模块里的变量、函数、类等在外部模块都是不可见的。想要在外部模块使用必须使用export导出，然后使用import导入。在编译时会根据导入导出代码生成相对应的模块加载系统使用的代码（Node.js (CommonJS)，Require.js (AMD)，UMD，SystemJS或ECMAScript 2015 native modules (ES6)）。 导出基本语法使用export关键字可以导出任何声明（如变量，函数，类，类型别名或接口等） 12345678910111213//声明代表变量、函数、类等的声明export 声明//变量、函数、类等的声明名称，多个名字用逗号分隔，as可以对导出部分重命名export {声明名称 [as 新名字]}//导出其他模块中的内容，不会在当前模块中生成局部变量export {声明名称 [as 新名字]} from &quot;目标模块位置&quot;//为了兼容CommonJS和AMD引入//CommonJS和AMD的环境里有一个exports变量，包含了一个模块的所有导出内容//不能在有其他导出时使用该形式export = 对象名 举例如下： 1234567891011121314151617//一般导出export interface interface1{}export function fun1(){}export const s1 = &quot;&quot;export class class1{}export type t1 = string//导出并重命名class OldName{}export {OldName as NewName}//在其他模块中导出module1中的方法fun1()export { fun1 } from &quot;./module1&quot;; 为了兼容CommonJS和AMD引入的export =形式导出 123class ClassName{}export = ClassName 默认导出每个模块都可以有一个默认导出，使用default关键字声明 12345678910//名字：声明的名字，名字也可以用一个值替代，比如123、&quot;123&quot;等export default 名字//类和函数声明可以直接被标记为默认导出，标记为默认导出的类和函数的名字是可以省略的export default class{...}export default function(...){...}//其他模块导入时使用//新名字：自定义默认导出声明的名字import 新名字 from &quot;目标模块&quot;; 举例如下： 1234567//导出类export class Default{}export default Default//导出类或方法，省略名称export default class{}export default function(){} 导入使用import来导入其他模块中导出的内容 1234567891011121314//一般形式，可以使用as重命名，多个声明可以用逗号分隔import { 声明名字 [as 新名字] } from &quot;目标模块&quot;;//导入目标模块全部声明，必须使用as对模块进行命名import * as 命名 from &quot;目标模块&quot;;//不推荐，import &quot;目标模块&quot;//导入默认导出import 命名 from &quot;目标模块&quot;;//导入`export =`形式导出的内容import 命名 = require(&quot;目标模块&quot;) 举例如下： 1234567891011//一般形式import { fun1 } from &quot;./module1&quot;;//导入目标模块默认导出部分import * as module1 from &quot;./module1&quot;//import &quot;./module1&quot;//导入`export =`形式导出的内容import NewName = require(&quot;./module1&quot;) 命名空间命名空间以前被称为内部模块，以前使用的是module关键字，现在应该被namespace关键字替换。命名空间的作用就是组织代码的，可以将一个文件分割成多个部分，还不用担心命名冲突的问题，也可以将单个命名空间分割成多个文件。命名空间中的声明外部是看不到的，在外部调用需要使用export导出。 单个文件将单个文件分隔成多个部分，每个部分命名不会冲突 1234567891011namespace ns1{ interface i1{} //命名不会冲突 class ClassName{}}namespace ns2{ function fun1(){} class ClassName{}} 多个文件分割命名空间多个文件使用相同名字的命名空间，也就是将单个命名空间分割成多个文件。在使用时就像定义在一个文件中一样。不同文件之间的依赖关系使用引用标签来标识（&lt;reference path=&quot;xx.ts&quot; /&gt;） 12345678910111213141516171819202122232425/** ns.ts */namespace ns{ export const s = &quot;sss&quot;}/** ns1.ts *//// &lt;reference path=&quot;ns.ts&quot; /&gt;namespace ns{ export function fun(){ console.log(&quot;fun&quot;) }}/** ns2.ts *//// &lt;reference path=&quot;ns.ts&quot; /&gt;namespace ns{ export class ClassName{}}/** test.ts *//// &lt;reference path=&quot;ns.ts&quot; /&gt;/// &lt;reference path=&quot;ns1.ts&quot; /&gt;/// &lt;reference path=&quot;ns2.ts&quot; /&gt;//调用ns命名空间导出的方法ns.fun() 使用方式 使用tsc命令进行编译 编译器会根据源码里的引用标签自动地对输出进行排序。也可以单独地指定每个文件。 123tsc --outFile sample.js Test.ts# 单独指定每个文件tsc --outFile sample.js ns.ts ns1.ts ns2.ts test.ts 编译每一个文件，然后通过 &lt;script&gt;标签把所有生成的JavaScript文件引入 1234&lt;script src=&quot;ns.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;ns1.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;ns2.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;test.js&quot; type=&quot;text/javascript&quot; /&gt; 别名可以通过import关键字给命名空间（也可以是任意标识符）的对象起个短的名字，这里只是起别名，而不是导入。举例如下 12//为ns命名空间中的fun起别名import f = ns.fun","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"},{"title":"泛型","text":"泛型 使用&lt;占位符&gt;来声明泛型，泛型主要用于约束传入时数据的类型 泛型函数函数的泛型声明在方法名后 123456789101112131415//1、泛型函数function fun&lt;T&gt;(arg:T):T{ console.log(arg) return arg}//2、调用方式//调用时可以指定泛型fun&lt;number&gt;(3)//也可以不指定泛型，编译器会自动推断泛型的类型fun(3)//3、泛型函数的变量类型let f:{&lt;T&gt;(arg:T):T} = funf(3) 使用泛型引用类的构造函数 1234//表示c为T类的构造函数function create&lt;T&gt;(c: {new(): T}): T { return new c();} 泛型接口接口的泛型声明在接口名后，接口内部可以使用该泛型 1234567891011//1、泛型接口interface iFun&lt;T&gt;{ funType:{&lt;T&gt;(arg:T):T} argType:T}//2、用泛型接口引用变量let fi:iFun&lt;number&gt; = {funType:fun,argType:3}//泛型函数中的示例方法fi.funType(3)console.log(fi.argType) 泛型类类的泛型声明在类名后 12345678910class ClassName&lt;T&gt;{ //这里需要使用非空断言，因为类属性必须初始化 value?:T fun(arg:T):T{ return arg }}let c = new ClassName&lt;number&gt;()c.value = 10 泛型约束声明一个泛型时，我们无法确定以后传入的泛型的类型，所以只能当作any类型来使用，如果希望可以调用某些类型的方法，可以使用extends关键字约束泛型的类型 extends：约束泛型必须是某个类型或其子类 12345//声明参数为String类型或其子类function fun&lt;T extends String&gt;(arg:T){ //调用String类型的属性 console.log(arg.length)}","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/"},{"title":"类型系统","text":"变量、常量、特殊类型、字面量类型、高级类型、类型别名、索引类型 变量声明变量使用let或var声明变量，他们写法一致 1234let/var 变量名:变量类型 = 字面量//类型推断let/var 变量名 = 字面量 举例如下： 1let myName: string = &quot;Alice&quot;; var与let的区别作用域 var的作用域是包含他的函数、模块，命名空间，不包括 let作用域是当前的代码块，也就是块作用域 12345678if(true){ let a = 10 var b = 10}console.log(a)//报错console.log(b)//不报错 重复声明 var变量可以重复声明 let变量在一个作用域内只能声明一次 1234let a = 10let a = 100//报错var b = 10var b = 100//不报错 变量获取 var每次进入一个作用域时，创建一个环境的变量， 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在 let不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域 123456789//这里每次进入都会创建一个新的i，最后输出0-9for (let i = 0; i &lt; 10 ; i++) { setTimeout(function() {console.log(i); }, 100 * i);//0-9}//这里内部的i引用着外部var声明的i，最终输出的都是10for (var i = 0; i &lt; 10 ; i++) { setTimeout(function() {console.log(i); }, 100 * i);//10 ...} 常量使用const声明常量 12const 变量名:变量类型 = 字面量const 变量名 = 字面量 常量必须初始化 举例如下： 1var myName: string = &quot;Alice&quot;; 声明合并ts中的声明会创建以下三个实体之一：命名空间、类型或值。 命名空间实体：创建一个命名空间，它包含了用.访问时使用的名字 类型实体：创建一个类型并绑定到给定的名字上 值的实体：创建在js中看到的值 每个声明创建的实体如下： 声明类型 命名空间 类型 值 Namespace X X Class X X Enum X X Interface X Type Alias X Function X Variable X 接口合并接口合并是最常见的声明合并类型，就是将多个接口的成员放到一个同名接口里。同名接口内的同名函数成员会被当成这个函数的重载，非函数成员不允许重名 1234567interface Animal { age: number;}interface Animal { name: string;} 命名空间合并命名空间的声明会创建命名空间和值，这两者会进行合并： 对于命名空间中接口的合并：模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口； 对于命名空间中其他值的合并：如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里； 特殊类型 any：可以接收任何类型的值； void：表示没有任何类型，可以用于声明函数返回值； never：表示永远不会存在值的类型，是所有类型的子类型，可以赋值给任何变量； undefined和null：表示不存在或未初始化的值。配置文件中 strictNullChecks为 true时区别如下： null：表示没有对象，即该处不应该有值，用法如下： 作为函数的参数，表示该函数的参数不是对象； 作为对象原型链的终点； undefined：表示缺少值，即次数应该有值，只不过还没初始化，用法如下： 变量被声明了，但没有赋值时，为undefined； 调用函数时，应该提供的参数没有提供，该参数默认为undefined； 对象没有赋值的属性，该属性的值为undefined； 函数没有返回值时，默认返回undefined； 字面量类型字面量类型表示将值作为类型使用，所有声明类型的地方都可以使用字面量类型，并且可以混合使用 12let x: &quot;hello&quot; = &quot;hello&quot;let x: &quot;hello&quot;|&quot;world&quot; = &quot;world&quot; 高级类型交叉类型使用&amp;连接多个类型表示对象需要满足多个类型的特征 1类型1&amp;类型2&amp;类型3 举例如下 123456789101112interface T1{ a:String}interface T2{ b:String}let v:T1&amp;T2 = {a:&quot;a&quot;,b:&quot;b&quot;}//使用时可以访问变量有多个类型的任意成员v.av.b 联合类型使用|连接多个类型，表示变量可以是这些类型中的任意一个 1类型1|类型2|类型3 举例如下 123456789101112131415161718192021222324252627interface T1{ a:String c:String}interface T2{ b:String c:String}//返回T1或T2类型变量function getType():T1|T2{ return {a:&quot;a&quot;,c:&quot;c&quot;}}//获取变量，此时不知道到底是T1|T2中那个类型let v = getType()//可以访问变量中多个类型的共有成员v.c//判断变量实际类型（推荐使用后面的类型保护）if((&lt;T2&gt;v).b==undefined){ console.log(&quot;是T1类型&quot;)}else if((&lt;T1&gt;v).a==undefined){ console.log(&quot;是T2类型&quot;)} 类型保护类型保护通过以下三种形式实现，返回的都是布尔值： is：用于判断变量的实际类型，用在方法返回值上 1变量名 is 类型 typeof：只能用于判断原始类型 1typeof 变量名 instanceof：判断变量类型，右侧需要是类。与java中类似 1变量名 instanceof 类型 索引类型keyof T返回T类型的属性的联合 1234567891011interface Animal{ name:String age:number}let props:keyof Animal //keyof Animal等同于'name' | 'age'//获取对象的属性值function getProperty&lt;T,K extends keyof T&gt;(o: T, prop: K):T[K]{ return o[prop]} 类型别名声明语法通过type关键字为一个常用类型设置别名 1type 别名 = 类型 举例如下 123type point = {x:number|string,y?:number,z:number}type ID = number | string;type n = number 说明： 只是设置了一个别名，没有创建新的类型； 扩展类型类型本身不能更改，只能通过合并的方式生成新的别名 12345type Animal = {name:string}type AnimalPro = Animal &amp; {age:number}type n = numbertype n2 = n | string","link":"/2021/05/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"运算符","text":"算术运算符、关系运算符、逻辑运算符、位运算符、其他运算符、运算符优先级 算术运算符 运算符 说明 + 加法 - 减法 * 乘法 / 除法 % 取模（余数） ++ 自增 – 自减 = 赋值 op= 赋值 关系运算符 运算符 说明 == 等于 x==5 true != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 逻辑运算符 运算符 说明 &amp;&amp; and || or ! not 位运算符 运算符 说明 &amp; AND，按位与处理两个长度相同的二进制数，两个相应的二进位都为 1，该位的结果值才为 1，否则为 0。 | OR，按位或处理两个长度相同的二进制数，两个相应的二进位中只要有一个为 1，该位的结果值为 1。 ~ 取反，取反是一元运算符，对一个二进制数的每一位执行逻辑反操作。使数字 1 成为 0，0 成为 1。 ^ 异或，按位异或运算，对等长二进制模式按位或二进制数的每一位执行逻辑异按位或操作。操作的结果是如果某位不同则该位为 1，否则该位为 0。 &lt;&lt; 左移，把 &lt;&lt; 左边的运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数指定移动的位数，高位丢弃，低位补 0。 &gt;&gt; 右移，把 &gt;&gt; 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数指定移动的位数。 &gt;&gt;&gt; 无符号右移，与有符号右移位类似，除了左边一律使用0 补位。 其他运算符 运算符 说明 condition ? exp1 : exp2 条件为真返回exp1，否则返回exp2 typeof 返回操作数的数据类型 运算符优先级优先级从上到下，同一级别结合性从左到右 运算符 描述 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ – - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 + - + 加法、减法、字符串连接 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位 &lt; &lt;= &gt; &gt;= instanceof 小于、小于等于、大于、大于等于、instanceof == != === !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 ^ 按位异或 | 按位或 &amp;&amp; 逻辑与 || 逻辑或 ?: 条件 = oP= 赋值、运算赋值 , 多重求值","link":"/2021/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"面向对象","text":"接口、类、抽象类、访问修饰符 接口ts中的接口和其他语言中的接口不同，它主要起到的是一个约束的作用，而不会关注引用的是否是接口或其子类的对象（即类型兼容性）。例子如下 1234567891011121314interface Animal { name: string age: number}//a不是Animal的子类，但a拥有Animal声明的属性约束let a = {age:2,name:&quot;魔力猫&quot;,sex:&quot;雌&quot;}//a可以作为test方法的参数test(a)function test(labelledObj: Animal) { console.log(labelledObj);} 类型兼容性：如果x要兼容y,x的每个属性在y中都有对应的值，对于方法也同样适用 123456789101112131415interface Animal { name: string;}let x: Animal;//y的类型是{ name: string; location: string; }let y = { name: '动力猿', location: '维苏威火山' };//x的每个属性y中都有对应的值x = y;let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 接口声明使用interface关键字声明接口 1234interface 接口名 { 属性名: 类型[;] ...} 说明： 和属性别名类似几乎所有特性都是一样，主要区别是接口可以改变； 接口不能声明静态成员； 举例如下 123456789interface Animal { name: string age?: number}//也可以声明级联类型和可选类型interface Animal { name: string|number age?: number} 接口继承接口间使用extends关键字继承 123456789interface Animal { name: string}interface Cat extends Animal{ age:number}let a: Cat = {name:&quot;张三&quot;,age:12} 接口合并一个接口可以声明多次，所有声明合在一起就是最终的接口，可以查看声明合并部分 123456789interface Animal { name: string}interface Animal{ age:number}let a: Animal = {name:&quot;张三&quot;,age:12} 属性可选属性接口中可以使用?声明可选属性 123456interface Animal { name: string age?: number}//即便不声明age也不会报错，age默认是undefinedlet a:Animal = {name:&quot;魔力猫&quot;} 在option bags模式下，会进行属性检查，如果传入的可选属性不存在，也会编译报错 12345678910interface Animal { name: string age?: number}//age拼写错误，这里会报错test({aga:2,name:&quot;魔力猫&quot;,sex:&quot;雌&quot;})function test(labelledObj: Animal) { console.log(labelledObj);} 可以使用类型断言或传递变量解决这个问题 12345678//方法1：声明类型断言test({aga:2,name:&quot;魔力猫&quot;,sex:&quot;雌&quot;} as Animal)//方法2使用变量传递let a = {aga:2,name:&quot;魔力猫&quot;,sex:&quot;雌&quot;}test(a)function test(labelledObj: Animal) { console.log(labelledObj);} 只读属性使用readonly关键字可声明只读属性 12345678interface Animal { name: string readonly age: number}let a:Animal = {name:&quot;魔力猫&quot;,age:3}a.age = 3 //报错，只读属性不能被修改 接口构造可以声明一个专门用来构造接口子类的接口 12345678910111213141516171819interface Animal{}//用于构造Animalinterface AnimalConstructor { new():Animal}//传递进来的是Animal的子类function createAnimal(ctor: AnimalConstructor): Animal { return new ctor();}//Animal子类class Cat implements Animal { constructor(){}}//传入Animal子类catcreateAnimal(Cat) 函数类型接口可以声明函数类型的接口，该接口的变量可以引用函数，类似于C#的委托 1234interface 接口名 { (参数列表):返回值类型 //其他属性或方法声明...} 说明： 参数列表的参数名可以与方法中的不同，但类型要相同 返回值类型可以不写，编译器可以自行推断 举例如下 1234567891011interface AnimalFun { (name:string,age:number):boolean}let animalFun:AnimalFun = function(name1:string,age:number) { console.log(name1,age) return true}animalFun(&quot;魔力猫&quot;,3) 可索引类型接口索引签名可索引类型接口需要有一个索引签名 1234567interface AnimalArr{ //类型1需要能赋值给类型2 //数字索引签名 [index:number]:类型1; //字符串索引签名 [index:string]:类型2;} 说明： 索引签名支持字符串和数字两种索引形式； 数字索引的返回值必须可以分配给字符串索引类型； 所有属性要与索引的返回值类型相匹配； 索引签名可以声明为readonly，这样初始化后就不能再给索引赋值； 举例如下 1234567891011121314151617181920212223242526272829interface AnimalArr{ //Cat必须能分配给Animal，声明的属性要少于Cat声明的属性也可以 //这里Animal是Cat父接口， //或者Animal可以替换成Cat //数字索引签名 [index:number]:Cat; //字符串索引签名 [x:string]:Animal;}interface Animal { name:string}interface Cat extends Animal { name:string}//初始化let cat1:Cat = {name:&quot;猫1&quot;}let cat2:Cat = {name:&quot;猫2&quot;}let animalArr:AnimalArr;//如果声明了字符串索引签名，这样初始化animalArr = {&quot;1&quot;:cat1,&quot;cat2&quot;:cat2}//如果只声明数字索引签名，这样初始化animalArr = [cat1,cat2] 访问方式可以使用数字和字符串进行索引，得到的就是对应索引签名的返回值 12345//数字签名索引indexInterface[index]//字符串签名索引indexInterface[&quot;str&quot;]indexInterface.str 说明： 当使用数字索引时，JavaScript会将它转换成字符串然后再去索引对象（100-&gt;“100”）； 接【1】中代码 123456789101112//方式1//如果只声明数字索引签名，这样初始化animalArr = [cat1,cat2]//数字索引方式console.log(animalArr[1])//方式2//如果声明了字符串索引签名，这样初始化animalArr = {&quot;1&quot;:cat1,&quot;cat2&quot;:cat2}//字符串索引方式console.log(animalArr.cat2)console.log(animalArr[&quot;cat2&quot;]) 继承接口接口也可以相互继承，并且支持多继承。相当于将多个接口的合成为一个 1234567891011interface interface1{}interface interface2{ }interface subInterface extends interface1,interface2{ } 继承类ts支持接口继承类，并且支持多继承 12345678910111213141516171819202122232425262728class Eye{ color:string = &quot;黑色&quot; //眨眼 blink(){}}class Ear{ size:string = &quot;长耳朵&quot; //听 hear(){}}//接口继承多个类interface Animal extends Ear,Eye{}class cat implements Animal{ size: string = &quot;&quot; hear(): void { throw new Error(&quot;Method not implemented.&quot;) } color: string = &quot;&quot; blink(): void { throw new Error(&quot;Method not implemented.&quot;) } } 说明： 接口相当于继承了父类的方法声明（不包含实现）和属性； 如果继承到类的private和protected成员，这时这个接口类型只能被这个类或其子类所实现； 类类声明使用class关键字声明类 1234567891011121314151617181920212223class ClassName{ //声明属性 p: string s: string = &quot;初始化&quot;; //构造方法 constructor(p:string){ //使用this引用类成员 this.p = p } //实例方法 fun(){} //静态属性 static animalName:string = &quot;&quot; //静态方法 static staticFun(){}}//初始化c:ClassName = new ClassName(&quot;p&quot;)//访问静态成员ClassName.animalNameClassName.staticFun() 说明： 使用constructor声明构造函数，构造函数是类的静态部分； 使用this引用类成员； 声明属性必须通过赋值或者在构造函数中初始化； 通过new关键字初始化类实例； 使用static声明静态成员，访问静态成员需要接通过类名； 继承类使用extends继承其他类，但不支持多继承 12345678910111213141516171819202122class Animal { fun(){}}class Cat extends Animal { //声明只读变量 readonly name:string; constructor() { //调用父类构造函数 super(); } //重写方法 fun(){ //使用父类的类成员 super.fun() } catFun(){}} 说明： 使用super引用父类的构造函数和父类成员； 使用readonly声明只读变量； 实现接口使用implements实现接口 12345678910111213interface Animal { s:string; fun(p:string):void;}class Cat implements Animal { //接口中属性也要实现 s: string = &quot;初始化&quot;; //实现方法 fun() { }} 说明： 实现接口后，接口的方法和属性都要在派生类中声明 存取器ts类中可以声明get和set方法 1234567891011121314class Animal{ _name:string = &quot;&quot; get name():string{ return this.name } set name(newName:string){ this._name = newName }}let a = new Animal()a.name = &quot;魔力猫&quot;a.name 抽象类通过abstract声明抽象类。抽象类相当于接口和类的结合 12345678910abstract class Animal{ //抽象方法 abstract fun():any constructor(){} //实例属性 name:string = &quot;&quot; //静态成员 static animalName:string = &quot;&quot; static staticFun(){}} 说明： 声明任何在类中声明的成员，可以声明constructor方法但不能实例化； 使用abstract声明抽象方法； 访问修饰符作用域ts中比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型和访问修饰符都是兼容的，我们就认为它们的类型是兼容的 public protected private 类内 √ √ √ 派生类 √ √ × 类外 √ × × 说明： ts中成员默认都是public； protected 构造函数被protected修饰的构造函数不能被实例化，但可以在派生类中调用父类构造函数 1234567891011121314151617class Animal { protected constructor() { }}class Cat extends Animal { constructor() { //在子类中可以调用父类受保护的构造函数 super(); }}let a:Animal = new Animal() //报错，构造函数被保护","link":"/2021/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Hadoop MapReduce","text":"MapReduce 是 Hadoop 的计算组件 Hadoop MapReduce MapReduce 执行一个计算任务时分为如下阶段： 输入数据：从HDFS加载数据，交给InputFormat处理； InputFormat：格式化输入，将数据（通常只拆分比block大的文件）拆分成一个个的InputSplit（Split）； InputSplit：代表一个个逻辑分片，通常一个Split就是一个block； RecordReader：用于将InputSplit分隔成一个个的key-value对给Map处理； Mapper：读取InputSplit的每一个键值对并对其进行处理； Partitioner：每个节点的多个Map操作输出的结果会合并为一个分区（Partitioner）， Sort Reduce OutputFormat 输出结果 InputFormat TextInputFormat：输入文件中的每一行就是一个记录，key是这行的偏移量，value是这一行的内容； KeyValueTextInputFormat：输入文件中每一行就是一个记录，通过第一个识别到的分隔符进行切割，在分隔符之前的内容为key，分隔符之后的内容为value分隔符变量通过key.value.separator.in.input.line变量设置，默认为(\\t)字符。 NLineInputFormat：与TextInputFormat一样，但每个数据块必须保证有且只有Ｎ行，mapred.line.input.format.linespermap属性，默认为１； SequenceFileInputFormat： 一个用来读取字符流数据的InputFormat，key和value为用户自定义的。字符流数据是Hadoop自定义的压缩的二进制数据格式。它用来优化从一个MapReduce任务的输出到另一个MapReduce任务的输入之间的数据传输过程； CombineFileInputFormat：用于处理大量小文件，可以将若干个Split打包成一个，避免map task 过多消耗性能； InputSplit1234567891011public abstract class InputSplit { /** * 获取Split的大小，支持根据size对InputSplit排序. */ public abstract long getLength() throws IOException, InterruptedException; /** * 获取存储该分片的数据所在的节点位置. */ public abstract String[] getLocations() throws IOException, InterruptedException;} 拆分大小通过如下参数控制拆分大小： mapred.min.split.size mapred.max.split.size block.size 问题 若mapred.max.split.size大于block.size时代表最小的分片大小都要比block大，当数据量不足或剩余数据量不足时需要从网络获取一些数据加到分片中以满足mapred.min.split.size的要求； 若mapred.max.split.size小于block.size代表每个block都比最大分大小要大，那么就需要对block进行分隔，一个block会分隔成多个分片，增加了map task的数量，消耗资源； Map当Map程序开始产生结果的时候，并不是直接写到文件的，而是利用缓存做一些排序方面的预处理操作 每个Map任务都有一个循环内存缓冲区（默认100MB），当缓存的内容达到80%时，后台线程开始将内容写到文件，此时Map任务可以继续输出结果，但如果缓冲区满了，Map任务则需要等待 写文件使用round-robin方式。在写入文件之前，先将数据按照Reduce进行分区。对于每一个分区，都会在内存中根据key进行排序，如果配置了Combiner，则排序后执行Combiner（Combine之后可以减少写入文件和传输的数据） 每次结果达到缓冲区的阀值时，都会创建一个文件，在Map结束时，可能会产生大量的文件。在Map完成前，会将这些文件进行合并和排序。如果文件的数量超过3个，则合并后会再次运行Combiner（1、2个文件就没有必要了） 如果配置了压缩，则最终写入的文件会先进行压缩，这样可以减少写入和传输的数据 一旦Map完成，则通知任务管理器，此时Reduce就可以开始复制结果数据 ReduceMap的结果文件都存放到运行Map任务的机器的本地硬盘中如果Map的结果很少，则直接放到内存，否则写入文件中同时后台线程将这些文件进行合并和排序到一个更大的文件中（如果文件是压缩的，则需要先解压）当所有的Map结果都被复制和合并后，就会调用Reduce方法Reduce结果会写入到HDFS中 调优一般的原则是给shuffle分配尽可能多的内存，但前提是要保证Map、Reduce任务有足够的内存 对于Map，主要就是避免把文件写入磁盘，例如使用Combiner，增大io.sort.mb的值 对于Reduce，主要是把Map的结果尽可能地保存到内存中，同样也是要避免把中间结果写入磁盘。默认情况下，所有的内存都是分配给Reduce方法的，如果Reduce方法不怎么消耗内存，可以mapred.inmem.merge.threshold设成0，mapred.job.reduce.input.buffer.percent设成1.0 在任务监控中可通过Spilled records counter来监控写入磁盘的数，但这个值是包括map和reduce的 对于IO方面，可以Map的结果可以使用压缩，同时增大buffer size（io.file.buffer.size，默认4kb） 配置 属性 默认值 描述 io.sort.mb 100 映射输出分类时所使用缓冲区的大小. io.sort.record.percent 0.05 剩余空间用于映射输出自身记录.在1.X发布后去除此属性.随机代码用于使用映射所有内存并记录信息. io.sort.spill.percent 0.80 针对映射输出内存缓冲和记录索引的阈值使用比例. io.sort.factor 10 文件分类时合并流的最大数量。此属性也用于reduce。通常把数字设为100. min.num.spills.for.combine 3 组合运行所需最小溢出文件数目. mapred.compress.map.output false 压缩映射输出. mapred.map.output.compression.codec DefaultCodec 映射输出所需的压缩解编码器. mapred.reduce.parallel.copies 5 用于向reducer传送映射输出的线程数目. mapred.reduce.copy.backoff 300 时间的最大数量，以秒为单位，这段时间内若reducer失败则会反复尝试传输 io.sort.factor 10 组合运行所需最大溢出文件数目. mapred.job.shuffle.input.buffer.percent 0.70 随机复制阶段映射输出缓冲器的堆栈大小比例 mapred.job.shuffle.merge.percent 0.66 用于启动合并输出进程和磁盘传输的映射输出缓冲器的阀值使用比例 mapred.inmem.merge.threshold 1000 用于启动合并输出和磁盘传输进程的映射输出的阀值数目。小于等于0意味着没有门槛，而溢出行为由 mapred.job.shuffle.merge.percent单独管理. mapred.job.reduce.input.buffer.percent 0.0 用于减少内存映射输出的堆栈大小比例，内存中映射大小不得超出此值。若reducer需要较少内存则可以提高该值. Map阶段ShuffleReduce阶段","link":"/2022/10/02/%E6%A1%86%E6%9E%B6/Java/Hadoop/Hadoop%20MapReduce/"},{"title":"Hadoop HDFS","text":"Hadoop HDFS 的架构、读写流程以及常用命令 Hadoop HDFSHDFS 架构 Block数据块 基本存储单位，一般大小为128mb（HDFS1.x是64mb），配置大的块主要是因为： 减少搜寻时间，一般硬盘传输速率比寻道时间要快，大的块可以减少寻道时间； 减少管理块的数据开销，每个块都需要在NameNode上有对应的记录； 对数据块进行读写，减少建立网络的连接成本； 一个大文件会被拆分成一个个的块，然后存储于不同的机器。如果一个文件少于Block大小，那么实际占用的空间为其文件的大小； 基本的读写单位，类似于磁盘的页，每次都是读写一个块 每个块都会被复制到多台机器，默认复制3份 NameNodeNameNode运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小。NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性。 存储内容 元数据（metadata）：会存储文件的元数据（metadata）运行时读取到内存。 块信息（block）：一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件。NameNode不会将block的位置信息持久化到磁盘，而是在运行时根据DataNode发来的信息动态地在内存中构建的，每次NameNode重启后都需要重新构建。 信息持久化NameNode将数据持久到磁盘时会把edit logs（改动）写入到文件系统中，然后当NameNode启动时再将快照和改动进行合并。 SecondaryNameNodeNameNode的edit logs文件会随着时间的增加而逐渐变大，这回导致NameNode启动时间变长（因为启动时需要将编辑日志和文件系统镜像合并）和丢失数据的问题，SecondaryNameNode用来解决上述问题，它的职责是合并NameNode的edit logs到fsimage文件中。 存储内容 编辑日志（edit logs） 文件系统镜像（fsimage） 运行流程 定时与NameNode进行同步，读取编辑日志和 将编辑日志合并到文件系统镜像中 合并后文件系统镜像的传给NameNode，替换其镜像，并清空编辑日志； DataNode 保存具体的block数据； 负责数据的读写操作和复制操作； DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息； DataNode之间会进行通信，复制数据块，保证数据的冗余性； 读写流程写文件 写文件流程如下： client将文件写入本地磁盘的HDFS Client中； 当HDFS Client中存储的临时文件达到一个block大小时，HDFS Client会通知NameNode，申请写入文件； Namenode在HDFS文件系统中创建一个文件，并把block id和要写入的DataNode列表返回给HDFS Client； HDFS Client接收到信息后将临时文件写入到DataNodes中，写入到第一个DataNode后，DataNode在将数据写入磁盘的同时也会传输到下一个DataNode，依次传输直到达到要求的副本数量（如果写入某个 DataNode 失败，数据会继续写入其他的 DataNode）； 后一个的 DataNode 接收完数据后，都会发送一个确认给前一个 DataNode，最终第一个 DataNode 返回确认给HDFS Client，当HDFS Client接收到整个 block 的确认后，会向 NameNode 发送一个最终的确认信息； 文件写完后通知NameNode，NameNode负责提交文件（这时文件才可见，如果提交前，NameNode 垮掉，那文件也就丢失了。只保证数据的信息写到 NameNode 上，但并不保证数据已经被写到DataNode 中）； 读文件 读文件流程如下： Client发送读文件请求； HDFS Client向NameNode发送读取请求； NameNode返回文件的信息； HDFS Client到DataNode中读取数据，如果读取失败（DataNode失效或校验码不对），则从复制节点中读取（如果读取的数据就在本机，则直接读取，否则通过网络读取） 可靠性文件冗余可以在 hdfs-site.xml 中设置复制因子指定副本数量，如果一个 DataNode 失效也可以去找文件副本。 机架感知机架感知是指通过节点之间发送一个数据包，根据机架名和DNS的对应关系来感应它们是否在同一个机架。由于同一机架内传输速度更快，一般在本机架放一个副本,在其他机架再存放一个副本,这样可以防止机架失效时丢失数据，也可以提高带宽利用率。 心跳机制 NameNode周期性地从 DataNode 接受心跳信息和块报告； NameNode 根据块报告验证元数据 没有按时发送心跳的 DataNode 会被标记为宕机,不会再给他任何 I/O 请求； 如果 DataNode 失效造成副本数量下降,并且低于预先设定的值,NameNode 会检测出这些数据库,并在合适的时机重新复制； 引发重新复制的原因还包括数据副本本身损坏,磁盘错误,复制因子被增大等； 安全模式 NameNode 启动时会先经过一个 “安全模式” 阶段，安全模式不会产生读写，在此阶段 NameNode 收集各个 DataNode 的报告, 当数据块达到最小副本数以上时,会被认为是”安全”的； 在一定比例(可设置) 的数据块被确定为”安全” 后 ,在过若干时间,安全模式结束； 当检测到副本数不足的数据块时,该块会被复制,直到达到最小副本数； 校验和 在文件创立时，每个数据块都产生效验和； 效验和会作为单独一个隐藏文件保存在命名空间下； 客户端获取数据时可以检查效验和是否相同，从而发现数据块是否损坏； 如果正在读取的数据块损坏，则可以继续读取其他副本； 回收站 删除文件时，其实是放入回收站 /trash； 回收站里的文件是可以快速恢复的； 可以设置一个时间值，当回收站里文件的存放时间超过了这个值，就被彻底删除,并且释放占用的数据块； 元数据保护 映像文件和事物日志是 NameNode 的核心数据.可以配置为拥有多个副本； 副本会降低 NameNode 的处理速度,但增加安全性； NameNode 依然是单点,如果发生故障要手工切换； HDFS 命令","link":"/2022/10/01/%E6%A1%86%E6%9E%B6/Java/Hadoop/Hadoop%20HDFS/"},{"title":"Hadoop YARN","text":"Hadoop YARN负责进行资源管理和任务调度，本文介绍YARN的组件、 Hadoop YARNYARN 架构 上图组件如下： ResourceManager：全局资源管理和任务调度； NodeManager：单个节点的资源管理和监控； ApplicationMaster：单个作业的资源管理和任务监控； Container： 资源申请的单位和任务运行的容器； ContainerContainer是基本的资源单位： 每个节点拥有多个Container； 每个Container可以动态申请资源（CPU、内存）； Container可以加载任意程序，而且不限于Java； 一个节点可以包含一个或多个 Container ； ApplicationMaster 可以根据需要，动态申请和释放Container； 每个Container可以根据需要运行ApplicationMaster、Map、Reduce或者任意的程序； ResourceManager资源管理器（ResourceManager）负责资源管理和任务调度 Client Service: 应用提交、终止、输出信息（应用、队列、集群等的状态信息） Adaminstration Service: 队列、节点、Client权限管理 ApplicationMasterService: 注册、终止ApplicationMaster, 获取ApplicationMaster的资源申请或取消的请求，并将其异步地传给Scheduler, 单线程处理 ApplicationMaster Liveliness Monitor: 接收ApplicationMaster的心跳消息，如果某个ApplicationMaster在一定时间内没有发送心跳，则被任务失效，其资源将会被回收，然后ResourceManager会重新分配一个ApplicationMaster运行该应用（默认尝试2次） Resource Tracker Service: 注册节点, 接收各注册节点的心跳消息 NodeManagers Liveliness Monitor: 监控每个节点的心跳消息，如果长时间没有收到心跳消息，则认为该节点无效, 同时所有在该节点上的Container都标记成无效，也不会调度任务到该节点运行 ApplicationManager: 管理应用程序，记录和管理已完成的应用 ApplicationMaster Launcher: 一个应用提交后，负责与NodeManager交互，分配Container并加载ApplicationMaster，也负责终止或销毁 YarnScheduler: 资源调度分配， 有FIFO(with Priority)，Fair，Capacity方式 ContainerAllocationExpirer: 管理已分配但没有启用的Container，超过一定时间则将其回收 资源管理用户提交作业到ResourceManager，然后在某个NodeManager上分配一个Container来运行ApplicationMaster，ApplicationMaster再根据自身程序需要向ResourceManager申请资源 YARN有一套Container的生命周期管理机制，而ApplicationMaster和其Container之间的管理是应用程序自己定义的 任务调度只关注资源的使用情况，根据需求合理分配资源 Scheluer可以根据申请的需要，在特定的机器上申请特定的资源（ApplicationMaster负责申请资源时的数据本地化的考虑，ResourceManager将尽量满足其申请需求，在指定的机器上分配Container，从而减少数据移动） NodeManagerNode节点下的Container管理 启动时向ResourceManager注册并定时发送心跳消息，等待ResourceManager的指令 监控Container的运行，维护Container的生命周期，监控Container的资源使用情况 启动或停止Container，管理任务运行时的依赖包（根据ApplicationMaster的需要，启动Container之前将需要的程序及其依赖包、配置文件等拷贝到本地） NodeStatusUpdater: 启动向ResourceManager注册，报告该节点的可用资源情况，通信的端口和后续状态的维护 ContainerManager: 接收RPC请求（启动、停止），资源本地化（下载应用需要的资源到本地，根据需要共享这些资源） PUBLIC: /filecache PRIVATE: /usercache//filecache APPLICATION: /usercache//appcache//（在程序完成后会被删除） ContainersLauncher: 加载或终止Container ContainerMonitor: 监控Container的运行和资源使用情况 ContainerExecutor: 和底层操作系统交互，加载要运行的程序 ApplicationMaster单个作业的资源管理和任务监控 具体功能描述： 计算应用的资源需求，资源可以是静态或动态计算的，静态的一般是Client申请时就指定了，动态则需要ApplicationMaster根据应用的运行状态来决定 根据数据来申请对应位置的资源（Data Locality） 向ResourceManager申请资源，与NodeManager交互进行程序的运行和监控，监控申请的资源的使用情况，监控作业进度 跟踪任务状态和进度，定时向ResourceManager发送心跳消息，报告资源的使用情况和应用的进度信息 负责本作业内的任务的容错 ApplicationMaster可以是用任何语言编写的程序，它和ResourceManager和NodeManager之间是通过ProtocolBuf交互，以前是一个全局的JobTracker负责的，现在每个作业都一个，可伸缩性更强，至少不会因为作业太多，造成JobTracker瓶颈。同时将作业的逻辑放到一个独立的ApplicationMaster中，使得灵活性更加高，每个作业都可以有自己的处理方式，不用绑定到MapReduce的处理模式上 如何计算资源需求 一般的MapReduce是根据block数量来定Map和Reduce的计算数量，然后一般的Map或Reduce就占用一个Container 如何发现数据的本地化 数据本地化是通过HDFS的block分片信息获取的 执行流程1. Job submission 从ResourceManager 中获取一个Application ID 检查作业输出配置，计算输入分片 拷贝作业资源（job jar、配置文件、分片信息）到 HDFS，以便后面任务的执行 2. Job initialization ResourceManager 将作业递交给 Scheduler（有很多调度算法，一般是根据优先级）Scheduler 为作业分配一个 Container，ResourceManager 就加载一个 application master process 并交给 NodeManager。 管理 ApplicationMaster 主要是创建一系列的监控进程来跟踪作业的进度，同时获取输入分片，为每一个分片创建一个 Map task 和相应的 reduce task Application Master 还决定如何运行作业，如果作业很小（可配置），则直接在同一个 JVM 下运行 3. Task assignment ApplicationMaster 向 Resource Manager 申请资源（一个个的Container，指定任务分配的资源要求）一般是根据 data locality 来分配资源 4. Task execution ApplicationMaster 根据 ResourceManager 的分配情况，在对应的 NodeManager 中启动 Container 从 HDFS 中读取任务所需资源（job jar，配置文件等），然后执行该任务 5. Progress and status update 定时将任务的进度和状态报告给 ApplicationMaster Client 定时向 ApplicationMaster 获取整个任务的进度和状态 6. Job completion Client定时检查整个作业是否完成 作业完成后，会清空临时文件、目录等","link":"/2022/10/03/%E6%A1%86%E6%9E%B6/Java/Hadoop/Hadoop%20YARN/"},{"title":"Hadoop 部署","text":"Hadoop部署方式 先决条件JAVA版本Hadoop3主要支持java1.8，虽然hadoop3.3及以上版本也支持java11运行时，但并不支持java11的编译，查看具体支持的版本点击此处， 需要事先下载好java1.8版本，版本太高可能有问题，这里推荐下载jre1.8，我第一次下载同版本jdk1.8后启动hadoop会警告（但运行正常） 支持的版本在如下网站 单机部署点击此处跳转到官方提供的单节点部署文档 安装过程123456789101112131415# 首先在官网下载hadoop，然后进行解压$ tar -zxvf hadoop-x.x.x.tar.gz# 移动到/opt/hadoop$ sudo mv hadoop/ /opt/hadoop/$ cd /opt/hadoop# 修改所有者和组$ sudo chown -R zcy:zcy hadoop/# 接下来编写配置文件# 进入配置文件目录$ cd /opt/hadoop/hadoop-3.3.4/etc/hadoop/# 配置hadoop环境变量$ vim hadoop-env.sh# 事先下载好的java1.8export JAVA_HOME=/opt/hadoop/jre1.8.0_341$ source hadoop-env.sh 接下来在该目录下配置Hadoop的配置文件，各个文件配置如下: core-site.xml（需要更改hadoop.tmp.dir路径） 123456789101112&lt;configuration&gt; &lt;!-- 用来指定hdfs的老大（NameNode）的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 用来指定Hadoop运行时产生文件的存放目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hadoop-3.3.4/data/&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml （无需更改） 123456789101112&lt;configuration&gt; &lt;!-- 指定HDFS保存数据副本数量 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;!-- 是否开启权限检查 --&gt; &lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml（无需更改） 1234567891011121314151617181920212223&lt;configuration&gt; &lt;!-- 告诉hadoop以后MR运行在yarn上 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt; &lt;/property&gt; &lt;!-- 历史服务器端地址 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;localhost:10020&lt;/value&gt; &lt;/property&gt; &lt;!-- 历史服务器 web 端地址 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;localhost:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml（无需更改） 12345678910111213141516&lt;configuration&gt; &lt;!-- NodeManager获取数据的方式是shuffle--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定YARN的老大（resourcemanager）的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 最后配置环境变量和启动Hadoop 1234567891011121314# 配置环境变量# 回到家目录$ cd $ vim .bash_profile# hadoop环境变量export HADOOP_HOME=&quot;/opt/hadoop/hadoop-3.3.4&quot; #自己hadoop的目录位置export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin$ source .bash_profile# 初始化$ hdfs namenode -format# 启动$ start-dfs.sh$ start-yarn.sh 通过访问以下两个网址确定是否开启成功： hdfs可视化界面 http://localhost:9870/ yarn可视化界面 http://localhost:8088/ 开启历史服务打开配置文件 mapred-site.xml 添加如下内容 1234567891011&lt;!-- 历史服务器端地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;localhost:10020&lt;/value&gt;&lt;/property&gt;&lt;!-- 历史服务器 web 端地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;localhost:19888&lt;/value&gt;&lt;/property&gt; 配置完后在yarn页面点击任务的history可能无法跳转，因为默认是根据hostname代理的，需要先将hostname改为localhost（可以先使用hostname命令确认一下） 12345678# 修改hosts文件，配置hostname$ hostnamectl set-hostname localhost# 重启终端# 重启hadoop$ stop-all.sh$ start-all.sh# 启动历史服务器$ mapred --daemon start historyserver 开启日志聚集打开配置文件 yarn-site.xml 添加如下内容 1234567891011121314&lt;property&gt; &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置日志聚集服务器地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://localhost:19888/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置日志保留时间为 7 天 --&gt;&lt;property&gt; &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt; &lt;value&gt;604800&lt;/value&gt;&lt;/property&gt; 配置完后重启历史服务器和yarn 1234$ mapred --daemon stop historyserver$ stop-yarn.sh$ stop-yarn.sh$ mapred --daemon start historyserver 总体验证使用hadoop提供的示例程序验证功能是否都正常 123456789101112# 创建wordcount，填入内容$ vim wordcounthahalalaheiheiheiheihiehiegaga# 将wordcount上传到hdfshdfs dfs -put wordcount /wcoutput# 执行任务$ hadoop jar /opt/hadoop/hadoop-3.3.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.4.jar wordcount /wordcount /wcoutput 然后进入 http://localhost:8088/ 界面可以看到进行中的任务，等任务执行完毕后点击后面的 history，如果跳转成功，说明历史服务启动成功。接着在跳转到的界面点击中间那栏最右边的logs，如果跳转成功，说明日志聚集开启成功 Docker集群部署安装过程新建一个文件夹，创建一个 shell脚本 12$ mkdir hadoop-docker$ vim hadoop.sh 拷贝如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297# 生成的镜像名字image_name=hadoop-test:0.1# 从节点数datanode_num=1# docker网络名network_name=hadoopnet# hadoop 版本hadoop_version=3.3.4# hadoop主节点名称namenode_name=hadoop-namenodedatanode_name=hadoop-datanode# 解压后的hadoop包名字（最好别改）hadoop_name=hadoop-$hadoop_version# hadoop安装包网络路径hadoop_url=https://dlcdn.apache.org/hadoop/common/${hadoop_name}/${hadoop_name}.tar.gzdocker network create --subnet=172.19.0.0/24 ${network_name}while getopts &quot;:dn:hv&quot; optdo case $opt in dn) datanode_num=$opt ;; hv) hadoop_version=$opt ;; ?) exit 1;; esacdoneif [ $datanode_num -lt 1 ]; then echo 'dn参数值至少为1' exit 1fi# hadoop下载部分if [ -e ${hadoop_name}.tar.gz ]; then re_download='n' read -p &quot;检测到已存在${hadoop_name}.tar.gz文件,是否重新下载?[y/n]&quot; re_download if [[ $re_download == 'y' ]]; then # 重新下载 rm -f ${hadoop_name}.tar.gz sudo dnf install wget -y dnf install wget -y # 下载hadoop wget -O ${hadoop_name}.tar.gz $hadoop_url fielse sudo dnf install wget -y # 下载hadoop wget -O ${hadoop_name}.tar.gz $hadoop_url fi# 生成docker镜像部分skip_docker_build='n'read -p '是否跳过dockerfile文件和镜像的生成?[y/n]' skip_docker_buildif [[ ${skip_docker_build} != 'y' ]]; then# 不跳过 echo &quot;不跳过&quot;tee Dockerfile &lt;&lt;ENDFROM fedoraLABEL &quot;maintainer&quot;=&quot;克里斯蒂安-宇&quot;#设置工作目录(hadoop存放在该目录)WORKDIR /opt/hadoop/# 更新包（可选）RUN dnf update -y &amp;&amp; dnf install openssh-server openssh-clients -y# 导入hadoopADD ${hadoop_name}.tar.gz /opt/hadoop/# 配置java环境RUN dnf install java-1.8.0-openjdk java-1.8.0-openjdk-devel -y# 配置环境变量RUN echo export JAVA_HOME=&quot;/usr/lib/jvm/jre-openjdk&quot; &gt;&gt; ~/.bashrcRUN echo export HADOOP_HOME=&quot;/opt/hadoop/hadoop-$hadoop_version&quot; &gt;&gt; ~/.bashrcRUN echo export 'PATH=\\$PATH:\\$HADOOP_HOME/bin' &gt;&gt; ~/.bashrcRUN echo export 'PATH=\\$PATH:\\$HADOOP_HOME/sbin' &gt;&gt; ~/.bashrcRUN source ~/.bashrcRUN echo 'vi /root/.ssh/authorized_keys' &gt;&gt; /opt/init.shRUN echo '/usr/sbin/sshd' &gt;&gt;/opt/init.shRUN chmod +x /opt/init.shENDecho &quot;运行Dockerfile&quot;docker build -f Dockerfile -t ${image_name} .fiskip_run_container='n'read -p '是否跳过容器的创建和运行?[y/n]' skip_run_containerif [[ ${skip_run_container} != 'y' ]]; then # 不跳过 echo &quot;开始创建容器...&quot; rm -f authorized_keys echo &quot;创建&quot;${namenode_name}&quot;...&quot; docker run --name ${namenode_name} --net ${network_name} --hostname ${namenode_name} -dit -p 50070:50070 -p 8088:8088 -p 9001:9001 -p 8030:8030 -p 8031:8031 -p 8032:8032 -p 9870:9870 -p 8042:8042 ${image_name} echo &quot;生成&quot;${namenode_name}&quot;的密钥...&quot; docker exec ${namenode_name} /bin/bash -c 'ssh-keygen -N &quot;&quot; -f /root/.ssh/id_rsa' docker exec ${namenode_name} /bin/bash -c 'ssh-keygen -A' docker exec ${namenode_name} /bin/bash -c 'echo StrictHostKeyChecking no &gt;&gt; /etc/ssh/ssh_config' docker cp ${namenode_name}:/root/.ssh/id_rsa.pub ./${namenode_name}-id_rsa.pub cat ./${namenode_name}-id_rsa.pub &gt;&gt; authorized_keys echo &quot;创建datanode...&quot; for((i=1;i&lt;=${datanode_num};i++)); do nodename=${datanode_name}-${i} echo &quot;创建&quot;${nodename}&quot;...&quot; docker run --name ${nodename} --net ${network_name} --hostname ${nodename} -dit ${image_name} echo &quot;生成&quot;${nodename}&quot;的密钥...&quot; docker exec ${nodename} /bin/bash -c 'ssh-keygen -N &quot;&quot; -f /root/.ssh/id_rsa' docker exec ${nodename} /bin/bash -c 'ssh-keygen -A' docker exec ${nodename} /bin/bash -c 'echo StrictHostKeyChecking no &gt;&gt; /etc/ssh/ssh_config' docker cp ${nodename}:/root/.ssh/id_rsa.pub ./${nodename}-id_rsa.pub cat ./${nodename}-id_rsa.pub &gt;&gt; authorized_keys done echo &quot;正在运行的容器如下：&quot; docker ps | grep hadoop-fiskip_config_hadoop='n'read -p '是否跳过hadoop的配置和初始化(当前目录如果已经存在配置文件则不会自动生成)?[y/n]' skip_config_hadoopif [[ ${skip_config_hadoop} != 'y' ]]; then# 不跳过echo &quot;生成配置文件&quot;if [ -e core-site.xml ]; then echo '检测到core-site.xml文件'elsetee core-site.xml &lt;&lt;EOF&lt;configuration&gt; &lt;!-- 用来指定hdfs的老大(NameNode)的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://${namenode_name}:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 用来指定Hadoop运行时产生文件的存放目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hadoop-${hadoop_version}/tmp/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;131702&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFfiif [ -e hdfs-site.xml ]; then echo '检测到hdfs-site.xml文件'elsetee hdfs-site.xml &lt;&lt;EOF&lt;configuration&gt; &lt;!-- 指定HDFS保存数据副本数量 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/opt/hadoop/hadoop-${hadoop_version}/data/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/opt/hadoop/hadoop-${hadoop_version}/name/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;${namenode_name}:9001&lt;/value&gt; &lt;/property&gt; &lt;!-- 是否开启权限检查 --&gt; &lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFfiif [ -e mapred-site.xml ]; then echo '检测到mapred-site.xml文件'elsetee mapred-site.xml &lt;&lt;EOF&lt;configuration&gt; &lt;!-- 告诉hadoop以后MR运行在yarn上 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;!-- 历史服务器端地址 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;${namenode_name}:10020&lt;/value&gt; &lt;/property&gt; &lt;!-- 历史服务器 web 端地址 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;${namenode_name}:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFfiif [ -e yarn-site.xml ]; then echo '检测到yarn-site.xml文件'elsetee yarn-site.xml &lt;&lt;EOF&lt;configuration&gt; &lt;!-- NodeManager获取数据的方式是shuffle--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定YARN的老大(resourcemanager)的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;${namenode_name}&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 设置日志聚集服务器地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://localhost:19888/jobhistory/logs&lt;/value&gt; &lt;/property&gt; &lt;!-- 设置日志保留时间为 7 天 --&gt; &lt;property&gt; &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt; &lt;value&gt;604800&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;EOFfiif [ -e hadoop-env.sh ]; then echo '检测到hadoop-env.sh文件'elsetee hadoop-env.sh &lt;&lt;EOFexport HDFS_NAMENODE_USER=rootexport HDFS_DATANODE_USER=rootexport HDFS_SECONDARYNAMENODE_USER=rootexport YARN_RESOURCEMANAGER_USER=rootexport YARN_NODEMANAGER_USER=rootexport JAVA_HOME=/usr/lib/jvm/jre-openjdkEOFfiecho &quot;将配置文件移动到容器...&quot;docker cp core-site.xml ${namenode_name}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/core-site.xmldocker cp hdfs-site.xml ${namenode_name}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/hdfs-site.xmldocker cp mapred-site.xml ${namenode_name}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/mapred-site.xmldocker cp yarn-site.xml ${namenode_name}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/yarn-site.xmldocker cp hadoop-env.sh ${namenode_name}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/hadoop-env.shfor((i=1;i&lt;=${datanode_num};i++)); do nodename=${datanode_name}-${i} docker cp core-site.xml ${nodename}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/core-site.xml docker cp hdfs-site.xml ${nodename}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/hdfs-site.xml docker cp mapred-site.xml ${nodename}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/mapred-site.xml docker cp yarn-site.xml ${nodename}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/yarn-site.xml docker cp hadoop-env.sh ${nodename}:/opt/hadoop/hadoop-$hadoop_version/etc/hadoop/hadoop-env.shdonefirm -f yarn-site.xmlrm -f mapred-site.xmlrm -f hdfs-site.xmlrm -f core-site.xmlrm -f hadoop-env.shrm -f Dockerfileecho &quot;删除${namenode_name}-id_rsa.pub&quot;rm -f &quot;${namenode_name}-id_rsa.pub&quot;for((i=1;i&lt;=${datanode_num};i++)); do echo &quot;删除${datanode_name}-${i}-id_rsa.pub&quot; rm -f &quot;${datanode_name}-${i}-id_rsa.pub&quot;done# 收尾工作，删除多余的包auto_delete='n'read -p '是否删除多余的包?[y/n]' auto_deleteif [[ ${auto_delete} == 'y' ]]; then rm -f ${hadoop_name}.tar.gz # rm -f authorized_keysfi 运行脚本 1$ ./hadoop.sh 执行完脚本后会创建多个容器（一个namenode和多个datanode），然后进入每个容器中 123456$ docker exec -it hadoop-namenode bash# 执行该命令打开一个文件，将目录中生成的authorized_keys文件内容拷贝进去保存即可$ /opt/init.sh# 对于datanode执行同样操作$ docker exec -it hadoop-datanode-1 bash$ /opt/init.sh 进入namenode容器执行如下命令 12345678# 初始化$ hdfs namenode -format# 启动$ start-all.sh# 启动历史服务器$ mapred --daemon start historyserver# 历史服务器关闭$ mapred --daemon stop historyserver 集群部署点击此处跳转到官方提供的集群搭建文档","link":"/2022/09/27/%E6%A1%86%E6%9E%B6/Java/Hadoop/Hadoop%E9%83%A8%E7%BD%B2/"},{"title":"函数","text":"函数、内置函数 函数定义基本语法12345def f(形参列表): &quot;&quot;&quot;文档字符串&quot;&quot;&quot; 方法体 # return语句不带表达式参数或者不写时，返回None return return 语句返回函数的值，函数执行完毕退出也返回 None； 函数形参默认形参调用函数时，可以为参数指定默认值 12345def f(p1, p2, p3=&quot;默认值&quot;): &quot;&quot;&quot;文档字符串&quot;&quot;&quot; print(p1) print(p2) print(p3) 默认值需要从右往左声明，也就是说一个参数如果声明了默认值，那么这个参数右边的参数都要声明默认值； 在方法调用时声明了默认值的形参是可选参数，未声明默认值的参数是必选参数； 命名形参可以通过形参名=value 的形式传递参数 123456# 此时参数的顺序并不重要f(p1=2,p2=5)# 等同于f(p2=5,p1=2)# 混合传参f(3,p2=5) 对于一个参数不能多次赋值，否则报错； 特殊参数默认情况下，参数可以按位置或显式关键字传递给 Python 函数； 12def f(p1, p2, /,p3, *, p4, p5): pass / 和 * 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。 函数定义中未使用 / 和 * 时，参数可以按位置或关键字传递给函数。 仅限位置形参： / 前面是仅限位置形参，这些形参不能用关键字传递；/ 后可以是位置或关键字或仅限关键字形参； 仅限关键字参数：把形参标记为 仅限关键字，表明必须以关键字参数形式传递该形参， *后面的是仅限关键字参数。 任意实参列表*args 接收一个元组， **args 接收一个字典 1234567def f(p1, *p2, **p3): &quot;&quot;&quot;文档字符串&quot;&quot;&quot; print(p1) print(p2) print(p3)f(&quot;p1&quot;, &quot;p2-1&quot;, &quot;p2-2&quot;, p3_1=&quot;p3-1&quot;, p3_2=&quot;p3-2&quot;, p3_3=&quot;p3-3&quot;) *args 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数 12345def f(p1, *p2, p3): passf(&quot;p1&quot;, &quot;p2-1&quot;, &quot;p2-2&quot;, &quot;p3&quot;) # 报错f(&quot;p1&quot;, &quot;p2-1&quot;, &quot;p2-2&quot;, p3=1) # 正确 函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作，用 * 操作符把实参从列表或元组解包出来： 12345def f(p1, *p2, p3): print(p2) # ('p2-1', 'p2-2')p2 = [&quot;p2-1&quot;, &quot;p2-2&quot;]f(&quot;p1&quot;, *p2, p3=1) 字典可以用 ** 操作符传递关键字参数 12345def f(p1, p2, **p3): print(p3) # {'p3_1': 'p3-1', 'p3_2': 'p3-2', 'p3_3': 'p3-3'}map = {&quot;p3_1&quot;: &quot;p3-1&quot;, &quot;p3_2&quot;: &quot;p3-2&quot;, &quot;p3_3&quot;: &quot;p3-3&quot;}f(&quot;p1&quot;, &quot;p2-1&quot;, **map) 补充： 函数在执行时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中。当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表； 变量引用顺序：局部符号表-&gt;外层函数局部符号表-&gt;全局符号表-&gt;内置名称符号表； 尽管可以在函数内引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是global语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）； 在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中 实参传递的是引用的值； 文档字符串函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring。利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档 12345678910def f(): #第一行应为对象用途的简短摘要。 &quot;&quot;&quot;Do nothing, but document it. # 文档字符串为多行时，第二行应为空白行 # 后面的行可包含若干段落，描述对象的调用约定、副作用等。 No, really, it doesn't do anything. &quot;&quot;&quot; pass 内置函数 方法名 说明 type(var) 返回var类型 isinstance(var,type) 返回var是否是type类型（包含父类）","link":"/2020/02/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/"},{"title":"异常处理","text":"异常处理 try 语句1234567try: pass# 可以有多个exceptexcept ValueError as ve: # 指定异常实例 print(type(ve)) # 异常实例 print(ve.args) # 参数存储在args中 print(ve) # 打印结果同ve.args try语句执行流程： 首先执行try子句； 如果没有异常，则跳过except子句； 如果发生异常，则跳过该子句中剩下部分： 如果异常类型与except子句指定的异常相匹配，则执行except子句； 如果不匹配则会被传递到外部try语句中，如果外部没有try子句则执行终止并输出异常信息； else 子句else子句必须放在所有 except 子句之后。 它适用于try子句没有引发异常但又必须要执行的代码 1234567try: passexcept ValueError: pass# 没发生异常时执行else: pass finally 子句finally 子句用于定义在所有情况下都必须要执行的清理操作 1234try: raise KeyboardInterruptfinally: print('Goodbye, world!') 复杂场景： 如果执行 try 子句期间触发了某个异常，并且没有 except 子句处理，在 finally 子句执行后会被重新触发； except 或 else 子句执行期间也会触发异常。 同样，该异常会在 finally 子句执行之后被重新触发； 如果 finally 子句中包含 break、continue 或 return等语句 异常将不会被重新引发。 finally 子句在执行 break、continue 或 return 语句之前执行。 如果 finally 子句中包含 return 语句，则返回值来自 finally 子句的某个 return 语句的返回值，而不是来自 try 子句的 return 语句的返回值。 raise 语句raise 用来触发指定的异常 12# 参数必须是异常实例或异常类，将通过调用没有参数的构造函数来隐式实例化raise NameError('HiThere') 如果只想判断是否触发了异常，但并不打算处理该异常 123456try: pass# 可以有多个exceptexcept ValueError as ve: # 指定异常实例 # 抛出异常 raise from 子句raise 语句支持可选的 from 子句，用于启动链式异常 1raise RuntimeError from exc 可用于转换异常 1234try: raise ConnectionErrorexcept ConnectionError as exc: raise RuntimeError('Failed to open database') from exc","link":"/2020/02/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"文件读写","text":"文件读写 打开文件通常使用open(filename, mode)函数读写文件 filename：文件名字符串； mode：使用方式默认为 r r：表示文件只能读取； w：表示只能写入（现有同名文件会被覆盖）； a：表示打开文件并追加内容，任何写入的数据会自动添加到文件末尾； r+：表示打开文件进行读写； 文件默认以文本模式打开，如果想通过二进制模式打开可以在mode中追加 'b'； 文本模式中读取文件时，默认把平台特定的行结束符（Unix 上为 \\n, Windows 上为 \\r\\n）转换为 \\n。写入数据时，默认把 \\n 转换回平台特定结束符。这种操作方式在后台修改文件数据对文本文件来说没有问题，但会破坏 JPEG 或 EXE 等二进制文件中的数据。注意，在读写此类文件时，一定要使用二进制模式。 在处理文件对象时，最好使用 with 关键字。优点是，子句体结束后，文件会正确关闭，即便触发异常也可以。而且，使用 with 相比等效的 try-finally代码块要简短得多： 12with open('workfile') as f: read_data = f.read() 文件对象操作方法 方法名 作用 f.read(size) 读取文件内容， f.readline() 从文件中读取单行数据，字符串末尾保留换行符 f.write(string) 把 string 的内容写入文件，并返回写入的字符数。 f.tell() 返回整数，给出二进制文件从文件开始的字节数（读写位置） f.seek(offset, whence) 改变读写位置 f.read(size) 省略 size 或 size 为负数时，读取并返回整个文件的内容，文件大小是内存的两倍时，会出现问题。如已到达文件末尾，则返回空字符串 1f.read() f.seek(offset, whence) offset表示计算位置 whence表示参考点 0 ：表示从文件开头计算 1 ：表示使用当前文件位置 2 ：表示使用文件末尾作为参考点 1234f = open('workfile', 'rb+')f.write(b'0123456789abcdef')f.seek(-3, 2) # 文件末尾开始倒数第三个位置f.read(1) # b'd'","link":"/2020/02/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"title":"模块系统","text":"模块、包 Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是模块；模块中的定义可以导入到其他模块或主模块。模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 .py 。在模块内部 在模块内部，通过全局变量 __name__ 可以获取模块名（即字符串） 123# 导入m1模块import m1 as mprint(m.__name__) # m1 模块导入基本语法（1）导入模块使用import语句，一般import会放在模块开头，但不强制要求 12# 导入的模块名存在当前模块的全局符号表里。import 模块名 （2）导入模块内定义的指定名称（import语句变体） 12# 可以直接把模块里的对应名称导入到当前模块的符号表。from 模块名 import 名称 （3）导入模块内定义的所有名称（import语句变体） 12# 这种方式会导入所有不以下划线（_）开头的名称。并加入到符号表from 模块名 import * （4）导入模块并起别名 12# 之后可以通过别名来使用模块import 模块名 as 别名 （5）执行模块代码 1python 文件名 &lt;arguments&gt; arguments参数： -O 去除断言语句 -OO 去除断言语句和 doc 字符串 模块加载模块搜索路径导入m模块时，解析器查找顺序如下： 查找名为m的内置模块 从sys.path变量中的目录列表里查找m.py文件 已编译文件缓存为了快速加载模块，Python 把模块的编译版缓存在 __pycache__ 目录中，文件名为 module.version.pyc，version：一般为 Python 的版本号。Python 对比编译版本与源码的修改日期，查看它是否已过期，是否要重新编译。 python在以下两种情况下不查缓存： 从命令行直接载入模块，只重新编译，不存储编译结果； 没有源模块，就不会检查缓存。 获取模块定义的名称使用dir()函数可以查找模块定义的名称，返回结果是经过排序的字符串列表 12345678import m1 as mprint(dir(m))# 得到的是该函数所有类型的名称：变量、模块、函数等。['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'f1', 'v']#没有参数时，dir() 列出当前定义的名称print(dir()) 包包就是一个模块集，一个包中包含多个模块，可以通过模块A.B的方式获取包A中名为B的子模块，导入包时，Python 搜索 sys.path 里的目录，查找包的子目录。 假设当前包结构如下： 12345678910111213141516p/ # 顶级包 __init__.py # 初始化顶级包 p1/ # 子包 __init__.py # 模块 m1.py m11.py m111.py ... p2/ # 子包 __init__.py m2 ... p3/ # 子包 __init__.py m3 ... 导入包导入包时，Python 搜索 sys.path 里的目录，查找包的子目录。Python 只把含 __init__.py 文件的目录当成包，其中 __init__.py 可以为空，文件也可以执行初始化代码。 加载子模块方式123456789101112131415# 1、import 包名.模块名import p.p1.m1# 使用时需要使用全类名：p.p1.m1# 起别名后，可以直接使用别名import p.p1.m1 as m# 2、from 包名 import 模块名（推荐用法）from p.p1 import m1# 使用时直接使用模块名# 3、from 包名.模块名 import 函数或变量from p.p1.m1 import f1# 之后可以直接使用函数或变量f1() 从包中导入 *import 语句使用如下规则： 如果包的 __init__.py 代码定义了列表 __all__ 12# 即，from p.p1 import * 将导入 p 包中的这三个命名子模块。__all__ = [&quot;m1&quot;, &quot;m11&quot;, &quot;m111&quot;] 如果没有定义 __all__，from p.p1 import * 语句 不会 把包 p.p1 中所有子模块都导入到当前命名空间。 该语句只会确保导入包p.p1（可能还会运行 __init__.py 中的初始化代码），然后，再导入包中定义的名称； 这些名称包括 __init__.py 中定义的任何名称（以及显式加载的子模块），还包括import语句加载的模块； 子包包中含有多个子包时，可以使用绝对导入引用兄弟包中的子模块。例如，在m2模块中想引入m1模块，可以使用如下代码 1from p1 import m1 还可以用 import 语句的 from module import name 形式执行相对导入，例如在m1中 1234567# . 和 .. 都是相对于当前模块位置而言的# 当前路径下的m11模块from . import m11# 当前的../路径下的p1包from .. import p1# 当前的../p1路径下的m11模块from ..p1 import m11 补充： 模块有自己的私有符号表，用作模块中所有函数的全局符号表，因此，不同模块的全局变量不会产生冲突； 为了保证运行效率，每次解释器会话只导入一次模块； 一些模块是内嵌到编译器里面的，不需要导入便可直接使用，例如sys； 有些模块依赖于底层操作系统，例如winreg模块只有在Windows上提供；","link":"/2020/02/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"},{"title":"流程控制","text":"变判断语句、循环语句、跳转语句、pass语句 判断语句if 语句基本语法12345678910if 表达式: #表达式成立执行 代码块elif 表达式: #表达式成立执行 代码块……else: #上面条件都不满足执行 代码块 if/elif 中的表达式只有为0或False时不进入代码块，其他情况下都进入 elif 和 else 可以省略 match 语句基本语法1234567match status: # 表达式：可以是任何类型 case 1: # 匹配条件 print('1') case 2: print('2') case _: # _ 作为通配符，必定匹配成功，相当于default print('3') 匹配模式case后定义匹配条件可以有多种模式 字面量：case ‘字面量’ 使用 |或 or 组合字面量：case 401 | 403 | 404 模式的形式可以是解包赋值，读取模式的推荐方式是将它们看做是你会在赋值操作左侧放置的内容的扩展形式，以便理解各个变量将会被设置的值。 123456789101112131415161718192021222324# 此处定义一个元组，也可以是其他类、列表等任意序列，并且可以相互嵌套# 唯一例外是它们不能匹配迭代器或字符串。point = (1,2)# case可以通过解包赋值的形式获取元组中的数据match point: case (0, 1): # 第1个元素是0，第2个元素是1 print(&quot;Origin&quot;) case (0, y): # 第一个元素是0，第二个元素之赋值 print(f&quot;Y={y}&quot;) case (x, 0): print(f&quot;X={x}&quot;) case (x, y): print(f&quot;X={x}, Y={y}&quot;) case _: raise ValueError(&quot;Not a point&quot;)# point是类时，可以使用类名之后跟一个类似于构造器的参数列表class Point: x: int y: intmatch point: case Point(x=x, y=0): # 赋值x，匹配y print(x) case Point(): # 不匹配x,y print(&quot;Somewhere else&quot;) 我们可以向一个模式添加 if 子句，称为“守护项”。 如果守护项为假值，则 match 将继续尝试下一个 case 语句块 12345match point: case Point(x, y) if x == y: # 如果x==y不成立，那么会跳过当前case print(f&quot;Y=X at {x}&quot;) case Point(x, y): print(f&quot;Not on the diagonal&quot;) 子模式可使用 as 关键字来捕获 12# 将把输入的第二个元素捕获为 p2 (只要输入是包含两个点的序列)case (Point(x1, y1), Point(x2, y2) as p2): ... 大多数字面值是按相等性比较的，但是单例对象 True, False 和 None 则是按标识号比较的。True也会匹配到 1，False也会匹配到 0 模式可以使用命名常量。 这些命名常量必须为带点号的名称以防止它们被解读为捕获变量todo 123456789101112131415from enum import Enumclass Color(Enum): RED = 'red' GREEN = 'green' BLUE = 'blue'color = Color(input(&quot;Enter your choice of 'red', 'blue' or 'green': &quot;))match color: case Color.RED: print(&quot;I see red!&quot;) case Color.GREEN: print(&quot;Grass is green&quot;) case Color.BLUE: print(&quot;I'm feeling the blues :(&quot;) 循环语句while 循环基本语法12while 条件表达式: 循环体 for 循环基本语法Python 的 for 语句不迭代算术递增数值，而是迭代列表或字符串等任意序列，元素的迭代顺序与在序列中出现的顺序一致。 1234# for循环用于遍历元素序列中的数据# 这里元素序列包括字符串，如果是字符串那么会按照字符进行遍历for 变量 in 元素序列: 循环体 遍历某个集合的同时修改该集合的内容，很难获取想要的结果。要在遍历时修改集合的内容，应该遍历该集合的副本或创建新的集合： 12345678# 此时会报错，因为当i为2时会删除2，那么此时序列长度为2，但程序会继续遍历索引为3的位置# 解决方法是创建一个新的序列，然后将符合条件的值插入到新的序列中a = [1, 2, 3]for i in a: print(i) if i == 2: del a[i] 关联 else 子句关联else子句后如果 for 循环全部执行完毕则会执行else 中的语句，否则不会执行 12345for a in [&quot;a&quot;,&quot;b&quot;,&quot;v&quot;]: print(a)else: # else会在循环结束后执行 print(&quot;else&quot;) 主要用于在循环执行过程中，中途结束for循环，则else不执行，循环正常执行完毕后执行else。下面的例子中如果if语句成立则跳出循环，else不会执行 123456for a in [&quot;a&quot;,&quot;b&quot;,&quot;v&quot;]: print(a) if a.__eq__(&quot;a&quot;): breakelse: print(&quot;else&quot;) range 函数 range()函数用于遍历数据索引，通常配合 for 循环使用 12345678910range(stop) # 0 - stop-1range(start,stop) # start - stop-1range(start,stop,step) # start - stop-1 step(步长)# range()和len()函数结合使用，可以按索引迭代序列a = ['a', 'b', 'c', 'd', 'e']for i in range(len(a)): print(i, a[i]) range 函数并没有创建新的列表，而是生成了可迭代对象，在迭代时返回对应的索引，从而节省了空间。 补充： for循环通常用于迭代、枚举或遍历 跳转语句跳转语句： break ：用于跳出最近的 for 或 while 循环； continue ：表示继续执行循环的下一次迭代； pass 语句pass是空语句，是为了保持程序结构的完整性。本身不做任何操作。","link":"/2020/02/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"类型系统","text":"变量、整数类型、浮点类型、布尔类型、复数类型、字符串、列表、元组、集合、字典、类型可变性 变量12345678#【1】定义和赋值# 在 Python 中，每个变量 在使用前都必须赋值，否则编译不通过变量名 = 值#【2】变量中存储的值的类型可以改变，例如：# 这种是合法的a = 1a = &quot;aaa&quot; 补充： 变量包括：变量名、保存的数据、数据类型、变量地址 变量 赋值以后才会被创建，再次使用时才是为变量赋其他值 变量地址python中数据是存储在内存中的，每个数据都拥有自己的地址值，变量通过指向数据的地址值来引用数据，每次的赋值其实就是修改了变量的引用 123456789101112131415161718192021//id()查看的是当前变量的地址值//不可变类型a = 1b = 1print(id(a)) //1904277782768print(id(b)) //1904277782768//可变类型//示例1//可变类型引用的地址各不相同a = [1, 2, 3]b = [1, 2, 3]print(id(a)) //2111033692608print(id(b)) //2111036813312//示例2//每次都会在内存中创建新的值a = [1, 2, 3] //2617522115008print(id(a))a = [1, 2, 3] //2617525235712print(id(a)) 不可变类型：a和b都指向 1 ，并且a和b的地址值相同，这说明 1 存储在在内存中地址为 1904277782768 的位置，a和b都引用或者说指向了该地址 可变类型：可变类型即便值相同，在内存中所存储的位置也不同，因为不可变类型在声明后就不会发生变化，多个变量引用一个地址即可，但可变类型的值可能在使用过程中发生变化，所以每次声明都会创建新的对象 命名规则 可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 作用域局部名称：函数中定义的名称 全局名称：模块级的变量和常量 作用域查找规则： 最内部作用域的局部名称 外层作用域 全局作用域 内置命名空间 global 语句和 nonlocal 语句global 语句可被用来表明特定变量生存于全局作用域 nonlocal 语句表明特定变量生存于外层作用域中 12345678910111213141516171819202122def scope_test(): def do_local(): spam = &quot;local spam&quot; def do_nonlocal(): nonlocal spam spam = &quot;nonlocal spam&quot; def do_global(): global spam spam = &quot;global spam&quot; spam = &quot;test spam&quot; do_local() print(&quot;After local assignment:&quot;, spam) do_nonlocal() print(&quot;After nonlocal assignment:&quot;, spam) do_global() print(&quot;After global assignment:&quot;, spam)scope_test()print(&quot;In global scope:&quot;, spam) 输出结果： 1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 整数类型 类型 有无符号 空间占用 取值范围 int 有 24 ~ ∞ 自动扩容 python的整型的占用空间会根据值的大小动态地进行调整：每增加30bit扩容一次（每次扩容增加4个Byte的空间） 123456789101112131415161718//sys.getsizeof()方法用来返回底层占用内存的字节数，并不是取值大小//初始空间占用位24Bytea = 0print(sys.getsizeof(a)) //24print(type(a)) //&lt;class 'int'&gt;a = 1print(sys.getsizeof(a)) //28//此时是28位最大的数：2的30次方-1a = 2**30 - 1print(sys.getsizeof(a)) //28a = 2**30print(sys.getsizeof(a)) //32a = 2**60 - 1print(sys.getsizeof(a)) //32a = 2**60print(sys.getsizeof(a)) //36 整数类型进制表示方式： 二进制：以0b或0B开头 八进制：以0o或0O开头 十六进制：以0x或0X开头 补充： python底层定义了一个PyLongObject类型的静态数组作为整数池，存储了 [-5,256] 区间的整数 浮点类型 类型 空间占用 精度 float 24bit 17位 python中浮点数使用科学计数法保存，空间占用永远是24bit当数据长度较大时会保留17位（1位整数，16位小数） 1234a = 123456789123456789.123456789123print(a) //1.2345678912345678e+17print(sys.getsizeof(a)) //24print(type(a)) //&lt;class 'float'&gt; 布尔类型 类型 空间占用 取值范围 bool 28bit True/False 1234a = Trueprint(a) //Trueprint(sys.getsizeof(a)) //28print(type(a)) //&lt;class 'bool'&gt; 复数类型 类型 空间占用 取值范围 complex 复数由实部（real）和虚部（imag）组成，其中实部和虚部都是浮点数类型 a + bj/J 形式1234a = 123 + 321jprint(a) //(123+321j)print(sys.getsizeof(a)) //32print(type(a)) //&lt;class 'complex'&gt; complex(123, 321) 形式其中real可以为int、float或str类型，而image只能为int或float类型。如果第一个参数为字符串，第二个参数必须省略，否则会报错 1234a = complex(123, 321)print(a) //(123+321j)print(sys.getsizeof(a)) //32print(type(a)) //&lt;class 'complex'&gt; 字符串 类型 空间占用 str 49 ~ ∞ 1234567891011121314# 1、双引号声明s1 = &quot;双引号&quot;# 2、单引号声明s2 = '单引号'# 3、声明多行s3 = &quot;&quot;&quot;声明多行1&quot;&quot;&quot;s4 = '''声明多行2'''# 4、上面的引号都可以相互嵌套使用s1 = '&quot;嵌套&quot;' # &quot;嵌套&quot; Python 没有字符类型，单字符也是字符串 在字符串开头的引号/三引号前添加f/F。在这种字符串中，可以使用 {} 引用变量或表达式,格式说明符是可选的，写在表达式后面，可以更好地控制格式化值的方式 1234567891011121314151617a = 3print(F&quot;引用变量：{a}&quot;)# 使用格式说明符# 保留小数pi = 3.141592653print(f&quot;{pi:.3f}&quot;) # 3.142# 在 : 后传递整数，表示设置最小字符宽度，用于列对齐pi = 3.14print(f&quot;{pi:5}&quot;) # 3.14前面多了两个空格# 使用修饰符做格式化传唤# '!a' 应用 ascii() ，'!s' 应用 str()，'!r' 应用 repr()animals = 'eels'print(f'{animals!r}') # 'eels' 转义字符12345# 1、使用转义字符s = &quot;转义字符\\'t,&quot;# 2、原始字符串：如果不希望前置 \\ 的字符转义成特殊字符，在引号前添加 r 即可：print(r'C:\\some\\name') # C:\\some\\name 字符编码python中的默认字符编码是 utf-8，通过sys.getdefaultencoding()可以获取到 1print(sys.getdefaultencoding()) //utf-8 转义字符 转义字符 含义 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 空间占用python中空串的大小为49bit，空间占用大小会随着字符串长度不同而增加 123a = &quot;&quot;print(sys.getsizeof(a)) //49print(type(a)) //&lt;class 'str'&gt; 拼接123456789# 1、字符串可以用 + 进行拼接a = &quot;hello&quot; + &quot; world&quot; //&quot;hello world&quot;# 2、使用 `*` 重复拼接相同的字符串c = &quot;-&quot; //&quot;----------&quot;# 3、相邻的两个或多个字面量会自动合并# 这个功能只适用于字面量，变量不行s = 'Py' 'thon' # 'Python' 检索字符串索引 1234567# 字符串支持 索引 （下标访问），第一个字符的索引是 0。# 索引越界会报错word = 'Python'word[0] # P# 索引还支持负数，用负数索引时，从右边开始计数：word[-1] # n 字符串切片 12345678910111213# 索引可以提取单个字符，切片 则提取子字符串：# 如果指定end，那么输出结果是左闭右开区间word = 'Python'word[:2] # [0,2)word[4:] # [2,end]word[-2:] # [-2,end]# 索引如下图所示+---+---+---+---+---+---+| P | y | t | h | o | n |+---+---+---+---+---+---+ 0 1 2 3 4 5 6 -6 -5 -4 -3 -2 -1 类型转换 方法名 作用 int(str) 将str转换为int float(str) 将str转换为float bool(str) str为空串时返回False，其他情况全为True complex(str) 返回复数，格式为 a + 0j 列表列表是用方括号标注，逗号分隔的一组值。 1234567# 列表可以包含不同类型的元素，但一般情况下，各个元素的类型相同squares = [1, 4, 9, 16, 25]# 嵌套列表a = ['a', 'b', 'c']n = [1, 2, 3]x = [a, n] # [['a', 'b', 'c'], [1, 2, 3]] 拼接列表支持拼接操作： 1squares + [36, 49, 64, 81, 100] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 索引123456# 检索squares[0] # 1squares[-1] # 25# 可以直接通过索引进行赋值squares[0] = 9 切片1234567# 切片操作返回包含请求元素的新列表，注意是浅拷贝squares[-3:] # [9,16,25]# 为切片赋值可以改变列表大小，甚至清空整个列表letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']letters[2:5] = ['C', 'D', 'E'] # ['a', 'b', 'C', 'D', 'E', 'f', 'g']letters[:] = [] # [] 用列表实现堆栈 入栈：stack.append(x) 出栈：stack.pop() 用列表实现队列 入队列：queue.append(“Terry”) 出队列：queue.popleft() 补充： insert、remove、sort 等方法只修改列表，不输出返回值——返回的默认值为 None 不是所有数据都可以排序或比较。例如，[None, 'hello', 10] 就不可排序，因为整数不能与字符串对比，而 None不能与其他类型对比。有些类型根本就没有定义顺序关系，例如，3+4j &lt; 5+7j 这种对比操作就是无效的。 元组元组由多个用逗号隔开的值组成 123456t = 123, &quot;123&quot;, 2.3print(t) # (123, '123', 2.3)# 构造 0 个或 1 个元素empty = ()singleton = 'hello', 输出时，元组都要由圆括号标注，输入时，圆括号可有可无，不过经常是必须的; 不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组； 元组与列表很像，但使用场景不同，用途也不同； 元组是不可变的，一般可包含异质元素序列，通过解包或索引访问；列表是可变的 集合创建集合用花括号或 set()函数。 123456789# 方式1a = {123,456,&quot;aa&quot;}print(a) # {456, 123, 'aa'}# 方式2a = set('abracadabra')print(a) # {'d', 'c', 'b', 'a', 'r'} set集合中的值是唯一的# 创建空集合只能用 `set()`a = set() 集合操作1234567891011a = set('abc')b = set('cde')# 去除print(a-b) # {'a', 'b'}# 并集print(a|b) # {'d', 'c', 'e', 'a', 'b'}# 交集print(a&amp;b) # {'c'}# 取交集再对a和b进行去除print(a^b) # {'e', 'b', 'd', 'a'} 字典12345678910111213# 方式1：使用花括号{}创建字典d = {'k1': &quot;v1&quot;, 'k2': &quot;v2&quot;}#用于创建空字典d = {}# 方式2：dict()构造函数创建字典# 可以直接用键值对序列d = dict([('k1', &quot;v1&quot;), ('k2', &quot;v2&quot;)])# 关键字是比较简单的字符串时，直接用关键字参数指定键值dict(k1=&quot;v1&quot;, k2=&quot;v2&quot;)# 方式3：字典推导式{x: x**2 for x in (2, 4, 6)} # {2: 4, 4: 16, 6: 36} 字典以关键字为索引，关键字通常是字符串或数字，也可以是其他任意不可变类型； 只包含字符串、数字、元组的元组，也可以用作关键字。但如果元组直接或间接地包含了可变对象，就不能用作关键字； 可以把字典理解为键值对的集合，字典的键必须是唯一的； 检查字典里是否存在某个键，使用关键字 in或not in； 检索1234# 用已存在的关键字存储值，与该关键字关联的旧值会被取代。通过不存在的键提取值，则会报错。d = {'k1': &quot;v1&quot;, 'k2': &quot;v2&quot;}print(d[&quot;k1&quot;]) # v1print(d[&quot;k3&quot;]) # 报错 删除1234# 用 del 可以删除键值对d = {'k1': &quot;v1&quot;, 'k2': &quot;v2&quot;}del d[&quot;k2&quot;]print(d) # {'k1': 'v1'} 类型可变性类型可变性是指变量所指向在内存中的数据是否允许被修改 不可变数据类型： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变数据类型： 列表 list 字典 dict 集合：Set 补充： Python 中内置的哈希函数（ hash(o) ），接收一个 不可变类型 的数据作为 参数，返回 结果是一个 整数","link":"/2020/02/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"运算符","text":"算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、成员运算符、比较运算符、运算符优先级 算术运算符 运算符 说明 + 正号/字符串拼接/加号 - 负号/减号 * 乘/字符串拼接 / 除，结果为浮点数 // 取整 % 取模 ** 幂运算 *和**解包使用可以对序列和字典进行解包 1234table = {'p1': 123, 'p2': '321'}print(table) # {'p1': 123, 'p2': '321'}print(*table) # p1 p2print('{p1}'.format(**table)) # 123 %用于格式化字符串1print('%5.3f.' % math.pi) 关系运算符 运算符 说明 == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 逻辑运算符 运算符 说明 and 与 or 或 not 非 位运算符 运算符 说明 &amp; 按位与 | 按位或 ^ 按位异或（不同为1） ~ 按位取反 &lt;&lt; 左移（乘2，无论正负） &gt;&gt; 右移（除2，无论正负） 补充： 数据底层使用补码存储，所以位运算都是操作的补码 赋值运算符 运算符 说明 = 赋值 += 相加赋值 -= 相减赋值 *= 相乘赋值 /= 相除赋值 %= 取模赋值 //= 取整赋值 **= 幂运算沪指 多重赋值12# 通过逗号间隔可以为多个变量赋值a, b = 0, 1 成员运算符 运算符 说明 in 当在指定的序列中找到值时返回 True,否则返回 False not in 当在指定的序列中未找到值时返回 True,否则返回 False 比较运算符 运算符 说明 is 两个标识符如果引用的是同一个对象则返回 True，否则返回 False is not 两个标识符如果引用的不是同一个对象则返回 True，否则返回 False 运算符优先级 运算符 描述 ** 幂 ~ 按位“取反” *、/、%、// 乘、除、取模、取整除 +、- 加、减 &gt;&gt;、&lt;&lt; 右移、左移 &amp; 按位“与” ^、| 按位“异或”、按位“或” &lt;=、&lt;、&gt;、&gt;= 比较运算符 ==、!= 等于、不等于 =、%=、/=、//=、-=、+=、*=、**= 赋值运算符 is、is not 身份运算符 in、not in 成员运算符 and、or、not 逻辑运算符","link":"/2020/02/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"面向对象","text":"类、继承、类内置方法 类类定义12345678910class ClassName: # 定义属性和函数 &quot;&quot;&quot;一个类&quot;&quot;&quot; i = 123 def f(self): print(&quot;f&quot;) # 初始化方法 def __init__(self): print(&quot;初始化&quot;) 类定义和函数定义一样几乎可以写在任何地方，并且只有执行才会起作用 12345678910def f1(): class C1: print(&quot;C1&quot;)# 只有调用f1()方法类才会输出C1f1()# 通过 类名.属性名 获取属性和函数对象# 通过赋值改变类中的变量值c1.i = 321c1.f()c1.__doc__ # 获取文档字符串：&quot;一个类&quot; 类对象创建类的实例， 12# 返回该类的一个新实例c = ClassName() 如果类中定义了__init__(self)方法，会调用这个方法。类属性会在第一次被赋值时产生，一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法： 123456789101112131415161718192021class C1: # 创建类变量 a = &quot;aaa&quot; def __init__(self, b): # 创建实例变量 self.b = b def f(self, p): print(&quot;p=&quot;+p) # 方法别名 f1 = fc = C1(&quot;bbb&quot;)# 创建实例变量c.c = &quot;ccc&quot;print(c.a, c.b, c.c)# 相当于 C1.f(c1,&quot;123&quot;)c.f(&quot;123&quot;) 补充： 如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例； 在 Python 中没有任何东西能强制隐藏数据，它是完全基于约定的； Python 不支持方法重载 私有变量python 中没有 静态语言中的私有变量，但有一个约定：带有一个下划线的名称（__spam）应当作为API的似有部分 (无论它是函数、方法或是数据成员) 名称改写 任何形式为 __spam 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 _classname__spam，其中 classname 为去除了前缀下划线的当前类名称。名称改写有助于让子类重载方法而不破坏类内方法调用 继承单继承12345678910111213141516171819202122232425# 基类class BaseClassName: base_i = 123 def __init__(self): print(&quot;BaseClassName-&gt;__init__&quot;) def f1(self): print(&quot;BaseClassName-&gt;f1&quot;)# 派生类class DerivedClassName(BaseClassName): i = 321 def __init__(self): # 需要调用基类构造器 # 等同于 BaseClassName.__init__() super().__init__() print(&quot;DerivedClassName-&gt;__init__&quot;) # 重写基类方法 def f1(self): print(&quot;DerivedClassName-&gt;f1&quot;) 使用isinstance()和issubclass()内置函数，检查继承机制 12345d = DerivedClassName()# True（d实例的类是否派生自BaseClassName类）print(isinstance(d,BaseClassName)) # True（DerivedClassName是否是BaseClassName子类）print(issubclass(DerivedClassName,BaseClassName)) 如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。 多继承python 支持多继承，语法如下： 1class DerivedClassName(Base1, Base2, Base3): 可以认为搜索父类的属性是深度优先、从左至右的，如果某一属性在 DerivedClassName 中未找到，则会到 Base1 中搜索它，然后（递归地）到 Base1 的基类中搜索，如果在那里未找到，再到 Base2 中搜索，依此类推。 可能出现继承链指向一个类的情况，比如所有类都继承于object， 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化，保留每个类所指定的从左至右的顺序，只调用每个父类一次， 类内置方法迭代器使用for语句可以遍历容器对象，底层会在容器对象上调用__iter__方法，该方法返回一个定义了__next__()方法的迭代器对象，此方法逐一访问容器中的元素，元素用尽时，引发异常来种植for循环。自定义迭代器如下： 123456789101112131415161718class Reverse: &quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot; def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): return self def __next__(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index] rev = Reverse('spam')for char in rev: print(char)","link":"/2020/02/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Python/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Spring Boot Web 框架集成：SpringMVC","text":"Spring Boot 集成 mvc 框架流程 Servlet Web核心配置构建基于servlet的Web应用程序，可以利用spring boot对spring mvc或jersey的自动配置 Spring MVC 自动配置spring mvc 是一个丰富的“模型视图控制器”Web框架，它允许创建@controller或@restController的bean来处理传入的HTTP请求。控制器中的方法通过使用@requestMapping注释与http请求进行映射。 spring mvc自动配置提供以下功能 包括ContentNegotiatingViewResolver和BeanNameViewResolver豆。 支持提供静态资源，包括对 WebJars 的支持。 自动注册Converter，GenericConverter和Formatter豆类。 支持HttpMessageConverters。 的自动注册MessageCodesResolver。 静态index.html支持。 ConfigurableWebBindingInitializerbean 的自动使用。 Spring MVC 自动配置原理根据spring.factories文件可以找到spring mvc的自动配置类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//配置类@Configuration( proxyBeanMethods = false)//web环境@ConditionalOnWebApplication( type = Type.SERVLET)//当前类路径下存在Servlet, DispatcherServlet,WebMvcConfigurerAdapter@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})//beanFactory中不存在WebMvcConfigurationSupport类型的bean@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})//加载的优先级@AutoConfigureOrder(-2147483638)//在DispatcherServletAutoConfiguration, ValidationAutoConfiguration 加载后进行装配@AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})public class WebMvcAutoConfiguration { //... @Bean @ConditionalOnMissingBean({HiddenHttpMethodFilter.class}) @ConditionalOnProperty( prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = false ) public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter(){} @Bean @ConditionalOnMissingBean({FormContentFilter.class}) @ConditionalOnProperty( prefix = &quot;spring.mvc.formcontent.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = true ) public OrderedFormContentFilter formContentFilter(){} //配置类 @Configuration(proxyBeanMethods = false) //交由OnEnabledResourceChainCondition进行判断 //内部是通过OnEnabledResourceChainCondition类进行判断 //主要就是获取各种xxx.enabled的配置，然后进行判断 @ConditionalOnEnabledResourceChain static class ResourceChainCustomizerConfiguration{} //配置类 @Configuration(proxyBeanMethods = false) public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware{} //配置类 @Configuration( proxyBeanMethods = false) //加载该配置类时会先加载上面的EnableWebMvcConfiguration类 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) @EnableConfigurationProperties({WebMvcProperties.class, ResourceProperties.class}) @Order(0) public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer{} //...} 接下来对上面列出的部分进行分析： 生效条件该配置类中包含三个条件注解，前两个分别限制了当前项目的环境（Type.SERVLET）和存在必要的类（Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class）。最重要的是第三个条件注解，也就是@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})，它说明如果此时的ioc容器中含有WebMvcConfigurationSupport接口的实现类，那么当前的自动配置类就会失效，这就是@EnableWebMvc注解生效的原理。 内部配置类WebMvcAutoConfiguration有三个内部配置类，接下来对其分别进行分析： 1、ResourceChainCustomizerConfiguration 其内部只有一个@bean方法，它主要是用来处理静态资源的 1234567@BeanWebMvcAutoConfiguration.ResourceChainResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer() { @Bean WebMvcAutoConfiguration.ResourceChainResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer() {...}} 2、EnableWebMvcConfiguration 该类继承了DelegatingWebMvcConfiguration类（@EnableWebMvc注解导入的那个类），所以他的功能其实与@EnableWebMvc注解一样 1234567891011121314151617181920public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware { @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter(...){...} @Bean @Primary public RequestMappingHandlerMapping requestMappingHandlerMapping(...){...} @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(...){...} @Bean public FormattingConversionService mvcConversionService() {...} @Bean public Validator mvcValidator(){...} @Bean public ContentNegotiationManager mvcContentNegotiationManager(){...}} 3、WebMvcAutoConfigurationAdapter 该类实现了WebMvcConfigurer接口 12345678910111213141516171819202122232425262728293031323334public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer { @Bean @ConditionalOnMissingBean public InternalResourceViewResolver defaultViewResolver(){...} @Bean @ConditionalOnBean({View.class}) @ConditionalOnMissingBean public BeanNameViewResolver beanNameViewResolver(){...} @Bean @ConditionalOnBean({ViewResolver.class}) @ConditionalOnMissingBean( name = {&quot;viewResolver&quot;}, value = {ContentNegotiatingViewResolver.class} ) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory){...} @Bean @ConditionalOnMissingBean @ConditionalOnProperty( prefix = &quot;spring.mvc&quot;, name = {&quot;locale&quot;} ) public LocaleResolver localeResolver(){...} //... @Bean @ConditionalOnMissingBean({RequestContextListener.class, RequestContextFilter.class}) @ConditionalOnMissingFilterBean({RequestContextFilter.class}) public static RequestContextFilter requestContextFilter(){...}} Bean注入在上面的内部配置类处理结束后会处理WebMvcAutoConfiguration自动配置类自身的@Bean方法，主要有两个，如下： 123456789101112131415161718192021@Bean@ConditionalOnMissingBean({HiddenHttpMethodFilter.class})@ConditionalOnProperty( prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = false)public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() { return new OrderedHiddenHttpMethodFilter();}@Bean@ConditionalOnMissingBean({FormContentFilter.class})@ConditionalOnProperty( prefix = &quot;spring.mvc.formcontent.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = true)public OrderedFormContentFilter formContentFilter() { return new OrderedFormContentFilter();} 自定义配置自定义spring mvc配置方式如下： 在已提供的spring mvc配置基础上进行配置：编写@Configuration配置类并实现WebMvcConfigurer接口，但不要添加 @EnableWebMvc注解。如果想自己提供 RequestMappingHandlerMapping, RequestMappingHandlerAdapter或者ExceptionHandlerExceptionResolver实例的话，可以声明一个WebMvcRegistrations类型的bean，使用它提供那些组件的自定义实例； 完全自定义配置，有两种方式： 编写@Configuration配置类并实现WebMvcConfigurer接口，然后加入@EnableWebMvc注解； 编写@Configuration配置类并实现WebMvcConfigurationSupport接口以代替@EnableWebMvc导入的DelegatingWebMvcConfiguration实现类； 补充： WebMvcConfigurerAdapter抽象类实现了WebMvcConfigurer接口，继承它也可以自定义配置spring mvc但spring5已经将其标记过时，所以这里不再说明； @EnableWebMvc 注解上面提到的@EnableWebMvc注解作用是让spring mvc自动配置失效，@EnableWebMvc注解引入了一个DelegatingWebMvcConfiguration类 123@Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 进入DelegatingWebMvcConfiguration类中 123456789101112131415161718@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //添加自定义的配置 @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } //...} 分析上面的DelegatingWebMvcConfiguration类： 1、这个类的@Configuration注解的proxyBeanMethods属性为false，但这个类中并没有@bean注解，进入其父类WebMvcConfigurationSupport，这里面注册了19个@bean，注册了与&lt;mvc:annotation-driven/&gt;一样的组件 123public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { //...} WebMvcConfigurationSupport提供用 Java 配置 SpringMVC 所需要的所有方法。在纯SSM注解开发中也是使用这个类来对springmvc进行自定义配置的 2、configurers是一个WebMvcConfigurerComposite类型的对象，保存着spring mvc相关配置的信息，其中delegates属性就保存了自定义的配置信息 1234class WebMvcConfigurerComposite implements WebMvcConfigurer { private final List&lt;WebMvcConfigurer&gt; delegates = new ArrayList(); //...} 如果自定义了@Configuration配置类实现了WebMvcConfigurer接口，那么就会通过DelegatingWebMvcConfiguration类的setConfigurers方法把自定义的配置加入到configurers中 WebMvcConfigurer 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface WebMvcConfigurer { default void configurePathMatch(PathMatchConfigurer configurer) { } default void configureContentNegotiation(ContentNegotiationConfigurer configurer) { } default void configureAsyncSupport(AsyncSupportConfigurer configurer) { } default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { } default void addFormatters(FormatterRegistry registry) { } //自定义拦截器 @Resource private MyInterceptor myInterceptor; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor) //添加拦截器 .excludePathPatterns(&quot;/aaa/**&quot;); //添加忽略路径 } //静态资源处理器，使用配置文件方式也可以 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/aaa/**&quot;) //设置访问路径 .addResourceLocations(&quot;classpath:/aaa/&quot;); //设置资源路径 } default void addCorsMappings(CorsRegistry registry) { } default void addViewControllers(ViewControllerRegistry registry) { } default void configureViewResolvers(ViewResolverRegistry registry) { } default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) { } default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) { } default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { } default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { } default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { } default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { } @Nullable default Validator getValidator() { return null; } @Nullable default MessageCodesResolver getMessageCodesResolver() { return null; }} 自定义拦截器自定义Interceptor需要实现HandlerInterceptor接口或继承其实现类，然后重写其中方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class MyInterceptor implements HandlerInterceptor { /** * 预处理逻辑，可以在这里做校验，比如登陆校验 * @param request 请求 * @param response 响应 * @param handler 处理器，自定义的controller * @return 如果是true则继续下一个拦截器，否则流程中断返回response * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //在这里可以做校验，根据结果判断是否进行映射 System.out.println(&quot;preHandle&quot;); return true; } /** * 后置处理逻辑，渲染视图之前执行，对模型数据进行处理或对视图进行处理 * @param request 请求 * @param response 响应 * @param handler 处理器 * @param modelAndView 模型视图对象，可能为null * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;postHandle&quot;); } /** * 视图渲染完毕后触发，可用于监控程序执行时间和一些资源的清理工作 * @param request 请求 * @param response 响应 * @param handler 处理器 * @param ex 异常 * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;afterCompletion&quot;); }} Spring MVC 相关配置HttpMessageConvertersSpring MVC使用HttpMessageConverter接口来转换 HTTP 请求和响应。例如，对象可以自动转换为 JSON（使用 Jackson 库）或 XML（优先使用Jackson XML 否则使用 JAXB），字符串编码格式为UTF-8。 如果需要添加或者自定义转换器，可以使用HttpMessageConverters类 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class MyHttpMessageConvertersConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter&lt;?&gt; additional = new AdditionalHttpMessageConverter(); HttpMessageConverter&lt;?&gt; another = new AnotherHttpMessageConverter(); return new HttpMessageConverters(additional, another); }}//这样会覆盖默认的HttpMessageConverters//默认的如下@Bean@ConditionalOnMissingBeanpublic HttpMessageConverters messageConverters(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { return new HttpMessageConverters((Collection)converters.orderedStream().collect(Collectors.toList()));} 自定义json序列化和反序列化如果使用Jackson 来序列化和反序列化json数据，可能需要自定义JsonSerializer和JsonDeserializer类，然后注册给Jackson。spring boot提供了@JsonComponent注解，可以更轻松的进行注册，可以将@JsonComponent注解加到自定义的JsonSerializer和JsonDeserializer类上，也可以加到他们的外部类上 12345678910111213141516171819202122232425262728@JsonComponentpublic class MyJsonComponent { public static class Serializer extends JsonSerializer&lt;MyObject&gt; { @Override public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException { jgen.writeStringField(&quot;name&quot;, value.getName()); jgen.writeNumberField(&quot;age&quot;, value.getAge()); } } public static class Deserializer extends JsonDeserializer&lt;MyObject&gt; { @Override public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException, JsonProcessingException { ObjectCodec codec = jsonParser.getCodec(); JsonNode tree = codec.readTree(jsonParser); String name = tree.get(&quot;name&quot;).textValue(); int age = tree.get(&quot;age&quot;).intValue(); return new MyObject(name, age); } }} 因为@JsonComponent的元注释包括@Component所以可以被扫描，同时spring boot也提供了JsonObjectSerializer和JsonObjectDeserializer基础类，上面的例子也可以改成继承这两个。 静态资源默认情况下，spring boot提供了以下静态目录（在classpath或ServletContext上下文的根目录下）优先级一次递减： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 源码如下： 1234private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;}; 如果想要访问静态资源时放行需要如下配置： 12345678# 静态资源访问路径# 默认为 /**spring.mvc.static-path-pattern=/test/**# 静态资源位置# 默认为 /spring.resources.static-locations=classpath:/templates,classpath:/# 注意：上面的配置其实是访问路径到资源路径的映射，访问路径设置为/test/**代表如果访问路径匹配那么就会映射到下面设置的静态资源的一或多个路径上，可以多层路径访问，如:http://localhost:8080/test/staticsss.png 如果使用@EnableWebMvc注解会导致以上两个配置失效，这时就需要使用[配置类](#（2）WebMvcConfigurer 配置)的方式进行配置，上面配置等效于： 12345678@Configurationpublic class MyWebMvcConfigurer implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/test/**&quot;) //设置访问路径 .addResourceLocations(&quot;classpath:/templates&quot;,&quot;classpath:/&quot;); //设置资源路径 }} 静态资源版本管理当我们的资源内容发生改变时，由于浏览器缓存，用户本地的资源还是旧资源，可以通过添加随机数、时间戳等方式解决，但这样每次都要访问服务器，增大了服务器资源压力为了防止这种情况发生导致的问题spring boot 默认提供了静态资源版本映射的支持 content 策略（MD5）： 1234# 配置是否开启缓存破坏spring.resources.chain.strategy.content.enabled=true# 配置生效的目录spring.resources.chain.strategy.content.paths=/static/** 如果使用了Thymeleaf 和 FreeMarker模板引擎，可以直接在页面中添加 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;${@mvcResourceUrlProvider.getForLookupPath('/static/css/test.css')}&quot;&gt; 上面的配置在页面中会解析成如下内容 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/css/test-16372d2e887158a751e8ccb481723b20.css&quot;&gt; 可以看到在文件名下面添加了哈希值，并且刷新不会改变，只有文件被更改或重启服务时该哈希值才会变化。 如果使用的模板引擎无法直接访问Spring bean，则可以将ResourceUrlProvider 添加到Spring中 1234567891011@ControllerAdvicepublic class ControllerConfig { @Autowired ResourceUrlProvider resourceUrlProvider; @ModelAttribute(&quot;urls&quot;) public ResourceUrlProvider urls() { return this.resourceUrlProvider; }} fix策略（版本号） 配置内容如下： 123spring.resources.chain.strategy.fixed.enabled=truespring.resources.chain.strategy.fixed.paths=/static/css/**spring.resources.chain.strategy.fixed.version=version-1 例子与content一致，最终页面上解析的结果为： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/version-1/static/css/test.css&quot;&gt; 可以看到，文件名字没有改变，但在路径前面添加了version-1作为标识，静态文件每次进行更改后需要修改版本号。 两种策略可以一起使用 12345spring.web.resources.chain.strategy.content.enabled=truespring.web.resources.chain.strategy.content.paths=/**spring.web.resources.chain.strategy.fixed.enabled=truespring.web.resources.chain.strategy.fixed.paths=/js/lib/spring.web.resources.chain.strategy.fixed.version=v12 如果这样配置，位于 /js/lib/ 下的 js 模块会使用 fix 版本策略，其他路径使用content版本策略 欢迎页面Spring Boot 支持静态和模板化欢迎页面，页面查找顺序如下： 配置文件中的静态目录下的index.html index模板 程序的欢迎页面 自定义类型转换Spring MVC使用一个 WebBindingInitializer来初始化WebDataBinder，用来处理特定的请求。如果需要自定义，可以使用以下方式 自定义 ConfigurableWebBindingInitializer创建一个自定义的的bean，spring mvc会直接使用它 todo（示例代码待补充） 使用 @initBinder 注解todo（示例代码待补充） 模板引擎spring boot 默认支持以下模板引擎： FreeMarker Groovy Thymeleaf Mustache 应该尽可能的避免使用 jsp，如果使用了spring boot默认配置的模板引擎，那么模板位置默认在src/main/ resources/templates 路径下。 错误处理spring boot 默认提供了一个/error映射作为全局戳五处理页面，也可以通过server.error的配置项来自定义错误处理行为 名称 描述 默认值 server.error.path 错误页面 /error server.error.whitelabel.enabled 服务器出错时默认显示错误页面 true server.error.include-binding-errors never server.error.include-exception false server.error.include-message never server.error.include-stacktrace never 自定义错误页面如果想要为给定的状态码自定义错误页面，可以在将页面 /error 目录下。这个页面可以是静态的，也可以是模板 123456789101112131415# 如果是静态src/ +- main/ +- resources/ +- public/ +- error/ | +- 404.html# 如果是 FreeMarker 模板src/ +- main/ +- resources/ +- templates/ +- error/ | +- 5xx.ftlh 对于更复杂的映射可以定义实现ErrorViewResolver接口的bean 12345678910111213public class MyErrorViewResolver implements ErrorViewResolver { @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { // 根据请求或者状态返回ModelAndView if (status == HttpStatus.INSUFFICIENT_STORAGE) { // 可以添加自定义视图 new ModelAndView(&quot;myview&quot;); } return null; }} ErrorController如果要完全替换错误默认行为，可以定义一个ErrorController的实现类的bean，可以通过继承BasicErrorController类实现 1234567891011121314151617181920212223242526272829public class MyErrorController extends BasicErrorController { public MyErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties) { super(errorAttributes, errorProperties); } /** * 覆盖默认的Json响应 * ResponseEntity 是spring mvc定义的返回实体， * 里面包括状态码、、请求头、请求体等信息 */ @Override public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { //处理异常 //指定返回的数据 return ; } /** * 覆盖默认的HTML响应 * 返回的是ModelAndView */ @Override public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { //处理异常 //指定自定义的视图 return ; }} @ControllerAdvice + @ExceptionHandler@ControllerAdvice + @ExceptionHandler是spring mvc常规异常处理方式，使用@ControllerAdvice注解自定义针对json数据的异常处理 12345678910111213141516171819202122//这里可以不继承ResponseEntityExceptionHandler@ControllerAdvicepublic class MyControllerAdvice extends ResponseEntityExceptionHandler { @ExceptionHandler({Exception.class}) public CommonReponse fix(Exception ex){ //处理异常 return new CommonReponse(); } //需要时可以重写该类的方法 @Override protected ResponseEntity&lt;Object&gt; handleHttpRequestMethodNotSupported( HttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { //处理异常，设置属性 return super.handleHttpRequestMethodNotSupported(ex, headers, status, request); }} ResponseEntityExceptionHandler类中包装了各种SpringMVC在处理请求时可能抛出的异常的处理，处理结果都是封装成一个ResponseEntity对象，进入该方法 12345678910111213141516171819202122232425public abstract class ResponseEntityExceptionHandler { /** 以下声明异常是springmvc处理请求的所有可能抛出的异常，如果出现异常就会进入该方法 * 这个方法内部就是一堆if语句，根据异常的的类型转发到其他的异常处理方法 */ @ExceptionHandler({HttpRequestMethodNotSupportedException.class, HttpMediaTypeNotSupportedException.class, HttpMediaTypeNotAcceptableException.class, MissingPathVariableException.class, MissingServletRequestParameterException.class, ServletRequestBindingException.class, ConversionNotSupportedException.class, TypeMismatchException.class, HttpMessageNotReadableException.class, HttpMessageNotWritableException.class, MethodArgumentNotValidException.class, MissingServletRequestPartException.class, BindException.class, NoHandlerFoundException.class, AsyncRequestTimeoutException.class}) @Nullable public final ResponseEntity&lt;Object&gt; handleException(){} //其他异常处理方法} 另外，也可以将@ExceptionHandler注解加到可能出现异常的控制器上，这样就不会进入全局异常处理 123456789101112131415161718@Controller@RequestMapping(&quot;/test&quot;)public class TestController { //可能抛出异常的方法 @RequestMapping(&quot;/test&quot;) @ResponseBody public String testError(){ int i = 1 / 0; return &quot;&quot;; } @ExceptionHandler({RuntimeException.class}) public ModelAndView handleException(Exception ex){ //处理异常 return new ModelAndView(&quot;error&quot;,new ModelMap(&quot;ex&quot;,ex.getMessage())); }} Spring MVC 之外的错误页面对于不使用 Spring MVC 的应用，可以使用ErrorPageRegistrar接口直接注册ErrorPages. 这种抽象直接与底层嵌入式 servlet 容器一起工作，即使您没有 Spring MVC 也能工作DispatcherServlet。 12345678910111213@Configuration(proxyBeanMethods = false)public class MyErrorPagesConfiguration { @Bean public ErrorPageRegistrar errorPageRegistrar() { return this::registerErrorPages; } private void registerErrorPages(ErrorPageRegistry registry) { registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, &quot;/400&quot;)); }} CORS 支持从 version 4.2 开始，Spring MVC开始支持 CORS 。在 Spring Boot 应用程序中可以通过自定义bean实现跨域 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class MyCorsConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override public void addCorsMappings(CorsRegistry registry) { //放行的路径 registry.addMapping(&quot;/api/**&quot;); } }; }} 也可以直接在 controller 上直接添加 @CrossOrigin 注解。","link":"/2022/01/05/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBootWeb%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%EF%BC%9ASpringMVC/"},{"title":"Spring Boot 数据库集成：Redis 数据库","text":"Redis 通常用于数据量比较小、性能较高的场景，一般用作缓存。spring boot提供了spring-boot-starter-data-redis启动器，为Lettuce和Jedis客户端以及Spring Data Redis提供的抽象做了基本的自动配置吗默认情况下使用Lettuce。可以用于传统的和响应式的应用程序。 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 相关配置在配置文件中添加redis相关配置 123456789101112131415161718# Redis数据库索引（默认0）spring.redis.database=0# redis服务器地址（默认localhost）spring.redis.host=127.0.0.1#Redis服务器连接端口（默认6379）spring.redis.port=6379 #Redis服务器连接密码（默认为空）spring.redis.password=#连接池最大连接数（使用负值表示没有限制，默认8）spring.redis.[客户端].pool.max-active=8#连接池最大阻塞等待时间（使用负值表示没有限制，默认-1ms）spring.redis.[客户端].pool.max-wait=-1#连接池中的最大空闲连接（默认8）spring.redis.[客户端].pool.max-idle=8#连接池中的最小空闲连接（默认0）spring.redis.[客户端].pool.min-idle=0#连接超时时间（毫秒）spring.redis.timeout=30000 自动配置我们来看redis自动配置类 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass({RedisOperations.class})@EnableConfigurationProperties({RedisProperties.class})@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&quot;redisTemplate&quot;} ) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; }} 可以看到该类中创建了RedisTemplate和StringRedisTemplate实例，同时通过@import注解引入了两个类（LettuceConnectionConfiguration和JedisConnectionConfiguration），下面只列出这两个类中的@bean方法 12345678910111213141516171819202122232425262728//LettuceConnectionConfigurationclass LettuceConnectionConfiguration extends RedisConnectionConfiguration { @Bean( destroyMethod = &quot;shutdown&quot; ) @ConditionalOnMissingBean({ClientResources.class}) DefaultClientResources lettuceClientResources() { return DefaultClientResources.create(); } @Bean @ConditionalOnMissingBean({RedisConnectionFactory.class}) LettuceConnectionFactory redisConnectionFactory(...); //... return this.createLettuceConnectionFactory(clientConfig); } //...}//JedisConnectionConfigurationclass JedisConnectionConfiguration extends RedisConnectionConfiguration { @Bean @ConditionalOnMissingBean({RedisConnectionFactory.class}) JedisConnectionFactory redisConnectionFactory(...) throws UnknownHostException { return this.createJedisConnectionFactory(builderCustomizers); }} LettuceConnectionConfiguration和JedisConnectionConfiguration中都存在创建他们所对应的 RedisConnectionFactory 实例的方法，并且根据其上声明的条件注解可知最终 ioc 容器中只存在一个。除此之外，LettuceConnectionConfiguration还多创建了一个名为DefaultClientResources的实例。 使用方法根据上述介绍可以得出：在自动配置过程中创建的bean实例主要有以下三个： RedisTemplate StringRedisTemplate RedisConnectionFactory 可以在项目中直接引入 123456@Autowiredprivate RedisTemplate redisTemplate;@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Autowiredprivate RedisConnectionFactory redisConnectionFactory; todo","link":"/2021/12/16/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90%EF%BC%9ARedis/"},{"title":"Spring Boot 数据库集成：SQL 数据库","text":"Spring 框架提供了利用JdbcTemplate 直接访问JDBC从而操作数据库的技术。另外可以利用Hibernate或Spring Data提供的Repository生成查询 嵌入式数据库Spring Boot 提供了嵌入式的H2、HSQL和Dery数据库。无需提供连接URL，只需要包含对应的嵌入式数据库的依赖项。例如： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 如果类路径上有多个嵌入式数据库，可以配置spring.datasource.embedded-database-connection属性设置使用哪一个。将其设置为none禁用嵌入式数据库的自动配置。 1spring.datasource.embedded-database-connection=none 在测试环境下，多个应用程序商家问会重用一个数据库，如果要确保每个上下文都有单独的嵌入式数据库，需要配置 1spring.datasource.generate-unique-name=true 如果为嵌入式数据库配置了URL，应确保禁用数据库的自动关闭，这样可以让spring boot控制何时关闭数据库，从而确保只使用一次数据库之后就不再须要的情况。 配置数据源Java 的javax.sql.DataSource提供了处理数据库连接的标准方法。数据库会通过URL和一些认证信息来建立数据库连接。通过spring.datasource.*进行配置 123spring.datasource.url=jdbc:mysql://localhost/testspring.datasource.username=dbuserspring.datasource.password=dbpass 其中至少应该指定URL，否则spring boot会尝试自动配置嵌入式数据库。Spring Boot 可以通过 URL 中推断出大多数的数据库JDBC驱动类，如果想要指定特定的类，可以使用 1spring.datasource.driver-class-name=xxx 为了创建DataSource，我们需要验证配置的Driver是可用的，所以在做任何事之前都会检查它，换句话说，上面配置的驱动类必须是课加载的。 对于其他的连接池可以通过它们对应的前缀配置 spring.datasource.hikari.*； spring.datasource.tomcat.*； spring.datasource.dbcp2.*； spring.datasource.oracleucp.* 例如： 123spring.datasource.tomcat.max-wait=10000spring.datasource.tomcat.max-active=50spring.datasource.tomcat.test-on-borrow=true 自定义数据源如果需要配置自己的数据源，直接定义对应类型的的@bean即可 123456789@Configuration(proxyBeanMethods = false)public class MyDataSourceConfiguration { @Bean //使用ConfigurationProperties自动绑定配置信息 @ConfigurationProperties(prefix = &quot;app.datasource&quot;) public SomeDataSource dataSource() { return new SomeDataSource(); }} 配置自定义数据源属性，这些属性会在SomeDataSource被装配到其他组件前注入 1234app.datasource.jdbc-url=jdbc:mysql://localhost/testapp.datasource.username=dbuserapp.datasource.password=dbpassapp.datasource.pool-size=30 spring boot也提供了一个公共的builder类（DataSourceBuilder），用于创建指定类型的标准数据源，这个builder能够根据classpath上的内容检测哪个是可用的，也会自动检测JDEB URL 1234567891011121314@Configuration(proxyBeanMethods = false)public class MyDataSourceConfiguration { @Bean @ConfigurationProperties(&quot;app.datasource&quot;) //这时可以指定具体类型的数据源 public HikariDataSource dataSource() { return DataSourceBuilder .create() .type(HikariDataSource.class) .build(); } } 可以提供自定义的DataSourceProperties，对自定义属性做进一步处理 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class MyDataSourceConfiguration { @Bean @Primary @ConfigurationProperties(&quot;app.datasource&quot;) public DataSourceProperties dataSourceProperties() { return new DataSourceProperties(); } @Bean @ConfigurationProperties(&quot;app.datasource.configuration&quot;) public HikariDataSource dataSource(DataSourceProperties properties) { return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); }} 对应配置如下 1234app.datasource.url=jdbc:mysql://localhost/testapp.datasource.username=dbuserapp.datasource.password=dbpassapp.datasource.configuration.maximum-pool-size=30 配置多数据源配置多数据源可以参照配置单数据源的方式，只不过需要指定一个DataSource作为@Primary，在之后的自动配置过程中获取到的都是这个DataSource，如果有其对应的 @ConfigurationProperties 也与要加@Primary 1234567891011121314151617181920212223242526@Configuration(proxyBeanMethods = false)public class MyCompleteDataSourcesConfiguration { //配置方式1 @Bean @Primary @ConfigurationProperties(&quot;app.datasource.first&quot;) public DataSourceProperties firstDataSourceProperties() { return new DataSourceProperties(); } @Bean @Primary @ConfigurationProperties(&quot;app.datasource.first.configuration&quot;) public HikariDataSource firstDataSource(DataSourceProperties firstDataSourceProperties) { return firstDataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); } //配置方式2 @Bean @ConfigurationProperties(&quot;app.datasource.second&quot;) public BasicDataSource secondDataSource() { return DataSourceBuilder.create().type(BasicDataSource.class).build(); }} 两个数据源对应自定义配置如下： 123456789app.datasource.first.url=jdbc:mysql://localhost/firstapp.datasource.first.username=dbuserapp.datasource.first.password=dbpassapp.datasource.first.configuration.maximum-pool-size=30app.datasource.second.url=jdbc:mysql://localhost/secondapp.datasource.second.username=dbuserapp.datasource.second.password=dbpassapp.datasource.second.max-total=30 连接池spring boot选择连接池的规则： 如果HikariCP 可用，则选择； 否则，如果 Tomcat 池DataSource可用，则使用； 否则，如果Commons DBCP2可用，则使用； 如果上面都不可用，并且Oracle UCP可用，则使用； 如果加入了spring-boot-starter-jdbc或spring-boot-starter-data-jpa的依赖会自动选择HikariCP。如果不希望使用上述规则可以如下设置： 1spring.datasource.type=要使用的连接池 使用DataSourceBuilder可以通过手动配置额外的连接池.如果自定义 DataSource ，那么自动配置不会剩下。DataSourceBuilder支持以下连接池 HikariCP Tomcat pooling Datasource Commons DBCP2 Oracle UCP &amp; OracleDataSource Spring Framework’s SimpleDriverDataSource H2 JdbcDataSource PostgreSQL PGSimpleDataSource 其他的连接池，比如C3P0可以直接引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.3&lt;/version&gt;&lt;/dependency&gt; 然后再自定义DataSource 1234567891011121314151617@Configuration@ConditionalOnClass(DataSource.class)public class C3p0AutoConfiguration { @Bean @ConditionalOnMissingBean public DataSource dataSource() throws Exception{ // 创建一个 c3p0 的连接池 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; }} JdbcTemplateJdbcTemplate和NamedParameterJdbcTemplate类都是自动配置的，可以直接在项目中注入，可以使用spring.jdbc.template.*属性自定义其参数 12spring.jdbc.template.max-rows=500更多属性 todo 如果JdbcTemplate定义了多个，并且没有指定@primary 那么NamedParameterJdbcTemplate不会自动配置 todo 使用方法","link":"/2021/12/05/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90%EF%BC%9ASQL/"},{"title":"Spring Boot 核心功能：启动执行代码","text":"添加 Spring Boot 程序启动后执行的逻辑 程序启动后执行特定代码如果需要在程序启动后执行特定代码，可以实现 ApplicationRunner 或 CommandLineRunner接口，这两个接口提供了run()方法会在SpringApplication.run(…)调用完成之前执行 1234567@Componentpublic class MyCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;我执行啦&quot;); }}","link":"/2021/06/13/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81/"},{"title":"Spring Boot 核心功能：自定义banner","text":"自定义 banner 配置文件设置可以通过将banner.txt文件添加到类路径或将spring.banner.location属性设置为此类文件的位置来更改启动时打印的banner。如果文件的编码不是 UTF-8，需要设置spring.banner.charset。 除了一个文本文件，还可以添加一个banner.gif，banner.jpg或banner.png图像文件到类路径或设置spring.banner.image.location属性。图像被转换为 ASCII 艺术表现形式并打印在任何文本横幅上方。 在您的banner.txt文件中，您可以使用以下任何占位符： 变量 描述 ${application.version} 应用程序的版本号 ${application.formatted-version} 应用程序的版本号，格式化输出 ${spring-boot.version} Spring Boot 版本 ${spring-boot.formatted-version} Spring Boot 版本，格式化输出 ${Ansi.NAME}(或${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME}) NAMEANSI 转义码 ${application.title} 应用程序的标题 代码设置使用SpringApplication.setBanner(…)方法可以设置banner 也可以自定义类继承org.springframework.boot.Banner接口并实现您自己的printBanner()方法。","link":"/2021/06/10/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89banner/"},{"title":"Spring Boot 核心功能：懒加载","text":"设置 bean 的懒加载 懒加载spring boot允许懒加载。启用懒加载后，bean 将在需要时创建，而不是在应用程序启动期间创建，但这可能会产生很多问题。开启的配置如下: properties： 1spring.main.lazy-initialization=true yaml： 123spring: main: lazy-initialization: true","link":"/2021/06/11/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"title":"Spring Boot 核心功能：获取应用程序参数","text":"获取应用启动时传递的参数 获取应用程序参数使用可以通过注入一个org.springframework.boot.ApplicationArguments类型的bean获取应用程序传递的参数 123456789101112@Componentpublic class MyBean { public MyBean(ApplicationArguments args) { boolean debug = args.containsOption(&quot;debug&quot;); List&lt;String&gt; files = args.getNonOptionArgs(); if (debug) { System.out.println(files); } }}","link":"/2021/06/12/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0/"},{"title":"Spring Boot 源码解析（一）依赖管理","text":"Spring Boot 中通过官方或第三方提供的启动类来集成各种组件的依赖管理方式 父工程pom文件解析首先建立一个springboot工程，只添加web依赖 工程创建成功后进入pom.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zcy&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-mytest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-mytest&lt;/name&gt; &lt;description&gt;spring-boot-mytest&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 其中父项目部分为： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 不断进入父项目，得到的层级结构为： spring-boot-starter-parent文件spring-boot-starter-parent文件中定义的内容包括少量的properties属性、项目资源路径、插件以及插件版本的管理 properties属性： 123456789&lt;properties&gt; &lt;main.basedir&gt;${basedir}/../../..&lt;/main.basedir&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;&lt;/properties&gt; 资源路径： 12345678910111213141516171819&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/application*.yml&lt;/include&gt; &lt;include&gt;**/application*.yaml&lt;/include&gt; &lt;include&gt;**/application*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/application*.yml&lt;/exclude&gt; &lt;exclude&gt;**/application*.yaml&lt;/exclude&gt; &lt;exclude&gt;**/application*.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 插件以及插件版本的管理： 12345678&lt;pluginManagement&gt; &lt;plugins&gt; ... &lt;/plugins&gt;&lt;/pluginManagement&gt;&lt;plugins&gt; ...&lt;/plugins&gt; spring-boot-dependencies文件spring-boot-dependencies中主要定义了大量的properties属性，包括了当前选择的springboot版本所依赖的各种jar包的版本号 123456789101112131415161718192021222324252627282930&lt;properties&gt; &lt;main.basedir&gt;${basedir}/../..&lt;/main.basedir&gt; &lt;!-- Dependency versions --&gt; &lt;activemq.version&gt;5.15.13&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.81&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.10.1&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.13.2&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;awaitility.version&gt;4.0.3&lt;/awaitility.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;byte-buddy.version&gt;1.10.13&lt;/byte-buddy.version&gt; &lt;caffeine.version&gt;2.8.5&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;3.7.2&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.5.1&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.13&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.7.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.9&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-pool2.version&gt;2.7.0&lt;/commons-pool2.version&gt; &lt;couchbase-client.version&gt;2.7.16&lt;/couchbase-client.version&gt; &lt;couchbase-cache-client.version&gt;2.1.0&lt;/couchbase-cache-client.version&gt; &lt;db2-jdbc.version&gt;11.5.4.0&lt;/db2-jdbc.version&gt; &lt;derby.version&gt;10.14.2.0&lt;/derby.version&gt; &lt;dropwizard-metrics.version&gt;4.1.11&lt;/dropwizard-metrics.version&gt; &lt;ehcache.version&gt;2.10.6&lt;/ehcache.version&gt; &lt;ehcache3.version&gt;3.8.1&lt;/ehcache3.version&gt; ......&lt;/properties&gt; 除此之外还定义了插件以及插件版本 spring-boot-build文件spring-boot-build文件，主要声明了依赖（repositories）和插件（pluginRepositories）的远程仓库列表以及不同环境下的配置（profiles），另外还有插件管理的版本，内容大致如下： 总结通过上面三个父工程中的内容可以发现，各个父工程分别定义了插件、依赖版本、环境配置等信息进行了统一的声明和管理，但并未导入任何jar包，那工程中引入的那些jar包是从哪里引入的呢？ 启动器spring boot工程的jar包主要通过dependencies标签中的dependency标签声明需要的依赖和启动器，如下所示： 123456789101112&lt;!--启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--依赖注入 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.66&lt;/version&gt;&lt;/dependency&gt; 我们都知道SpringBoot可以快速的开发基于Spring框架的项目。由于围绕SpringBoot存在很多开箱即用的Starter依赖，遇到某个应用场景只需要引入对应的启动器然后进行相应的配置即可。 启动类的格式包括两种，分别由不同的命名格式： 官方提供的依赖启动器（spring-boot-starter-xxx） 技术框架的开发团队主动与spring boot进行整合提供的启动器（xxx-spring-boot-starter） 官方启动器内容进入spring-boot-starter-web启动器，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;${revision}&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;name&gt;Spring Boot Web Starter&lt;/name&gt; &lt;description&gt;Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container&lt;/description&gt; &lt;properties&gt; &lt;main.basedir&gt;${basedir}/../../..&lt;/main.basedir&gt; &lt;/properties&gt; &lt;scm&gt; &lt;url&gt;${git.url}&lt;/url&gt; &lt;connection&gt;${git.connection}&lt;/connection&gt; &lt;developerConnection&gt;${git.developerConnection}&lt;/developerConnection&gt; &lt;/scm&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以发现，spring-boot-starter-web启动器中包含了json、tomcat等启动器，另外也引入了spring-webmvc等相关依赖，spring boot内置了tomcat服务器，以tomcat为例，再进入spring-boot-starter-tomcat中，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--2.3.0版本以上没有parent部分--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;${revision}&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;name&gt;Spring Boot Tomcat Starter&lt;/name&gt; &lt;description&gt;Starter for using Tomcat as the embedded servlet container. Default servlet container starter used by spring-boot-starter-web&lt;/description&gt; &lt;properties&gt; &lt;main.basedir&gt;${basedir}/../../..&lt;/main.basedir&gt; &lt;/properties&gt; &lt;scm&gt; &lt;url&gt;${git.url}&lt;/url&gt; &lt;connection&gt;${git.connection}&lt;/connection&gt; &lt;developerConnection&gt;${git.developerConnection}&lt;/developerConnection&gt; &lt;/scm&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看到spring-boot-starter-tomcat启动器中引入了tomcat相关依赖，所以说spring boot内置了tomcat 替换tomcatSpring Boot默认支持Tomcat，Jetty，和Undertow作为底层容器。，并且默认使用tomcat作为服务器容器。如果需要切换servlet容器需要先排除tomcat启动器，然后再引入其他容器 pom.xml文件引入修改依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!--移除spring-boot-starter-web中的tomcat--&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!--引入jetty--&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 启动器父工程结构 此部分只针对于2.3.0以下的版本，2.3.0以上版本的启动类已经将parent标签去除，另外非官方提供的启动类一般也是没有parent的。 通过上面两个启动器可以发现他们的父工程都为spring-boot-starters，逐层进入父工程得到层次结构如下： 后三个父工程上面已经提到过，我们主要来看spring-boot-starters中的内容 可以发现该spring-boot-starters的pom文件中包含了大量的子模块，这些子模块就是spring boot官方提供的启动器，一共44个。另外文件中还有一些插件配置。 第三方启动类第三方启动类包括非官方提供的启动类以及自定义启动类，下面介绍自定义starter的过程 pom.xml文件中需要加入依赖自定义的start命名应遵循xxx-spring-boot-starter的命名规则，并且在启动器中应加入自动配置核心依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;spring boot版本&lt;/version&gt;&lt;/dependency&gt; 编写映射配置信息类@ConfigurationProperties注解可以将配置文件中的信息封装到当前类中，但需要使用@EnableConfigurationProperties注解或者@ConfigurationPropertiesScan注解进行注册，否则无法生效 123456789@ConfigurationProperties(prefix = &quot;ufo&quot;)public class MyProperties { private int id; private String name; //getter()/setter()} 编写enable注解只有在@enableUFO注解会引入ufoMarker类 12345678910//标记类public class ufoMarker {}@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import({ufoMarker.class})public @interface enableUFO {} 编写配置类这里通过构造函数注入MyProperties类 12345678910111213141516171819202122232425262728@Configuration//ioc容器中存在ufoMarker的bean时才加载该配置类@ConditionalOnBean(ufoMarker.class)@EnableConfigurationProperties({MyProperties.class})public class MyAutoConfiguration { private MyProperties myProperties; //通过构造方法引入myProperties //也可以通过@autowire注解引入 public MyAutoConfiguration(MyProperties myProperties) { this.myProperties = myProperties; } @Bean public UFO getUFO(){ return new UFO(); }}//实体类，用于测试public class UFO { public void hello(){ System.out.println(&quot;hello I am UFO&quot;); }} 编写spring.factories文件上面的过程结束后spring boot并不会进行扫描，需要在META-INFO目录下编写spring.factories文件，spring boot启动过程中会通过读取该文件，然后根据文件中的配置对类进行解析 123# 自动配置org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.zcy.myAotoconfigration.MyAutoConfiguration 测试在测试项目的pom.xml文件中引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.zcy&lt;/groupId&gt; &lt;artifactId&gt;ufo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-RELEASE&lt;/version&gt;&lt;/dependency&gt; 测试代码： 1234567891011121314151617181920@RestControllerpublic class TestController { @Autowired private UFO ufo; @RequestMapping(method = RequestMethod.GET,path = &quot;/ufo&quot;) public void hello(){ ufo.hello(); }}//启动类@SpringBootApplication//自定义starter生效@EnableUFOpublic class SpringBootMytestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMytestApplication.class, args); }} 配置文件： 12ufo.id=1ufo.name=ufo 测试结果：","link":"/2020/08/26/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Spring Boot 核心功能：配置相关","text":"本篇介绍 Spring Boot 中对配置的相关问题，包括配置导入、配置分隔等 自动配置spring boot会根据引入的自动配置器来引入配置，只需要在启动类上标记@EnableAutoConfiguration 或者 @SpringBootApplication注解，原理参照源码解析 自动配置替换spring boot的自动配置是可以替换。启动spring boot时会将相关的bean封装为beanDefination保存到benfactory（ioc容器）中，自定义的配置会率先加载到ioc容器中，之后在加载自动配置类的时，一般都会在创建bean的方法上标记@ConditionalOnMissingBean注解，意为当前bean不存在时才加载，这就是自定义配置替换原有配置的原理 禁用自动配置可以使用@EnableAutoConfiguration注解的的 exclude 属性和excludeName属性禁用不想要的特定自动配置类。由于@SpringBootApplication和@SpringCloudApplication都是组合了@EnableAutoConfiguration注解，所以也可以直接将排除配置卸载@SpringBootApplication和@SpringCloudApplication注解上 exclude 属性需要指定排除项类的数组 1234@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })public class MyApplication {} excludeName 属性需要指定排除项的全类名 1234@SpringBootApplication(excludeName = {&quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;})public class MyApplication {} 配置文件中排除properties： 123spring.autoconfigure.exclude=\\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration yaml： 12345spring: autoconfigure: exclude: - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration - org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration 外部配置spring boot可以使用各种外部配置源： Java文件 properties文件 YAML文件 环境变量 命令行参数 配置源读取顺序（后面的会覆盖更早的,null值不会覆盖）： 默认属性（由设置指定SpringApplication.setDefaultProperties）； @Configuration注释的类； 配置数据（如application.properties文件）； RandomValuePropertySource，只有在拥有性能random.*； 操作系统环境变量； Java 系统属性 ( System.getProperties())； 来自java:comp/env的NDI 属性； ServletContext 初始化参数； ServletConfig 初始化参数 来自SPRING_APPLICATION_JSON（嵌入在环境变量或系统属性中的内联 JSON）的属性。 命令行参数； 测试中的@SpringBootTest； 测试中的@TestPropertySource； 当 devtools 处于活动状态时的 $HOME/.config/spring-boot ； 配置文件优先级： 打包在 jar 中的应用程序属性（application.properties和 YAML 变体）； 打包在 jar 中的特定于配置文件的应用程序属性（application-{profile}.properties和 YAML 变体）； 打包的 jar 之外的应用程序属性（application.properties和 YAML 变体）； 打包的 jar之外的特定于配置文件的应用程序属性（application-{profile}.properties和 YAML 变体）； 加载application.properties和application.yaml的默认位置： classpath classpath目录 classpath目录下的 /config 子目录 project（如果有多个子模块，这里指的是父他们父工程的根目录） project根目录 project根目录的 /config 子目录 /config 子目录的直接子目录 补充： 该列表按优先级排序，后加载的覆盖先加载的。 同一位置同时具有.properties和.yml格式，.properties则优先； 命令行属性命令行属性始终优先于基于文件的属性源； 禁用命令行参数使命令行属性不会添加到Environment中 1SpringApplication.setAddCommandLineProperties(false) json应用程序属性环境变量和系统属性通常有限制，不能随意使用。为解决这个问题，spring boot允许使用以单个json的结构定义一组属性； 在程序启动时，任何spring.application.json或SPRING_APPLICATION_JSON属性将被解析并添加到Environment，例如： 1234# 命令行参数中配置$ SPRING_APPLICATION_JSON='{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}' java -jar myapp.jar$ java -Dspring.application.json='{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}' -jar myapp.jar$ java -jar myapp.jar --spring.application.json='{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}' 自定义配置文件spring.config.name, spring.config.location, 和spring.config.additional-location等用来指定配置文件，它们必须定义为环境属性（通常是操作系统环境变量、系统属性或命令行参数） spring.config.name配置spring.config.name环境属性定替换默认文件名 1$ java -jar myproject.jar --spring.config.name=myproject spring.config.location配置spring.config.location环境属性替换默认位置 12345678# 多个位置用逗号分隔# 如果希望位置时可选的，可以使用optional前缀$ java -jar myproject.jar --spring.config.location=\\ optional:classpath:/custom-config/,\\ optional:file:./custom-config/# 上面的配置扫描路径如下optional:classpath:custom-config/optional:file:./custom-config/ 补充： 如果spring.config.location指定的是目录（而不是文件），则会以spring.config.name的指定的值作为文件名。如果指定的是文件名则直接导入； 配置多个位置会按照定义的顺序进行处理，后面的位置可以覆盖前面位置的值。 spring.config.additional-location配置spring.config.additional-location环境属性，添加默认位置 12345678910$ spring.config.additional-location=\\ optional:classpath:/custom-config/, optional:file:./custom-config/# 上面的配置扫描路径如下# 默认的配置文件位置optional:classpath:/;optional:classpath:/config/optional:file:./;optional:file:./config/;optional:file:./config/*/# 添加的配置文件位置optional:classpath:custom-config/optional:file:./custom-config/ 可以在默认位置设置默认值，然后在自定义位置设置新的值来覆盖默认值； 补充： 对于指定的配置文件也同样起效，例如spring.config.location设置为classpath:myconfig.properties，也能找到相应的classpath:myconfig-&lt;profile&gt;.properties文件被加载； spring.config.location您添加的每个项目都将引用单个文件或目录。位置按照定义的顺序进行处理，后面的位置可以覆盖前面位置的值。 可选位置： 默认情况下，指定的配置如果不存在会报错。如果不希望报错，可以通过optional:前缀指定可选配置，如果想要来忽略所有的ConfigDataLocationNotFoundExceptions，如果想忽略所有的ConfigDataLocationNotFoundExceptions并始终继续启动您的应用程序，可以设置spring.config.on-not-found属性； 通配符位置： 如果文件位置的配置路径最后一个路径段的包含*，则将其视为通配符（匹配一个或多个字符）。例如，我们将redis和mysql配置分开存放，又想让他们都被读取，可以设置位置分别为*/config/redis/application.properties和/config/mysql/application.properties*。 补充： 通配符位置仅适用于外部目录。不能在classpath:位置中使用通配符。 通配符位置必须仅包含一个*并以*/目录结尾或*/&lt;filename&gt;文件搜索位置结尾。带有通配符的位置根据文件名的绝对路径按字母顺序排序。 spring.profiles.active默认spring boot会加载application配置文件，通过配置spring.profiles.active属性来指定特定配置文件： 1spring.profiles.active=prod,live 补充： application.properties文件仍会被加载，可以作为默认配置； 被指定的特定文件中的值会覆盖非特定文件； 如果配置了多个特定文件那么后面的会覆盖前面的，例如配置prod,live，那么application-prod.properties中的值会被application-live.properties中的值覆盖； Environment具有一组默认的配置文件（默认[default]），如果没有指定spring.profiles.active属性，则加载application-default的文件； 配置分组（;分隔符）： 使用分隔符（;）会对自定义的配置文件进行分组，例如： 123456789101112131415161718192021222324252627# 当前文件目录/cfg application-live.properties /ext application-live.properties application-prod.properties # 配置spring.profiles.active=prod,live# 以,逗号分隔spring.config.location=classpath:/cfg/,classpath:/ext/# 会加载的文件顺序# 可以看到此时不会按照spring.profiles.active中的配置顺序加载/cfg/application-live.properties/ext/application-prod.properties/ext/application-live.properties# 用;分隔符替换,逗号spring.config.location=classpath:/cfg/;classpath:/ext/# 会加载的文件顺序# 此时ext和cfg目录被分为不同组，处理时在同意水平# 满足spring.profiles.active中的配置顺序加载/ext/application-prod.properties/cfg/application-live.properties/ext/application-live.properties spring.config.import使用spring.config.import属性可以从其他位置导入更多配置数据，会在读取到该配置时引入，视为附加文件 1spring.config.import=optional:file:./dev.properties 这条配置会将触发dev.properties文件导入，导入文件的值优先级更高，配置定义的顺序无关紧要 12345spring.config.import=my.propertiesmy.property=value# 等同于my.property=valuespring.config.import=my.properties 上面两个示例中my.properties文件中的值优先于触发其导入的文件 补充： 一个导入无论声明多少次都只会被导入一次； spring.config.import键下指定多个位置，导入顺序和定义顺序一致，后面导入文件的值优先； 导入无扩展名文件： 某些云平台无法为卷挂载文件添加文件扩展名，如果需要这些无扩展名的文件，需要将扩展提示放在方括号中 1spring.config.import=file:/etc/config/myconfig[.yaml] 导入配置树： 使用optional:前缀导入配置树 配置树： 12345etc/ config/ myapp/ username password 导入： 1spring.config.import=optional:configtree:/etc/config/ 导入之后可以以通常的方式访问或注入myapp.username和myapp.password属性。入股有多个配置树要从同一个父文件夹导入 12345678910etc/ config/ dbconfig/ db/ username password mqconfig/ mq/ username password 可以将configtree:/etc/config/*/用作导入位置 1spring.config.import=optional:configtree:/etc/config/*/ 属性占位符application.properties和application.yml中的值在Environment使用时会通过现有值进行过滤，因此可以参考以前定义的值。使用${name}属性占位符语法可用于值内的任何地方。 12app.name=MyAppapp.description=${app.name} is a Spring Boot application 配置随机值： RandomValuePropertySource可以用来注入随机值，它可以生成整数、长整数、uuid 或字符串，如以下示例所示： 123456my.secret=${random.value}my.number=${random.int}my.bignumber=${random.long}my.uuid=${random.uuid}my.number-less-than-ten=${random.int(10)}my.number-in-range=${random.int[1024,65536]} 多文档文件Spring Boot 允许您将单个物理文件拆分为多个独立添加的逻辑文档。文档按顺序处理，从上到下。后面的文档可以覆盖在前面的文档中定义的属性。 12345678910spring: application: name: &quot;MyApp&quot;---spring: application: name: &quot;MyCloudApp&quot; config: activate: on-cloud-platform: &quot;kubernetes&quot; 对于application.properties文件，使用特殊#---注释来标记文档拆分： 1234spring.application.name=MyApp#---spring.application.name=MyCloudAppspring.config.activate.on-cloud-platform=kubernetes 补充： 属性文件分隔符不能有任何前导空格，并且必须正好有三个连字符。分隔符前后的行不能是注释。 不能使用@PropertySource或@TestPropertySource注释加载多文档属性文件。 激活属性： 有时仅在满足某些条件时激活一组给定的属性很有用。可以通过spring.config.activate.*有条件的激活配置 配置 说明 on-profile 必须匹配才能使文档处于活动状态的配置文件表达式。 on-cloud-platform 在CloudPlatform必须对文件进行检测活跃。 下面例子表示仅在 Kubernetes 上运行并且prod或staging配置文件处于活动状态时才生效 12345myprop=always-set#---spring.config.activate.on-cloud-platform=kubernetesspring.config.activate.on-profile=prod | stagingmyotherprop=sometimes-set 配置导入加载spring配置文件 @ImportResource注解用于导入spring的xml文件 引入额外配置类 @ImportResource 注解用于可用于导入额外的配置类。 @ComponentScan自动选取所有 Spring 组件，包括@Configuration类。 外部配置导入获取外部配置的方式： 通过@Value注解 访问Environment 通过@ConfigurationProperties注解绑定到结构化对象 @Valuetodo Environment在springboot项目启动阶段会执行如下代码，用于创建environment对象，之后会将配置都加入到该对象中，包括环境变量、java环境变量、命令行参数，自定义配置文件等 1ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); todo @ConfigurationProperties使用@ConfigurationProperties可以获取指定前缀的结构化配置，比如下面配置文件的风格： 12345678my: service: remote-address: 192.168.1.1 security: username: &quot;admin&quot; roles: - &quot;USER&quot; - &quot;ADMIN&quot; 在属性绑定时属性名和配置名 不一定要完全匹配，spring boot会进行宽松绑定： 驼峰命名法（aaaBbb） 大写格式（AAABBB） 下划线表示法（aaa_bbb） 烤肉盒（aaa-bbb） 属性绑定1234567891011121314151617181920212223@ConfigurationProperties(&quot;my.service&quot;)public class MyProperties { private boolean enabled; private InetAddress remoteAddress; private final Security security = new Security(); // getters / setters... public static class Security { private String username; private String password; private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;)); // getters / setters... }} @ConfigurationProperties标记的类中的属性会注入Spring Boot中可用类的属性。上面javaBean定义了以下属性 my.service.enabled，默认值为false； my.service.remote-address, 一个被可以被解析的String； my.service.security.username，带有一个嵌套的“安全”对象，其名称由属性的名称决定； my.service.security.password； my.service.security.roles,默认为USER的集合String； 可以在其他bean使用，与@ConfigurationProperties标记的类属性注入方式类似 123456789101112131415161718@Servicepublic class MyService { private final SomeProperties properties; public MyService(SomeProperties properties) { this.properties = properties; } public void openConnection() { Server server = new Server(this.properties.getRemoteAddress()); server.start(); // ... } // ...} 补充： 通过属性文件、YAML 文件、环境变量和其他机制配置； getter无论何时都是必须的，setter不一定，因为可以通过绑定器也可以赋值； 初始化嵌套的pojo不setter不是必要的； 不支持静态属性绑定 构造函数绑定12345678910111213141516171819202122232425262728293031@ConstructorBinding@ConfigurationProperties(&quot;my.service&quot;)public class MyProperties { // fields... public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) { this.enabled = enabled; this.remoteAddress = remoteAddress; // 如果没有匹配到，security为null // 如果希望非空可以在参数列表使用@DefaultValue注释 this.security = security; } // getters... public static class Security { // fields... public Security(String username, String password, @DefaultValue(&quot;USER&quot;) List&lt;String&gt; roles) { this.username = username; this.password = password; this.roles = roles; } // getters... } } 补充： @ConstructorBinding注释用于指示应使用构造函数绑定，绑定器会尝试找到对应的构造函数； 如果有多个构造函数，可以将@ConstructorBinding放在应该绑定的构造函数上； 类的嵌套成员也将通过它们的构造函数绑定； 可以通过@DefaultValue注解指定默认值； 不能对由常规 Spring 机制创建的 bean 使用构造函数绑定（@Component、@Bean、@Import） 启用@ConfigurationProperties注释@ConfigurationProperties注解需要配合@EnableConfigurationProperties或组件扫描器使用。但有些情况下，必须使用@EnableConfigurationProperties注释，比如想要有条件的启用。 123456@Configuration(proxyBeanMethods = false)//指定对应的class@EnableConfigurationProperties(SomeProperties.class)public class MyConfiguration {} 如果想要使用配置属性扫描，请将@ConfigurationPropertiesScan注释添加到应用程序中，一般是声明在启动类或@Configuration类。 123456@SpringBootApplication//指定扫描路径@ConfigurationPropertiesScan({ &quot;com.example.app&quot;, &quot;com.example.another&quot; })public class MyApplication {} @ConfigurationProperties配置类的名称格式为：&lt;prefix&gt;-&lt;fqn &lt;prefix&gt;是@ConfigurationProperties注解中指定的环境前缀 &lt;fqn&gt;是 bean 的完全限定名称 如果注释不提供任何前缀，则仅使用 bean 的完全限定名称。 上面示例中的 bean 名称是com.example.app-com.example.app.SomeProperties。 建议@ConfigurationProperties只处理环境，不要冲上下文中注入其他bean。如果必须要用，可以使用 setter 注入或*Aware框架提供的接口。如果必须要用构造函数注入其他bean，则必须使用由@Component注释的JavaBean的属性绑定bean。 第三方配置对于一些第三方组件可以通过以下形式从Environment中向bean注入属性 12345678910@Configuration(proxyBeanMethods = false)public class ThirdPartyConfiguration { @Bean @ConfigurationProperties(prefix = &quot;another&quot;) public AnotherComponent anotherComponent() { return new AnotherComponent(); }} @ConfigurationProperties 与 @Value区别 特征 @ConfigurationProperties @Value 宽松绑定 是 有限 元数据支持 是 否 SpEL表达式 否 是 @Value仅使用小写字母来引用属性名称时支持宽松绑定 Profilesspring profiles提供了一种分离应用程序配置部分，并使其在默写环境下生效，可以为@Component，@Configuration或者@ConfigurationProperties标记加载限制 1234567@Configuration(proxyBeanMethods = false)@Profile(&quot;production&quot;)public class ProductionConfiguration { // ...} 补充： 如果@ConfigurationProperties是通过@EnableConfigurationProperties引入，那么@Profile需要加在具有@EnableConfigurationProperties注解的@Configuration类上； 如果ConfigurationProperties是通过自动扫描的，@Profile可以在@ConfigurationProperties类本身上指定； 指定环境可以使用spring.profiles.active 指定Environment来限制哪些配置文件处于活动状态。 在配置文件中指定： 1spring.profiles.active=dev,hsqldb 在命令行上指定： 1--spring.profiles.active=dev,hsqldb 如果没有配置文件处于活动状态，则启用默认配置文件：default，可以使用spring.profiles.default 对Environment属性进行调整 1spring.profiles.default=none 可以通过SpringApplication.setAdditionalProfiles(…)在应用程序运行之前调用来以编程方式设置活动配置文件。也可以使用 Spring 的ConfigurableEnvironment接口激活配置文件。 配置组有时，应用程序的配置文件定义太过精细，不同的配置放在一起也不好管理。为了解决这个问题，spring boot允许配置Profile Groups 123# 格式 spring.profiles.group.自定义逻辑名称[索引]=配置文件名spring.profiles.group.production[0]=proddbspring.profiles.group.production[1]=prodmq 在启动应用程序时需要激活production、proddb和prodmq配置文件，添加启动参数 1--spring.profiles.active=production","link":"/2021/05/22/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"},{"title":"Spring Boot 源码解析（三）SpringApplication 初始化","text":"Spring Boot 项目在开始导入依赖前会首先进行初始化操作 项目启动类如下： 123456@SpringBootApplicationpublic class SpringBootMytestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMytestApplication.class, args); }} 进入run()方法中： 123456789public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) { //调用重载方法 return run(new Class&lt;?&gt;[] { primarySource }, args);}//最终执行方法public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args);} 可见，spring boot的run()方法分为两部分 初始化SpringApplication配置 执行run方法 本篇主要讨论初始化SpringApplication部分，进入new SpringApplication(primarySources)中 12345678910111213141516171819202122232425262728public SpringApplication(Class&lt;?&gt;... primarySources) { this(null, primarySources);}private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;//进入重载方法public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { //此时resourceLoader为null this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); //此时primarySources为启动类SpringBootMytestApplication的class对象，将其转化为Set进行保存 this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //以下四个方法重要 //1、判断当前应用环境，一共有三种，一般为servlet this.webApplicationType = WebApplicationType.deduceFromClasspath(); //2、初始化classpath下 META-INF/spring.factories文件中 //配置的key为ApplicationContextInitializer的实例，并保存至实例变量中 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //3、和2中操作类似，只不过这里key为ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //4、推测 main 方法的类名 this.mainApplicationClass = deduceMainApplicationClass();}private ResourceLoader resourceLoader;private Set&lt;Class&lt;?&gt;&gt; primarySources;private WebApplicationType webApplicationType;private Class&lt;?&gt; mainApplicationClass; 下面分别介绍上述代码中的四个方法 获取应用环境进入WebApplicationType.deduceFromClasspath() 123456789101112131415161718192021222324252627282930313233343536//第一部分private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.web.servlet.DispatcherServlet&quot;;private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.springframework.web.reactive.DispatcherHandler&quot;;private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;;//第二部分private static final String[] SERVLET_INDICATOR_CLASSES = { &quot;javax.servlet.Servlet&quot;, &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; };static WebApplicationType deduceFromClasspath() { //ClassUtils.isPresent方法用于判断当前class loader中是否存在对应的类型 //如果存在上面第一部分三个常量中的DispatcherServlet，并且另外两个不存在， //这样证明这个项目是一个反应式 Web 应用程序，应该返回REACTIVE //一般情况下此时应该只存在WEBMVC_INDICATOR_CLASS if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } //SERVLET_INDICATOR_CLASSES中的两个类有一个不存在时返回NONE. //这两个类有一个不存在证明不是web应用程序. for (String className : SERVLET_INDICATOR_CLASSES) { if (!ClassUtils.isPresent(className, null)) { return WebApplicationType.NONE; } } //上述条件都不成立返回SERVLET return WebApplicationType.SERVLET;} 上面返回值的注解类如下 1234567891011121314151617public enum WebApplicationType { /** * 该应用程序不应作为 Web 应用程序运行，也不应启动嵌入式 Web 服务器。 */ NONE, /** * 该应用程序应作为基于 servlet 的 Web 应用程序运行，并应启动嵌入式 servlet Web 服务器。 */ SERVLET, /** * 该应用程序应作为反应式 Web 应用程序运行，并应启动嵌入式反应式 Web 服务器。 */ REACTIVE;} 上下文初始化器首先进入setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));中的getSpringFactoriesInstances(ApplicationContextInitializer.class)方法 12345678910111213141516private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) { return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {});}//进入getSpringFactoriesInstances()方法private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { //获取当前类加载器 ClassLoader classLoader = getClassLoader(); //通过上面获得的classLoader从META-INF/spring.factories 的资源文件中读取key为type.getName()的value //因为要确保唯一，所以转化为set集合 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //根据names创建springFactory实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //如果标注了Order注解，则按照注解进行排序 AnnotationAwareOrderComparator.sort(instances); return instances;} loadFactoryNames() 方法loadFactoryNames()方法是spring-core中提供的从META-INF/spring.factories中获取指定的类 （key）的同一入口方法。进入SpringFactoriesLoader.loadFactoryNames(type, classLoader)方法 123456public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { //factoryType为上面传入的ApplicationContextInitializer.class String factoryTypeName = factoryType.getName(); //根据factoryTypeName获取META-INF/spring.factories文件中对应的全类名 return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());} loadSpringFactories(classLoader)方法作用为获取META-INF/spring.factories文件中的全部配置信息，并封装成Map&lt;String, List&lt;String&gt;&gt;进行返回，此处不再展开。 所以此处最终返回的就是spring.factories文件中key为ApplicationContextInitializer的全类名集合，结果如下： createSpringFactoriesInstances() 方法进入createSpringFactoriesInstances方法中 12345678910111213141516171819202122private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) { //创建bean实例 List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size()); for (String name : names) { try { //获取class对象 Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader); Assert.isAssignable(type, instanceClass); //获取构造方法 Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes); //创建实例对象 T instance = (T) BeanUtils.instantiateClass(constructor, args); //添加到集合 instances.add(instance); } catch (Throwable ex) { throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex); } } return instances;} 该方法利用反射依次遍历names，然后创建对应的实例对象并加入到数组，最终返回，返回的结果如下： 监听器获取监听器实例集合与第2步类似，只不过这里key为ApplicationListener，此处直接展示结果 获取main方法类名进入deduceMainApplicationClass()方法 123456789101112131415161718private Class&lt;?&gt; deduceMainApplicationClass() { try { //获取堆栈信息 StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); //对获取的堆栈信息进行遍历 for (StackTraceElement stackTraceElement : stackTrace) { //判断对应堆栈的方法名是否为main if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) { //若是，即为启动类，使用forName创建对象实例并返回 return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { // Swallow and continue } return null;}","link":"/2020/10/15/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"Spring Boot 源码解析（二）@SpringBootApplication注解","text":"Spring Boot 项目入口所标记的 @SpringBootApplication 注解的作用和意义 创建Spring Boot工程后会自动生成一个启动类，用于启动spring boot项目： 123456@SpringBootApplicationpublic class SpringBootMytestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMytestApplication.class, args); }} 这个类中标注了@SpringBootApplication注解，进入到这个注解中： 123456789101112@Target(ElementType.TYPE) //注解标注的适用范围@Retention(RetentionPolicy.RUNTIME) //注解的生命周期@Documented //记录在doc文档中@Inherited //可被继承//------------------------------------------------------------------@SpringBootConfiguration //配置类@EnableAutoConfiguration //启动自动配置@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { ...} 可以看到这个注解是个组合注解，上面四个是元注解，下面三个是spring注解，接下来对其单独介绍 @SpringBootConfiguration进入到@SpringBootConfiguration注解中： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration { @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true;} 从上述源码可以看出，@SpringBootConfiguration注解内部有一个核心注解@Configuration，该注解是Spring框架提供的，表示当前类为一个配置类，并可以被组件扫描器扫描。由此可见，@SpringBootConfiguration注解的作用与@Configuration注解相同，都是标识一个可以被组件扫描器扫描的配置类，只不过@SpringBootConfiguration是被Spring Boot进行了重新封装命名而已 。 @EnableAutoConfiguration进入到@EnableAutoConfiguration注解中： 123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default {}; String[] excludeName() default {};} 除了元注解之外还有两个注解，为@AutoConfigurationPackage注解和@Import注解。 @AutoConfigurationPackage进入到@AutoConfigurationPackage注解中： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage {} 可以发现，@AutoConfigurationPackage注解中也使用了@Import注解，引入了AutoConfigurationPackages.Registrar.class类，这个类的registerBeanDefinitions方法会在spring boot刷新上下文时被创建，进入这个内部类中 12345678910111213static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { //这个方法是向ioc中注册组件 register(registry, new PackageImport(metadata).getPackageName()); } @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImport(metadata)); }} 使用Debug模式启动项目可以看到 new PackageImport(metadata).getPackageName()的值为 进入register方法内部： 1234567891011121314151617181920private static final String BEAN = AutoConfigurationPackages.class.getName();public static void register(BeanDefinitionRegistry registry, String... packageNames) { //检查AutoConfigurationPackages.class是否已经被加载 if (registry.containsBeanDefinition(BEAN)) {//已注册 //获取beanDefinition BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); //获取构造参数值 ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues(); //更改参数中的packageNames constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); } else {//未注册则创建beanDefinition并将其注册到的ioc容器中 GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN, beanDefinition); }} 该方法参数有两个： packageNames：packageNames为项目的包名集合，在本项目中为com.zcy.springboottest。 registry：registry的类型为BeanDefinitionRegistry，我们常说的ioc容器其实就是 Beanfactory 中的一个 Map，key 是 Bean 的名称，value 是 Bean 对应的 BeanDefinition。BeanDefinitionRegistry 是一个接口，它定义了关于 BeanDefinition 的注册、移除、查询等一系列的操作，注册 Bean 的方法是 registerBeanDefinition。 此处@AutoConfigurationPackage注解的主要作用就是向ioc容器中注入了一个name为常量BEAN的beanDefinition，这个beanDefinition中存储着启动类的beanClass、packageNames等相关信息 @Import这个注解是自动配置的核心，上面通过@Import注解将AutoConfigurationImportSelector类引入， 1234public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { ... } 类关系图如下： AutoConfigurationImportSelector实现了很多接口： Aware接口：用于获取bean的相关信息 Ordered接口：用于处理相同接口实现类的优先级问题。 DeferredImportSelector接口：它是ImportSelector的子接口，ImportSelector接口是spring中导入外部配置的核心接口 自动配置执行流程在启动spring boot时自动配置的方法调用流程为： 如上图所示，spring boot启动时会调用ConfigurationClassParser类的process()方法，在这个方法中会调用handler.processGroupImports()，在其中调用grouping.getImports()方法。在getImports()方法中会分别调用两个DeferredImportSelector的内部类Group的方法（process和selectImports） 12345678910public Iterable&lt;Entry&gt; getImports() {Iterator var1 = this.deferredImports.iterator(); while(var1.hasNext()) { ConfigurationClassParser.DeferredImportSelectorHolder deferredImport = (ConfigurationClassParser.DeferredImportSelectorHolder)var1.next(); this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); } return this.group.selectImports();} process()方法1234567891011121314151617private final Map&lt;String, AnnotationMetadata&gt; entries = new LinkedHashMap&lt;&gt;();@Overridepublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) { Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); //获取自动配置实体 AutoConfigurationEntry autoConfigurationEntry =((AutoConfigurationImportSelector)deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry); //加入到entries集合 for (String importClassName : autoConfigurationEntry.getConfigurations()) { this.entries.putIfAbsent(importClassName, annotationMetadata); }} process()方法中首先通过getAutoConfigurationEntry方法获取自动配置类，然后又将自动配置类都加入到了entries中。 进入getAutoConfigurationEntry()方法，其中方法的调用和作用如下所示： 123456789101112131415161718192021protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); //获取spring.factories中每一个xxxAutoConfiguration List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //移除名字相同的配置类 configurations = removeDuplicates(configurations); //获取将要排除的自动配置类 //@SpringBootApplication可以指定exclude属性和excludeName属性用于排除特定的自动配置类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); //根据自动配置类上的注解进行过滤 configurations = filter(configurations, autoConfigurationMetadata); //触发事件 fireAutoConfigurationImportEvents(configurations, exclusions); //封装复合条件的自动配置类和排除的自动配置类 return new AutoConfigurationEntry(configurations, exclusions);} getCandidateConfigurations()方法在AutoConfigurationImportSelector中存在一个getCandidateConfigurations方法，它负责把 spring-boot-autoconfigure.jar/META-INF/spring.factories中每一个xxxAutoConfiguration文件都加载到容器中 12345678protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { //spring.factories中每一个xxxAutoConfiguration文件都加载到容器中 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;+ &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations;} SpringFactoriesLoader是一个抽象类，其主要功能就是从指定的配置文件META-INF/spring-factories加载配置，类中定义的静态属性定义了其加载资源的路径： public static final String FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories” 此外还有三个静态方法： loadFactories：加载指定的factoryClass并进行实例化。 loadFactoryNames：加载指定的factoryClass的名称集合。 instantiateFactory：对指定的factoryClass进行实例化。 以debug的方式启动项目观察到返回的值为： 可以发现AutoConfiguration类都被引入了。 getExclusions()方法1234567protected Set&lt;String&gt; getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) { Set&lt;String&gt; excluded = new LinkedHashSet&lt;&gt;(); excluded.addAll(asList(attributes, &quot;exclude&quot;)); excluded.addAll(Arrays.asList(attributes.getStringArray(&quot;excludeName&quot;))); excluded.addAll(getExcludeAutoConfigurationsProperty()); return excluded;} 在启动类上的@SpringBootApplication注解中可以指定exclude属性和excludeName属性用于排除特定的自动配置类，该方法就是将这些排除项取出 filter()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private List&lt;String&gt; filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata) { long startTime = System.nanoTime(); //将spring.factories中获取的自动配置类转出字符串数组 String[] candidates = StringUtils.toStringArray(configurations); //定义skip数组，用于判定是否需要跳过 boolean[] skip = new boolean[candidates.length]; //getAutoConfigurationImportFilters方法：拿到OnBeanCondition，OnClassCondition和OnWebApplicationCondition //然后遍历这三个条件类去过滤从spring.factories加载的大量配置类 boolean skipped = false; for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) { // 调用各种aware方法，将beanClassLoader,beanFactory等注入到filter对象中， // 这里的filter对象即OnBeanCondition，OnClassCondition或OnWebApplicationCondition invokeAwareMethods(filter); // 判断各种filter来判断每个candidate（这里实质要通过candidate(自动配置类)拿到其标注的 // @ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication里面的注解值）是否匹配， // 注意candidates数组与match数组一一对应 boolean[] match = filter.match(candidates, autoConfigurationMetadata); // 遍历match数组，注意match顺序跟candidates的自动配置类一一对应 for (int i = 0; i &lt; match.length; i++) { //如果不匹配 if (!match[i]) { skip[i] = true; candidates[i] = null; skipped = true; } } } // 这里表示若所有自动配置类经过OnBeanCondition，OnClassCondition和OnWebApplicationCondition过滤后， // 全部都匹配的话，则全部原样返回 if (!skipped) { return configurations; } // 建立result集合来装匹配的自动配置类 List&lt;String&gt; result = new ArrayList&lt;&gt;(candidates.length); for (int i = 0; i &lt; candidates.length; i++) { // 若skip[i]为false，则说明是符合条件的自动配置类，此时添加到result集合中 if (!skip[i]) { result.add(candidates[i]); } } //打印日志 if (logger.isTraceEnabled()) { int numberFiltered = configurations.size() - result.size(); logger.trace(&quot;Filtered &quot; + numberFiltered + &quot; auto configuration class in &quot; + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + &quot; ms&quot;); } // 最后返回符合条件的自动配置类 return new ArrayList&lt;&gt;(result);} 该方法会根据每个xxxAutoConfiguration配置类上的条件注解判断该类是否应该被加载，最后再将自动配置类集合返回 条件注解spring.factories文件里每一个xxxAutoConfiguration文件上的条件注解包括： @ConditionalOnClass ： classpath中存在该类时起效 @ConditionalOnMissingClass ： classpath中不存在该类时起效 @ConditionalOnBean ： DI容器中存在该类型Bean时起效 @ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效 @ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效 @ConditionalOnExpression ： SpEL表达式结果为true时 @ConditionalOnProperty ： 参数设置或者值一致时起效 @ConditionalOnResource ： 指定的文件存在时起效 @ConditionalOnJndi ： 指定的JNDI存在时起效 @ConditionalOnJava ： 指定的Java版本存在时起效 @ConditionalOnWebApplication ： Web应用环境下起效 @ConditionalOnNotWebApplication ： 非Web应用环境下起效 selectImports()方法12345678910111213141516171819@Overridepublic Iterable&lt;Entry&gt; selectImports() { if (this.autoConfigurationEntries.isEmpty()) { return Collections.emptyList(); } //得到所有要清除的自动配置类 Set&lt;String&gt; allExclusions = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getExclusions).flatMap(Collection::stream).collect(Collectors.toSet()); //得到所有符合条件的自动配置类 Set&lt;String&gt; processedConfigurations = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getConfigurations).flatMap(Collection::stream) .collect(Collectors.toCollection(LinkedHashSet::new)); //再次过滤 processedConfigurations.removeAll(allExclusions); //对标注了@Ordered注解的配置类进行排序 return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream() .map((importClassName) -&gt; new Entry(this.entries.get(importClassName), importClassName)) .collect(Collectors.toList());} selectImports 方法主要是针对经过排除掉 exclude 的和被AutoConfigurationImportFilter 接口过滤后的满足条件的自动配置类再进一步排除 exclude 的自动配置类，然后再排序。 @ComponentScan@ComponentScan用于类或接口上用于指定扫描路径，spring会把指定路径下带有指定注解的类自动装配到bean容器里。其作用等同于&lt;context:component-scan base-package=”xxx” /&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan { @AliasFor(&quot;basePackages&quot;) String[] value() default {}; // 指定扫描路径，如果为空则以@ComponentScan注解的类所在的包为基本的扫描路径 @AliasFor(&quot;value&quot;) String[] basePackages() default {}; // 指定具体扫描的类 Class&lt;?&gt;[] basePackageClasses() default {}; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class; ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; String resourcePattern() default &quot;**/*.class&quot;; boolean useDefaultFilters() default true; // 指定满足Filter条件的类 ComponentScan.Filter[] includeFilters() default {}; // 指定排除Filter条件的类 ComponentScan.Filter[] excludeFilters() default {}; boolean lazyInit() default false; @Retention(RetentionPolicy.RUNTIME) @Target({}) public @interface Filter { FilterType type() default FilterType.ANNOTATION; @AliasFor(&quot;classes&quot;) Class&lt;?&gt;[] value() default {}; @AliasFor(&quot;value&quot;) Class&lt;?&gt;[] classes() default {}; String[] pattern() default {}; }} @SpringBootApplication注解中@ComponentScan注解的为： 123456@ComponentScan( excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) 表示排除TypeExcludeFilter和AutoConfigurationExcludeFilter两个类，其中FilterType： 123456789101112131415public enum FilterType { // 注解类型 ANNOTATION, // 指定的类型 ASSIGNABLE_TYPE, // 按照Aspectj的表达式，基本上不会用到 ASPECTJ, // 按照正则表达式 REGEX, // 自定义规则 CUSTOM; private FilterType() { }}","link":"/2020/09/10/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Spring Boot 源码解析（五）bean注册顺序","text":"Spring Boot 在启动时将 bean 注册进 ioc 容器中，包括 Spring Boot 内置的 bean 、启动类引入的 bean 及自定义的 bean 本文讨论的是所有 bean 注入到 ioc 容器中的流程 bean注册顺序spring会将 bean 封装为beanDefination然后通过方法注入到ioc容器中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); //检查传入的beanDefinition是否是AbstractBeanDefinition类型 if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition)beanDefinition).validate(); } catch (BeanDefinitionValidationException var8) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, var8); } } //看当前ioc容器中是否存在名为beanName的bean，不存在则返回null BeanDefinition existingDefinition = (BeanDefinition)this.beanDefinitionMap.get(beanName); //如果已存在 if (existingDefinition != null) { //如果不允许bean覆盖，则报错 if (!this.isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); } /** 关于AbstractBeanDefinition的role属性 * ROLE_APPLICATION = 0 :用户 * ROLE_SUPPORT = 1：某些复杂配置一部分 * ROLE_INFRASTRUCTURE = 2：完全内部使用，与用户无关 * 定义这个bean的应用 */ // 如果已存在的bean的role更小，输出框架的bean覆盖用户定义的bean if (existingDefinition.getRole() &lt; beanDefinition.getRole()) { if (this.logger.isInfoEnabled()) { this.logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName + &quot;' with a framework-generated bean definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } //如果是一个bean } else if (!beanDefinition.equals(existingDefinition)) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with a different definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } else if (this.logger.isTraceEnabled()) { this.logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with an equivalent definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } //当前bean覆盖原有bean this.beanDefinitionMap.put(beanName, beanDefinition); } else { //这里底层逻辑是return !this.alreadyCreated.isEmpty(); //alreadyCreated是AbstractBeanFactory类的一个类型为Set&lt;String&gt;的属性 //这里的意思是alreadyCreated集合不为空，表示开始自动配置bean和自定义bean的注册 //springboot创建时会先将一些内置的Processor和Reader注册到ioc中， //加入完成后才会加载其他的bean，这个if就是判断是否开始加载其他bean if (this.hasBeanCreationStarted()) { synchronized(this.beanDefinitionMap) { //加入ioc容器 this.beanDefinitionMap.put(beanName, beanDefinition); //这里不直接添加beanName是因为异步，并且beanDefinitionNames线程不安全 //创建一个新的beanDefinitionNames集合 List&lt;String&gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); //将原有的beanDefinitionNames集合和当前beanName添加进去 updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); //替换原有的 this.beanDefinitionNames = updatedDefinitions; this.removeManualSingletonName(beanName); } } else { //加入ioc容器 this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.removeManualSingletonName(beanName); } this.frozenBeanDefinitionNames = null; } if (existingDefinition == null &amp;&amp; !this.containsSingleton(beanName)) { if (this.isConfigurationFrozen()) { this.clearByTypeCache(); } } else { this.resetBeanDefinition(beanName); }} 使用debug进行调试 在进入当前if语句内时已经经过了七次else，此时的beanDefinitionMap数据为： 结论根据上述分析可知bean注册的顺序分别为： 内置（处理器）Processor和（读取器）Reader，用于读取和处理配置 启动类 启动类包下的标记@Configuration、@controller、@component等注解的bean 自动配置类的bean","link":"/2021/01/18/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"},{"title":"Spring Boot 源码解析（四）run()方法执行流程","text":"Spring Boot 将依赖注入到 IOC 容器的过程 前一篇说到这个方法 123public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args);} SpringApplication初始化完成后执行run方法，进入run方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ConfigurableApplicationContext run(String... args) { //记录运行时间 StopWatch stopWatch = new StopWatch(); stopWatch.start(); //上下文对象 ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); //1、获取并启动监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //2、构造应用上下文环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); //3、初始化上下文 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] {ConfigurableApplicationContext.class }, context); //4、刷新应用上下文前的准备阶段 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //5、刷新应用上下文 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } listeners.started(context); callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context;} 由上面可知，run方法中重要步骤有六步 获取并启动监听器 获取并启动监听器获取并启动监听器相关代码如下： 123//1、获取并启动监听器SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting(); 进入getRunListeners方法中 1234567891011private SpringApplicationRunListeners getRunListeners(String[] args) { Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class }; //返回的是一个新建的SpringApplicationRunListeners对象 //第一个参数为logger，第二个参数为getSpringFactoriesInstances方法的返回值 return new SpringApplicationRunListeners( logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args) );} 上面调用了方法有两个，分别为getSpringFactoriesInstances()方法和new SpringApplicationRunListeners()方法，其中第一个方法是个构造方法，而第二个方法在上一篇初始化阶段就已经介绍过，就是获取Initializers和Listeners所调用的方法 12345678910111213141516171819202122232425//首先进入new SpringApplicationRunListeners()方法//可以看到这个方法只是简单的将外部传递的log和listeners集合赋值给了对象的属性SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners) { this.log = log; this.listeners = new ArrayList&lt;&gt;(listeners);}//接着看获取listeners集合的getSpringFactoriesInstances()方法//其实就是根据传入的key获取对应的spring.factories文件中的list集合private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { //获取当前类加载器 ClassLoader classLoader = getClassLoader(); //在META-INF/spring.factories 的资源文件中读取key为 //org.springframework.boot.SpringApplicationRunListener的value Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //获得springFactory实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //排序 AnnotationAwareOrderComparator.sort(instances); return instances;}//spring.factories文件中对应获取的数据，只有一个# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener EventPublishingRunListener监听器是用来监听spring boot在启动过程中不同阶段的事件，并且把这些事件通知给初始化阶段获取的ApplicationListener的那11个监听器 getRunListeners(args)的这部分方法执行完毕后返回的就是一个SpringApplicationRunListeners对象，内部包含了监听器集合，然后会调用listeners.starting()方法 1234567void starting() { //此方法只是将listeners对象中的监听器集合进行遍历，分别调用starting()方法 //此时集合内只有一个listener for (SpringApplicationRunListener listener : this.listeners) { listener.starting(); }} 构建应用上下文环境构建应用上下文环境部分负责加载和配置系统的环境变量以yml和propertise配置文件的相关信息，后面如果想要获取配置文件和环境变量等信息就可以直接查找到，相关代码如下： 123456//2、构造应用上下文环境ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);//处理需要忽略的beanconfigureIgnoreBeanInfo(environment);//打印spring启动时的那个图标Banner printedBanner = printBanner(environment); 下面两个方法比较简单，首先来看一下configureIgnoreBeanInfo方法 12345678910public static final String IGNORE_BEANINFO_PROPERTY_NAME = &quot;spring.beaninfo.ignore&quot;;private void configureIgnoreBeanInfo(ConfigurableEnvironment environment) { //是否配置了spring.beaninfo.ignore if (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) { //根据配置的spring.beaninfo.ignore的配置来判断是否忽略，后面会用来忽略一些bean Boolean ignore = environment.getProperty(&quot;spring.beaninfo.ignore&quot;, Boolean.class, Boolean.TRUE); System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString()); }} 进入prepareEnvironment方法 1234567891011121314151617181920212223242526private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) { //（1）创建和配置环境变量 //创建环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); //配置环境信息 configureEnvironment(environment, applicationArguments.getSourceArgs()); //添加新建的一个name为configurationProperties的source ConfigurationPropertySources.attach(environment); //（2）启动响应监听器 listeners.environmentPrepared(environment); //将environment绑定到SpringApplication上 //里面只有一行代码：Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this)); bindToSpringApplication(environment); //是自定义环境 if (!this.isCustomEnvironment) { //添加环境转换器 environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary( environment, deduceEnvironmentClass() ); } //和上面调用的一个方法 ConfigurationPropertySources.attach(environment); return environment;} 创建和配置环境变量进入getOrCreateEnvironment方法 123456789101112131415private ConfigurableEnvironment getOrCreateEnvironment() { //如果不为null直接返回 if (this.environment != null) { return this.environment; } //根据当前应用类型初始化不同的环境变量 switch (this.webApplicationType) { case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); }} 一般的非响应式的web项目项目类型都是SERVLET，所以会返回StandardServletEnvironment类型对象 获取环境对象后，进入configureEnvironment(environment, applicationArguments.getSourceArgs())方法，配置环境信息 123456789101112protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) { //设置类型转换的服务接口 if (this.addConversionService) { ConversionService conversionService = ApplicationConversionService.getSharedInstance(); environment.setConversionService((ConfigurableConversionService) conversionService); } //该方法会将args封装成SimpleCommandLinePropertySource对象 //然后注入到environment的propertySources属性中(args不为空的话) configurePropertySources(environment, args); //激活配置文件，其实就是将配置添加到environment的activeProfiles属性中 configureProfiles(environment, args);} environment对象内容如下 将propertySources展开就可以看到： 上面name为环境的标识，source保存的是相关信息，此处展开的是环境信息，除此之外还有jdk信息、命令行参数信息等等。例如命令行参数的配置信息name为commandLineArgs 上面都完成之后会调用ConfigurationPropertySources.attach(environment)方法，该方法作用就是添加一个新建的name为configurationProperties的source，至此环境配置结束。 启动响应监听器启动监听器的部分包括： 12345678910111213141516//（2）启动响应监听器listeners.environmentPrepared(environment);//将environment绑定到SpringApplication上//里面只有一行代码：Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));bindToSpringApplication(environment);//是自定义环境if (!this.isCustomEnvironment) { //添加环境转换器 environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary( environment, deduceEnvironmentClass() );}//和上面调用的一个方法ConfigurationPropertySources.attach(environment);return environment; 首先进入environmentPrepared方法 123456void environmentPrepared(ConfigurableEnvironment environment) { //遍历this.listeners，里面只有一个元素，就是上面获取的EventPublishingRunListener for (SpringApplicationRunListener listener : this.listeners) { listener.environmentPrepared(environment); }} 最终会进入Spring的方法如下方法 1234567891011121314151617181920212223public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) { ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event); //获取任务执行器 Executor executor = this.getTaskExecutor(); //主要是这里 //获取了一个迭代器，里面是监听器 Iterator var5 = this.getApplicationListeners(event, type).iterator(); //下面依次进行遍历 while(var5.hasNext()) { ApplicationListener&lt;?&gt; listener = (ApplicationListener)var5.next(); //如果executor不为null if (executor != null) { //用executor进行执行 executor.execute(() -&gt; { this.invokeListener(listener, event); }); } else { //否则直接执行 this.invokeListener(listener, event); } }} 上面获取迭代器的this.getApplicationListeners(event, type)得到的值其实就是初始化时的11个监听器中的七个（这7个单独在同一个spring.factories文件中） 其中第一个监听器ConfigFileApplicationListener就是用于加载配置文件（yml和propertise）的，进入这个监听器内可以看到如下注解（这里为了方便看，我将英文全部替换成中文）： 1234567891011121314151617181920212223242526/** * 默认会加载'application.properties' and/or 'application.yml'两个文件内容来配置上下文， * 会在下面四个路径中寻找配置文件 * &lt;ul&gt; * file是工程根目录，和src同级 * classpath是resource下 * &lt;li&gt;file:./config/&lt;/li&gt; * &lt;li&gt;file:./&lt;/li&gt; * &lt;li&gt;classpath:config/&lt;/li&gt; * &lt;li&gt;classpath:&lt;/li&gt; * &lt;/ul&gt; * 该列表按优先级排序（在列表中较高位置定义的属性覆盖在较低位置定义的属性）。 * &lt;p&gt; * 可以使用特定的{@link #setSearchLocations(String)} 和 {@link #setSearchNames(String)} * 来替代搜索的位置和名称 * &lt;p&gt; * 还将根据动态配置加载其他文件。 * 例如，如果“web”配置文件处于活动状态，则将考虑加载“application-web.properties”和“application-web.yml”。 * &lt;p&gt; * “spring.config.name”属性可用于指定要加载的替代名称， * “spring.config.location”属性可用于指定替代搜索位置或特定文件。 * &lt;p&gt; */public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered { ...} 总之，使用EventPublishingRunListener监听器来触发这7个监听器中只有ConfigFileApplicationListener监听器负责加载配置文件，然后注入到environment中 配置文件加载规则根据上面ConfigFileApplicationListener类上的注释可以总结出spring boot配置文件加载方式，如下： 默认加载顺序： file:./config/ file:./ classpath:config/ classpath: file是工程根目录，和src同级 classpath是resource路径下 加载规则： 先加载的配置优先级更高 如果同级目录下存在yml和properties，则先读取properties 默认加载’application.properties’ 和 ‘application.yml’两个文件 还将根据动态配置加载其他文件，比如多环境下进行配置，使其加载application-dev或application-prop名字的文件文件 spring.config.name属性可用于指定要加载的替代名称， spring.config.location属性可用于指定替代搜索位置或特定文件。 初始化上下文该部分相关代码为： 1234567891011//上下文对象ConfigurableApplicationContext context = null;Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();...//3、初始化上下文context = createApplicationContext();//又是这个方法，根据传入的class作为key，创建spring.factories文件中对应的对象//exceptionReporters主要是用来报告spring boot启动过程中的错误exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); 上下文对象即为ConfigurableApplicationContext类型的context对象。ConfigurableApplicationContext是ApplicationContext的子类并在其之上增加了配置上下文的工具，具体类图如下： 从上图可以看到BeanFactory类，它提供了ioc容器的最基本形式，它的实现类包括 DefaultListableBeanFactory（spring boot用的是这个）、XmlBeanFactory、ApplicationContext等 进入createApplicationContext方法中 12345678910111213141516171819202122232425262728293031323334public static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = &quot;org.springframework.boot.&quot; + &quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;;public static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = &quot;org.springframework.&quot; + &quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;;public static final String DEFAULT_CONTEXT_CLASS = &quot;org.springframework.context.&quot; + &quot;annotation.AnnotationConfigApplicationContext&quot;;protected ConfigurableApplicationContext createApplicationContext() { Class&lt;?&gt; contextClass = this.applicationContextClass; //如果还没初始化上下文 if (contextClass == null) { try { //根据应用类型加载不同的contextClass类 switch (this.webApplicationType) { case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); } } catch (ClassNotFoundException ex) { throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); } } //根据加载到的contextClass进行实例化并转换类型后返回 return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);} 上面三个常量所对应的类的继承关系基本一致所以下面只列出AnnotationConfigServletWebServerApplicationContext的类关系图 其他两个类的继承关系的结构和上图基本一致，只不过某些类的实现和名称不同 上下文对象创建完成后context中的beanFactory 刷新应用上下文准备阶段刷新上下文准备阶段主要代码为： 12//4、刷新应用上下文前的准备阶段prepareContext(context, environment, listeners, applicationArguments, printedBanner); 进入refreshContext方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) { //将上一步获取的环境对象赋值给应用上下文对象 context.setEnvironment(environment); //（1）应用上下文后置方法，主要是添加转换器 postProcessApplicationContext(context); //（2）应用上面获取的那些初始化器 applyInitializers(context); //向第一步获取的监听器发送事件，这个监听器会触发其他相关监听器 listeners.contextPrepared(context); //记录启动信息 if (this.logStartupInfo) { logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); } // Add boot specific singleton beans //增加指定的单例bean //获取ioc容器 ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); //将main函数的参数封装成bean并注册 beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); //用于打印启动图标的printedBanner不为空，则注册 if (printedBanner != null) { beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); } //beanFactory真实类型是DefaultListableBeanFactory if (beanFactory instanceof DefaultListableBeanFactory) { ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } //是否懒加载 if (this.lazyInitialization) { context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); } //（3）加载启动类 //拿到启动类，set中只有一个对象，启动类 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); //注册启动类 load(context, sources.toArray(new Object[0])); //发布事件 listeners.contextLoaded(context);} 应用上下文后置方法应用上下文后置方法为postProcessApplicationContext(context)它的作用就是添加了大量的转换器，代码如下： 1234567891011121314151617181920protected void postProcessApplicationContext(ConfigurableApplicationContext context) { if (this.beanNameGenerator != null) { context.getBeanFactory().registerSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,this.beanNameGenerator); } if (this.resourceLoader != null) { if (context instanceof GenericApplicationContext) { ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader); } if (context instanceof DefaultResourceLoader) { ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader()); } } //添加转换器 if (this.addConversionService) { //ConversionService 是一个类型转换服务接口，并且还是线程安全的。 //ApplicationConversionService是他的一个实现类，里面包含了一大堆转换器 context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance()); }} 这里主要关注的是getSharedInstance方法 12345678910111213141516//getSharedInstance()这里使用了单例模式public static ConversionService getSharedInstance() { ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance; //双重锁检查 if (sharedInstance == null) { synchronized (ApplicationConversionService.class) { sharedInstance = ApplicationConversionService.sharedInstance; if (sharedInstance == null) { //新建ApplicationConversionService对象 sharedInstance = new ApplicationConversionService(); ApplicationConversionService.sharedInstance = sharedInstance; } } } return sharedInstance;} 可以看出，这里使用了单例模式，创建了ApplicationConversionService对象，进入该构造方法 123456789101112131415161718192021222324public ApplicationConversionService() { this(null);}public ApplicationConversionService(StringValueResolver embeddedValueResolver) { if (embeddedValueResolver != null) { setEmbeddedValueResolver(embeddedValueResolver); } //给this添加一堆转换器 configure(this);}//主要是configure(this)方法，它负责注入各种类型的转换器public static void configure(FormatterRegistry registry) { //添加默认转换器，也就是适用于大多数环境的转换器。 DefaultConversionService.addDefaultConverters(registry); //添加默认格式化程序，适用于大多数环境的格式化程序：包括数字格式化程序，JSR-354货币和货币格式化程序， //JSR-310日期时间格式化程序和/或Joda时间格式化程序，具体取决于类路径上相应API的存在。 DefaultFormattingConversionService.addDefaultFormatters(registry); //添加对大多数Spring Boot应用程序有用的格式化程序。 addApplicationFormatters(registry); //添加对大多数Spring Boot应用程序有用的转换器。 addApplicationConverters(registry);} 应用初始化器这里的初始化器指的是初始化阶段获取的那些，此处会调用他们进行初始化操作，每个初始化器执行的逻辑各有不同，进入applyInitializers方法中 123456789101112131415161718@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })protected void applyInitializers(ConfigurableApplicationContext context) { //遍历初始化阶段获取的初始化器 for (ApplicationContextInitializer initializer : getInitializers()) { //泛型工具类，resolveTypeArgument用来解析泛型参数 //这一步的的作用就是获取按照initializer的继承链向上找 //直到ApplicationContextInitializer类， //然后获取ApplicationContextInitializer类此时泛型的真实类型 //如果没有则返回空值 Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class); //判断context是不是上面的泛型类型的实例 Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;); //没问题了就初始化，这里每次遍历的initializer对象不同，经路的initialize方法实现也不同 //但基本都是为context执行一些初始化的操作，添加和设置一些东西包括上下文id，监听器等 initializer.initialize(context); }} 加载启动类这里主要的方法为load(context, sources.toArray(new Object[0])) 123456789101112131415161718protected void load(ApplicationContext context, Object[] sources) { if (logger.isDebugEnabled()) { logger.debug(&quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources)); } //获取loader //getBeanDefinitionRegistry(context)获取的register对象用于加载definition对象到ioc容器中 BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources); if (this.beanNameGenerator != null) { loader.setBeanNameGenerator(this.beanNameGenerator); } if (this.resourceLoader != null) { loader.setResourceLoader(this.resourceLoader); } if (this.environment != null) { loader.setEnvironment(this.environment); } loader.load();} 进入load方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int load() { int count = 0; for (Object source : this.sources) { //调用重载方法 count += load(source); } return count;}//重载方法private int load(Object source) { Assert.notNull(source, &quot;Source must not be null&quot;); //从Class加载 //source是启动类，会进入这里 if (source instanceof Class&lt;?&gt;) { return load((Class&lt;?&gt;) source); } //从Resource加载 if (source instanceof Resource) { return load((Resource) source); } //从Package加载 if (source instanceof Package) { return load((Package) source); } //从CharSequence加载 if (source instanceof CharSequence) { return load((CharSequence) source); } throw new IllegalArgumentException(&quot;Invalid source type &quot; + source.getClass());}//最终调用private int load(Class&lt;?&gt; source) { if (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) { // Any GroovyLoaders added in beans{} DSL can contribute beans here GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class); load(loader); } //是否标记了@Component，启动类上的组合注解包括该注解 if (isComponent(source)) { //注册启动类 this.annotatedReader.register(source); return 1; } return 0;} 刷新应用上下文这部分是spring boot自动配置的核心，相关代码为 1this.refreshContext(context); 由于这里主要使用spring的方法，而且嵌套过多，所以只列出相关代码其他省略，进入refreshContext方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void refreshContext(ConfigurableApplicationContext context) { if (this.registerShutdownHook) { try { context.registerShutdownHook(); } catch (AccessControlException var3) { } } //主要方法 this.refresh((ApplicationContext)context);}//进入this.refreshprotected void refresh(ApplicationContext applicationContext) { Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext); //主要方法 this.refresh((ConfigurableApplicationContext)applicationContext);}//进入this.refreshprotected void refresh(ConfigurableApplicationContext applicationContext) { applicationContext.refresh();}//进入applicationContext.refresh//这里是spring的源码，主要需要关注invokeBeanFactoryPostProcessors(beanFactory)方法的部分//它完成了ioc容器的上下文初始化过程public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. //刷新上下文环境 prepareRefresh(); //这里获取了spring boot之前创建的ioc容器 ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); //准备bean工厂，以便在此上下文中使用 prepareBeanFactory(beanFactory); obtainFreshBeanFactory(); try { //设置 beanFactory 的后置处理 postProcessBeanFactory(beanFactory); //调用 BeanFactory 的后处理器，这些处理器是在Bean 定义中向容器注册的 invokeBeanFactoryPostProcessors(beanFactory); //注册Bean的后处理器，在Bean创建过程中调用 registerBeanPostProcessors(beanFactory); //对上下文中的消息源进行初始化 initMessageSource(); //初始化上下文中的事件机制 initApplicationEventMulticaster(); //初始化其他特殊的Bean onRefresh(); //检查监听Bean并且将这些监听Bean向容器注册 registerListeners(); //实例化所有的（non-lazy-init）单件 finishBeanFactoryInitialization(beanFactory); //发布容器事件，结束Refresh过程 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 进入invokeBeanFactoryPostProcessors方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors()); //...}//进入invokeBeanFactoryPostProcessors方法public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { //... if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory; //... invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); }}//进入invokeBeanDefinitionRegistryPostProcessors方法private static void invokeBeanDefinitionRegistryPostProcessors(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) { Iterator var2 = postProcessors.iterator(); //遍历postProcessors并执行postProcessBeanDefinitionRegistry方法 while(var2.hasNext()) { BeanDefinitionRegistryPostProcessor postProcessor = (BeanDefinitionRegistryPostProcessor)var2.next(); //主要方法 postProcessor.postProcessBeanDefinitionRegistry(registry); }}//进入postProcessBeanDefinitionRegistry方法public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { //... this.processConfigBeanDefinitions(registry); //...}//进入processConfigBeanDefinitions方法public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList(); //中间过程为configCandidates添加了一个数据（启动类的BeanDefinitionHolder） if(...){ //... }else{ configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } //转换为set，应该是为了去重 Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet(configCandidates); do { //（1）这里面会解析各个注解，包括组合类中的两个@import，获取自动配置类 parser.parse(candidates); //... //获取了configClasses，后面将此作为参数传入loadBeanDefinitions开始注册过程 Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet(parser.getConfigurationClasses()); //... //（2）将获取的自动配置类加载到ioc中 this.reader.loadBeanDefinitions(configClasses); //... }while(!candidates.isEmpty());} 到了这里一共有两个重要的方法，下面分别讨论 parse方法进入到ConfigurationClassParser类的parse方法 12345678910111213141516171819202122232425262728public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { //便利configCandidates，此时只有一个启动类 Iterator var2 = configCandidates.iterator(); while(var2.hasNext()) { BeanDefinitionHolder holder = (BeanDefinitionHolder)var2.next(); BeanDefinition bd = holder.getBeanDefinition(); try { //前面将启动类封装成了AnnotatedBeanDefinition类型并注入ioc容器中 if (bd instanceof AnnotatedBeanDefinition) { //【1】、【2】步骤在这里面 //该方法主要就是解析各个注解的 this.parse(((AnnotatedBeanDefinition)bd).getMetadata(), holder.getBeanName()); } else if (...) { //... } else { //... } } catch (BeanDefinitionStoreException var6) { throw var6; } catch (Throwable var7) { throw new BeanDefinitionStoreException(&quot;...&quot;); } } //【3】加载默认的配置---》（对springboot项目来说这里就是自动装配的入口了） this.deferredImportSelectorHandler.process();} 注意这里this.parse(((AnnotatedBeanDefinition)bd).getMetadata(), holder.getBeanName());这个方法会解析类上的注解，并且该方法会递归调用，递归的情况有两种： 在这个方法执行过程中会判断当前类上是否有@Component/@Configuration注解，如果有就会递归调用parse方法 在此方法内处理@import注解时会通过调用processImports方法查找并引入相关的类，此时也会递归调用parse方法 进入parse方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException { this.processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);}//进入processConfigurationClassprotected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException { //这里会进行校验，符合条件才会执行下面方法 //... //这里sourceClass为启动类 ConfigurationClassParser.SourceClass sourceClass = this.asSourceClass(configClass, filter); do { //递归处理Bean，如果有父类，递归处理，直到顶层父类 sourceClass = this.doProcessConfigurationClass(configClass, sourceClass, filter); } while(sourceClass != null); this.configurationClasses.put(configClass, configClass);}//进入doProcessConfigurationClass方法，spring中do开头的才是真正干活的方法protected final ConfigurationClassParser.SourceClass doProcessConfigurationClass(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass, Predicate&lt;String&gt; filter) throws IOException { //处理内部类 if (configClass.getMetadata().isAnnotated(Component.class.getName())) { this.processMemberClasses(configClass, sourceClass, filter); } //处理@PropertySource注解 //并将该注解指定的properties配置文件中的值存储到Spring的 Environment中 //Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值。 Iterator var4 = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, PropertySource.class).iterator(); AnnotationAttributes importResource; while(var4.hasNext()) { importResource = (AnnotationAttributes)var4.next(); if (this.environment instanceof ConfigurableEnvironment) { this.processPropertySource(importResource); } else { this.logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); } } //【1】处理@ComponentScan注解 Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { Iterator var14 = componentScans.iterator(); while(var14.hasNext()) { AnnotationAttributes componentScan = (AnnotationAttributes)var14.next(); //执行扫描 Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); Iterator var8 = scannedBeanDefinitions.iterator(); while(var8.hasNext()) { BeanDefinitionHolder holder = (BeanDefinitionHolder)var8.next(); BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } //检查是否是配置类（有@configuration/@component注解），则递归查找关联类 //关联类包括内部的@bean注解定义的bean或者@import注解引入的类 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { this.parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } //【2】处理@Import注解 //这里的处理是递归的 //SpringBoot项目中经常用的各种@Enable*** 注解基本都是封装的@Import this.processImports(configClass, sourceClass, this.getImports(sourceClass), filter, true); //处理@ImportResource注解 importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); String[] var20 = resources; int var22 = resources.length; for(int var23 = 0; var23 &lt; var22; ++var23) { String resource = var20[var23]; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } //先把@Bean的方法存入beanMethods,后面this.reader.loadBeanDefinitions(configClasses)会继续处理@Bean,那时候才会真正实例化@Bean; Set&lt;MethodMetadata&gt; beanMethods = this.retrieveBeanMethodMetadata(sourceClass); Iterator var18 = beanMethods.iterator(); while(var18.hasNext()) { MethodMetadata methodMetadata = (MethodMetadata)var18.next(); configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces this.processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) { this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } // No superclass -&gt; processing is complete return null;} 介绍上面标记的几个和自动配置相关的注解处理方法 处理@ComponentScan注解相关代码： 123456789101112131415161718192021222324252627//【1】处理@ComponentScan注解Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);//没有@ComponentScan注解注解或条件注解不通过if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { Iterator var14 = componentScans.iterator(); while(var14.hasNext()) { AnnotationAttributes componentScan = (AnnotationAttributes)var14.next(); //执行扫描 Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); Iterator var8 = scannedBeanDefinitions.iterator(); while(var8.hasNext()) { BeanDefinitionHolder holder = (BeanDefinitionHolder)var8.next(); BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } //检查是否是配置类（有@configuration/@component注解），则递归查找关联类 //关联类包括内部的@bean注解定义的bean或者@import注解引入的类 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { this.parse(bdCand.getBeanClassName(), holder.getBeanName()); } } }} 这部分代码会根据@ComponentScan注解扫描对应路径的bean，如果没有设置basePackages属性，那么默认为标记的类的路径，进入 this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());方法 1234567891011121314//解析@ComponentScan方法中主要就是对该注解的各个属性进行处理，最后再根据basePackages进行扫描public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) { //... //如果basePackages属性为空则默认值为对应类的包路径 if (basePackages.isEmpty()) { basePackages.add(ClassUtils.getPackageName(declaringClass)); } //... //根据basePackages扫描类 return scanner.doScan(StringUtils.toStringArray(basePackages));} 因为启动spring boot项目时启动类会进入到该方法，并且启动类中的@ComponentScan注解没有给basePackages属性赋值，所以在扫描时会扫描启动类路径下的包和类，接着进入scanner.doScan(StringUtils.toStringArray(basePackages))方法 12345678910111213141516171819202122232425262728293031323334353637383940//扫描启动类路径下的包和类protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); //用来返回的beanDefinitions集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; //遍历basePackages数组中的各个路径，由于是启动类，basePackages也只有一个元素：com.zcy.springbootmytest for(int var5 = 0; var5 &lt; var4; ++var5) { String basePackage = var3[var5]; //【1.1】从指定路径扫描bean，并加载bean Set&lt;BeanDefinition&gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); //遍历加载到的bean while(var8.hasNext()) { BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); } if (this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); //将bean装载到beanDefinitions中 beanDefinitions.add(definitionHolder); //【1.2】将bean注册到ioc容器中 this.registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions;} 从指定目录扫描bean进入this.findCandidateComponents(basePackage)方法，该方法拼接了一个扫描路径，然后根据扫描路径匹配全部的类，在之后对扫描到的类进行排查，看是否有@Component注解，如果有，则将其封装成BeanDefinition，最终将封装好的BeanDefinition返回，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//这里会调用的是this.scanCandidateComponents(basePackage)方法public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { return this.componentsIndex != null &amp;&amp; this.indexSupportsIncludeFilters() ? this.addCandidateComponentsFromIndex(this.componentsIndex, basePackage) : this.scanCandidateComponents(basePackage);}//进入this.scanCandidateComponents(basePackage)方法private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) { LinkedHashSet candidates = new LinkedHashSet(); try { //拼接路径，结果为：classpath*:com/zcy/springbootmytest/**/*.class String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern; //根据路径扫描匹配所有类 Resource[] resources = this.getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = this.logger.isTraceEnabled(); boolean debugEnabled = this.logger.isDebugEnabled(); Resource[] var7 = resources; int var8 = resources.length; //遍历扫描到的类 for(int var9 = 0; var9 &lt; var8; ++var9) { Resource resource = var7[var9]; if (traceEnabled) { this.logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = this.getMetadataReaderFactory().getMetadataReader(resource); //判断该类是不是 @Component 注解标注的类，并且不是需要排除掉的类 if (this.isCandidateComponent(metadataReader)) { //将该类封装成ScannedGenericBeanDefinition（BeanDefinition接口的实现类）类 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) { if (debugEnabled) { this.logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else if (debugEnabled) { this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } catch (Throwable var13) { throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not readable: &quot; + resource); } } //最终将封装好的BeanDefinition返回 return candidates; } catch (IOException var14) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14); }} 将bean注册到ioc容器中可以看到虽然该方法最终返回了beanDefinitions集合，但其实beanDefinition已经被注入 1234//将bean装载到beanDefinitions中beanDefinitions.add(definitionHolder);//【1.2】将bean注册到ioc容器中this.registerBeanDefinition(definitionHolder, this.registry); 处理@Import注解相关代码： 1234//【2】处理@Import注解//这里的处理是递归的//SpringBoot项目中经常用的各种@Enable*** 注解基本都是封装的@Importthis.processImports(configClass, sourceClass, this.getImports(sourceClass), filter, true); 涉及到的方法有两个 this.getImports方法：获取@import注解集合 processImports方法： 获取@import注解集合首先进入getImports方法中 12345678910111213141516171819202122232425262728private Set&lt;ConfigurationClassParser.SourceClass&gt; getImports(ConfigurationClassParser.SourceClass sourceClass) throws IOException { Set&lt;ConfigurationClassParser.SourceClass&gt; imports = new LinkedHashSet(); Set&lt;ConfigurationClassParser.SourceClass&gt; visited = new LinkedHashSet(); this.collectImports(sourceClass, imports, visited); return imports;}//进入collectImports方法//这个方法是一个递归方法，直到解析到@import注解或者没有注解为止private void collectImports(ConfigurationClassParser.SourceClass sourceClass, Set&lt;ConfigurationClassParser.SourceClass&gt; imports, Set&lt;ConfigurationClassParser.SourceClass&gt; visited) throws IOException { if (visited.add(sourceClass)) { //取出当前注解 Iterator var4 = sourceClass.getAnnotations().iterator(); //遍历当前注解 while(var4.hasNext()) { ConfigurationClassParser.SourceClass annotation = (ConfigurationClassParser.SourceClass)var4.next(); String annName = annotation.getMetadata().getClassName(); //如果当前注解不是@import继续遍历包含的注解，否则直接跳出递归将注解加入到imports中 if (!annName.equals(Import.class.getName())) { this.collectImports(annotation, imports, visited); } } //最终将@import注解返回 imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), &quot;value&quot;)); }} 引入的类加入到对应集合进入processImports方法中，上一个方法已经解析出了该类的注解并传入到了本方法中，本方法先判断解析的注解是否为空，如果为空直接退出，若不为空则对注解进行遍历，启动类上注解引入的两个类分别为AutoConfigurationImportSelector.class和AutoConfigurationPackages.Registrar.class，这两个类分别是ImportSelector和ImportBeanDefinitionRegistrar的子类，本方法会对这两个类分别进行处理，处理的过程就是将这两个类加入到对应的集合中，集合会在注解解析完之后分别进行执行，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) { if (!importCandidates.isEmpty()) { if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) { this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { Iterator var6 = importCandidates.iterator(); while(var6.hasNext()) { //遍历@import注解引入的类 ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next(); Class candidateClass; //这里判断是否引入的是ImportSelector if (candidate.isAssignable(ImportSelector.class)) { //加载引入类 candidateClass = candidate.loadClass(); //判断是否排除 ImportSelector selector = (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter(); if (selectorFilter != null) { exclusionFilter = exclusionFilter.or(selectorFilter); } //如果是DeferredImportSelector则进入 if (selector instanceof DeferredImportSelector) { //这个方法主要是将AutoConfigurationImportSelector加入到了 //deferredImportSelectors中 this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = this.asSourceClasses(importClassNames, exclusionFilter); this.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false); } //这里判断引入的是否是ImportBeanDefinitionRegistrar } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); //加入到importBeanDefinitionRegistrars中 configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { //其他类会进入这里，比如配置引入的类，后面会说明 //加入到configurationClasses中 this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); } } } catch (BeanDefinitionStoreException var17) { throw var17; } catch (Throwable var18) { throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, var18); } finally { this.importStack.pop(); } } }} 到这里注解的解析和启动类所在目录下的类都已经成功引入了，接下来进行的就是对@import引入的两个类进行执行的过程 加载默认配置上面两个步骤都是parse方法内部的parse方法里的，在执行完内部parse会执行 12//【3】加载默认的配置---》（对springboot项目来说这里就是自动装配的入口了）this.deferredImportSelectorHandler.process(); 由于上面两个方法已经将AutoConfigurationImportSelector加入到deferredImportSelectorHandler中，这里会对其进行执行，也就是引入自动配置类集合，进入该方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void process() { //拿到上一步deferredImportSelectors存储的DefererdImportSelectorHolder对象 //其内部封装了AutoConfigurationImportSelector.class类 List&lt;ConfigurationClassParser.DeferredImportSelectorHolder&gt; deferredImports = this.deferredImportSelectors; this.deferredImportSelectors = null; try { if (deferredImports != null) { ConfigurationClassParser.DeferredImportSelectorGroupingHandler handler = ConfigurationClassParser.this.new DeferredImportSelectorGroupingHandler(); deferredImports.sort(ConfigurationClassParser.DEFERRED_IMPORT_COMPARATOR); //先把DefererdImportSelectorHolder对象注册到ioc容器 deferredImports.forEach(handler::register); //自动配置的核心 handler.processGroupImports(); } } finally { this.deferredImportSelectors = new ArrayList(); }}//进入handler.processGroupImports()方法public void processGroupImports() { Iterator var1 = this.groupings.values().iterator(); while(var1.hasNext()) { ConfigurationClassParser.DeferredImportSelectorGrouping grouping = (ConfigurationClassParser.DeferredImportSelectorGrouping)var1.next(); Predicate&lt;String&gt; exclusionFilter = grouping.getCandidateFilter(); //grouping.getImports()方法就是获取自动配置类目录的方法 grouping.getImports().forEach((entry) -&gt; { //获取配置类信息后，使用forEach进行遍历 ConfigurationClass configurationClass = (ConfigurationClass)this.configurationClasses.get(entry.getMetadata()); try { //方法其实已经前面【2.2】用过了 //就是在解析import注解时引入ImportSelector和Register类的那个方法 ConfigurationClassParser.this.processImports(configurationClass, ConfigurationClassParser.this.asSourceClass(configurationClass, exclusionFilter), Collections.singleton(ConfigurationClassParser.this.asSourceClass(entry.getImportClassName(), exclusionFilter)), exclusionFilter, false); } catch (BeanDefinitionStoreException var5) { throw var5; } catch (Throwable var6) { throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configurationClass.getMetadata().getClassName() + &quot;]&quot;, var6); } }); }} grouping.getImports()方法debug结果： 进入grouping.getImports()方法 12345678910public Iterable&lt;Entry&gt; getImports() { Iterator var1 = this.deferredImports.iterator(); while(var1.hasNext()) { ConfigurationClassParser.DeferredImportSelectorHolder deferredImport = (ConfigurationClassParser.DeferredImportSelectorHolder)var1.next(); this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); } return this.group.selectImports();} 这个方法其实就是第二篇中的查看导入的AutoConfigurationImportSelector.class类的入口方法，当时的类调用图如下： 红色框出的就是当前方法所在的位置。到这里就已经和之前第二篇分析的自动配置执行连接起来了，此处不再赘述。 最后在拿到spring.factories文件中的自动配置类后会调用ConfigurationClassParser.this.processImports方法，这个方法在之前解析@import注解时就已经使用过（其实在这部分用的方法大多上面都已经介绍过） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) { if (!importCandidates.isEmpty()) { if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) { this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { Iterator var6 = importCandidates.iterator(); while(var6.hasNext()) { ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next(); Class candidateClass; if (candidate.isAssignable(ImportSelector.class)) { //处理引入的ImportSelector } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { //处理引入的1Registrar } else { //此时会进入这里 //这个方法会将类添加到一个imports集合中 //this.imports.add(importedClass, importingClass); this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); //这个方法主要用来条件评估，然后将符合条件的自动配置类加入到configurationClasses中 //加入该集合的类会在（2）统一引入 this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); } } } catch (BeanDefinitionStoreException var17) { throw var17; } catch (Throwable var18) { throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, var18); } finally { this.importStack.pop(); } } }}///进入this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter)方法protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException { //根据条件注解判断是否需要跳过 if (!this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) { ConfigurationClass existingClass = (ConfigurationClass)this.configurationClasses.get(configClass); //判断配置类是否已经引入 if (existingClass != null) { if (configClass.isImported()) { if (existingClass.isImported()) { existingClass.mergeImportedBy(configClass); } return; } this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); } //获取配置类 ConfigurationClassParser.SourceClass sourceClass = this.asSourceClass(configClass, filter); do { //又是这个方法， //这里主要是因为配置类也会有内部的bean、内部类等需要进行解析 sourceClass = this.doProcessConfigurationClass(configClass, sourceClass, filter); } while(sourceClass != null); //加入到configurationClasses中 this.configurationClasses.put(configClass, configClass); }} 结果就是，被引入的那些类都被加入到了configurationClasses中 loadBeanDefinitions方法上面的一系列过程通过递归等操作，将需要引入的那些类根据不同的类型分别加入到了不同集合中 deferredImportSelectors：ImportSelector类型，例如AutoConfigurationImportSelector类 importBeanDefinitionRegistrars：ImportBeanDefinitionRegistrar类型，例如AutoConfigurationPackages.Registrar类 configurationClasses：其他类型，例如引入的配置类、自己包中定义的类 beanMethods：类中的@bean注解引入的bean 这一部分就是将上面的这些类和相关类注册进ioc容器中，注意本方法的参数在前面通过 1Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet(parser.getConfigurationClasses()); 获取到了，所以configurationModel就是configurationClasses集合的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) { ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator = new ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator(); Iterator var3 = configurationModel.iterator(); //遍历configurationModel while(var3.hasNext()) { ConfigurationClass configClass = (ConfigurationClass)var3.next(); //将集合中的类注册到ioc容器 this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); }}//进入this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator)private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator) { //根据条件注解判断是否需要跳过 if (trackedConditionEvaluator.shouldSkip(configClass)) { //获取beanName String beanName = configClass.getBeanName(); //有beanName而且ioc中不包含 if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) { this.registry.removeBeanDefinition(beanName); } //移除bean this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); } else { //是被引入的，则先将该配置类加入到ioc容器中 if (configClass.isImported()) { //里面应该是覆盖原本的bean this.registerBeanDefinitionForImportedConfigurationClass(configClass); } Iterator var3 = configClass.getBeanMethods().iterator(); while(var3.hasNext()) { BeanMethod beanMethod = (BeanMethod)var3.next(); //【1】注册beanMethods this.loadBeanDefinitionsForBeanMethod(beanMethod); } //【2】注册 this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); //【3】注册Registrar this.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); }} 注册beanMethods1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) { ConfigurationClass configClass = beanMethod.getConfigurationClass(); //获取方法名，bean的name会根据方法名设置 MethodMetadata metadata = beanMethod.getMetadata(); String methodName = metadata.getMethodName(); //根据条件注解判断是否需要跳过 if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) { configClass.skippedBeanMethods.add(methodName); } else if (!configClass.skippedBeanMethods.contains(methodName)) { //还没有注册 //获取注解属性 AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class); Assert.state(bean != null, &quot;No @Bean annotation attributes&quot;); //获取name属性，没有设置则为空集合 List&lt;String&gt; names = new ArrayList(Arrays.asList(bean.getStringArray(&quot;name&quot;))); //如果names不为空则以name作为beanName，否则使用方法名 String beanName = !names.isEmpty() ? (String)names.remove(0) : methodName; Iterator var8 = names.iterator(); //对每个names都作为key进行注册别名 while(var8.hasNext()) { String alias = (String)var8.next(); this.registry.registerAlias(beanName, alias); } //检查名字是否存在，有就报错 if (this.isOverriddenByExistingDefinition(beanMethod, beanName)) { if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) { throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(), beanName, &quot;Bean name derived from @Bean method '&quot; + beanMethod.getMetadata().getMethodName() + &quot;' clashes with bean name for containing configuration class; please make those names unique!&quot;); } } else {//名字没重复 //包装成beanDefinition ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition(configClass, metadata); beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource())); //下面就是为beanDefinition赋一些值，不重要的直接掠过 //... //下面是对注解的解析，判断是否加了对应注解 beanDef.setAutowireMode(3); beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE); AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata); //处理@autowire注解 Autowire autowire = (Autowire)bean.getEnum(&quot;autowire&quot;); if (autowire.isAutowire()) { beanDef.setAutowireMode(autowire.value()); } //处理@autowireCandidate注解 boolean autowireCandidate = bean.getBoolean(&quot;autowireCandidate&quot;); if (!autowireCandidate) { beanDef.setAutowireCandidate(false); } //处理@initMethod注解 String initMethodName = bean.getString(&quot;initMethod&quot;); if (StringUtils.hasText(initMethodName)) { //设置初始化方法 beanDef.setInitMethodName(initMethodName); } //处理@destroyMethod注解 String destroyMethodName = bean.getString(&quot;destroyMethod&quot;); //设置销毁方法 beanDef.setDestroyMethodName(destroyMethodName); //处理@Scope注解（代理模式） ScopedProxyMode proxyMode = ScopedProxyMode.NO; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class); if (attributes != null) { beanDef.setScope(attributes.getString(&quot;value&quot;)); proxyMode = (ScopedProxyMode)attributes.getEnum(&quot;proxyMode&quot;); if (proxyMode == ScopedProxyMode.DEFAULT) { proxyMode = ScopedProxyMode.NO; } } BeanDefinition beanDefToRegister = beanDef; //如果代理模式不是no，则进行相应处理 if (proxyMode != ScopedProxyMode.NO) { BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(new BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS); beanDefToRegister = new ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition((RootBeanDefinition)proxyDef.getBeanDefinition(), configClass, metadata); } if (logger.isTraceEnabled()) { logger.trace(String.format(&quot;Registering bean definition for @Bean method %s.%s()&quot;, configClass.getMetadata().getClassName(), beanName)); } //这个方法就是将bean注册进ioc容器中 this.registry.registerBeanDefinition(beanName, beanDefToRegister); } }} 注册ImportedResources这个方法应该是从配置文件中导入bean，由于项目中都是使用注解导入，这里重要性比较低，所以只做简单介绍，进入this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources())方法 123456789101112131415161718192021222324252627282930313233private void loadBeanDefinitionsFromImportedResources(Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources) { Map&lt;Class&lt;?&gt;, BeanDefinitionReader&gt; readerInstanceCache = new HashMap(); importedResources.forEach((resource, readerClass) -&gt; { //判断文件类型 if (BeanDefinitionReader.class == readerClass) { if (StringUtils.endsWithIgnoreCase(resource, &quot;.groovy&quot;)) { readerClass = GroovyBeanDefinitionReader.class; } else { readerClass = XmlBeanDefinitionReader.class; } } //获取读取器 BeanDefinitionReader reader = (BeanDefinitionReader)readerInstanceCache.get(readerClass); if (reader == null) { try { reader = (BeanDefinitionReader)readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(this.registry); if (reader instanceof AbstractBeanDefinitionReader) { AbstractBeanDefinitionReader abdr = (AbstractBeanDefinitionReader)reader; abdr.setResourceLoader(this.resourceLoader); abdr.setEnvironment(this.environment); } readerInstanceCache.put(readerClass, reader); } catch (Throwable var6) { throw new IllegalStateException(&quot;Could not instantiate BeanDefinitionReader class [&quot; + readerClass.getName() + &quot;]&quot;); } } //读取资源 reader.loadBeanDefinitions(resource); });} 注册Registrar被加入到ImportBeanDefinitionRegistrars集合中的类会在这里被加载，默认调用每个ImportBeanDefinitionRegistrars的registerBeanDefinitions方法，具体实现由其类自己定义，下面只拿注册类上的AutoConfigurationPackages.Registrar举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) { registrars.forEach((registrar, metadata) -&gt; { registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator); });}//这里调用每个registrar的registerBeanDefinitions方法，registerBeanDefinitions由其自己实现//进入registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator)//ImportBeanDefinitionRegistrar类public interface ImportBeanDefinitionRegistrar { //调用了registerBeanDefinitions default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) { this.registerBeanDefinitions(importingClassMetadata, registry); } //进入这里，AutoConfigurationPackages.Registrar.class是他的一个实现类 //所以真正进入的是AutoConfigurationPackages.Registrar.class default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { }}//AutoConfigurationPackages.Registrar.class//由于第二篇已经说过，这里只显示代码，不做过多解释static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { //进入到这个方法 @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { //这个方法是向ioc中注册组件 register(registry, new PackageImport(metadata).getPackageName()); } @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImport(metadata)); }}//接着进入register方法public static void register(BeanDefinitionRegistry registry, String... packageNames) { if (registry.containsBeanDefinition(BEAN)) { BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues(); constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); } else { GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN, beanDefinition); }}","link":"/2020/12/04/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"},{"title":"Spring 数据访问：JDBC","text":"spring 中对 JDBC 进行了封装并提供了数据源和配置方式和数据库访问方法 spring提供了jdbc抽象，它完成了以下部分的工作： 打开连接 准备并运行SQL 循环遍历结果（如果需要） 处理异常 处理事务 关闭连接 开发人员需要做的任务如下： 定义连接参数 指定SQL语句 声明并提供参数 完成迭代工作 相关组件core org.springframework.jdbc.core包：包含JdbcTemplate类及其各种回调接口以及相关类 org.springframework.jdbc.core.simple包：包含SimpleJdbcInsert和 SimpleJdbcCall类 org.springframework.jdbc.core.namedparam包：包含NamedParameterJdbcTemplate 该类和相关的支持类； datasource org.springframework.jdbc.datasource包：包含一个便于 DataSource访问的实用程序类和各种简单的DataSource实现 org.springfamework.jdbc.datasource.embedded包：提供对使用 Java 数据库引擎（如 HSQL、H2 和 Derby）创建嵌入式数据库的支持 object org.springframework.jdbc.object包：包含将 RDBMS 查询、更新和存储过程表示为线程安全、可重用对象的类。依赖于org.springframework.jdbc.core包中的抽象 support org.springframework.jdbc.support包：提供SQLException翻译功能和一些实用程序类 访问数据库方式spring提供了jdbc的四种访问方式 JdbcTemplate：最常用的方式； NamedParameterJdbcTemplate：包装了一个JdbcTemplate，提供命名参数功能，取代了传统的?占位符。提高了可读性； SimpleJdbcInsert 和SimpleJdbcCall：优化数据库元数据以限制必要匹配的数量。只需要提供表或过程的名称，并提供与列名匹配的参数映射 RDBMS（MappingSqlQuery, SqlUpdate, and StoredProcedure）：要求在初始化数据访问层期间创建可重用和线程安全的对象。可以使用execute()、update()、findObject()等方法； JdbcTemplate引入依赖123456789101112&lt;!--jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--根据需求替换数据库引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt; 配置数据源123456789101112131415&lt;!--数据源，由于展示原因，这里不用占位符，实际工作中请将value中的值进行替换--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/springStudy&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;&lt;/bean&gt;&lt;!--模板类--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--引入外部配置，之后可以通古在value属性中使用${}占位符获取外部配置--&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; 操作数据库方法使用JdbcTemplate提供的方法操作数据库需要自己写sql，并使用?作为占位符。需要注意的是JdbcTemplate的方法的结果集不会帮我们进行封装，只有在返回结果是基本类型时才会直接返回对应类型的结果，而当我梦想要获取自定义类型的结果时，无论是单个的还是一个集合的都需要自定义结果映射逻辑： 结果映射：JdbcTemplate的方法很多需要使用结果映射对象作为参数，下面会直接使用这个对象，定义形式如下 123456789//结果映射类，因为jdbc查询结束后会将数据保存在ResultSet中，//如果是单列且基本类型的数据，底层会直接赋值，也就不需要手动映射//但对于自定义的pojo，我们需要手动处理结果映射RowMapper&lt;Animal&gt; animalRowMapper = (resultSet, rowNum)-&gt;{ Animal a = new Animal(); a.setId(resultSet.getInt(&quot;id&quot;)); a.setName(resultSet.getString(&quot;name&quot;)); return a;}; queryForObject()：查询单个数据 1234567//获取单个数据(单列)String queryForCount = &quot;select count(*) from animal&quot;;Integer count = jdbcTemplate.queryForObject(queryForCount, Integer.class);//获取单条数据(多列)String queryForSingle = &quot;select id,name from animal where id=?&quot;;Animal animal = (Animal) jdbcTemplate.queryForObject(queryForSingle,animalRowMapper,124); queryForMap()：获取单个数据，Map中包含的每一列就是一个条目，key为列名，value为值 123String queryForSingle = &quot;select id,name from animal where id=?&quot;;Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(queryForSingle,125);System.out.println(map); //{id=125, name=火神} query()：获取多条数据 123//获取多条数据(query方法)String queryForMultiple = &quot;select * from animal&quot;;List&lt;Animal&gt; animals1 = jdbcTemplate.query(queryForMultiple, animalRowMapper); queryForList()：返回一个list，list中每个元素是一个Map，Map中包含的每一列就是一个条目，key为列名，value为值 1234//获取多条数据(queryForList方法)String queryForMultiple = &quot;select * from animal&quot;;List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(queryForMultiple);System.out.println(maps); //[{id=124, name=火花}, {id=125, name=火神}] update()：用于增删改 1234567891011121314151617@Testpublic void insert(){ String sql = &quot;insert into animal(name) value(?)&quot;; jdbcTemplate.update(sql,&quot;火神&quot;);}@Testpublic void delete(){ String sql = &quot;delete from animal where id=?&quot;; jdbcTemplate.update(sql,123);}@Testpublic void update(){ String sql = &quot;update animal set name=? where name=?&quot;; jdbcTemplate.update(sql,&quot;火花&quot;,&quot;火神&quot;);} execute()：执行任意sql，通常用于ddl语句 12String sql = &quot;create table test (id integer, name varchar(100))&quot;;jdbcTemplate.execute(sql); NamedParameterJdbcTemplateNamedParameterJdbcTemplate只是在JdbcTemplate基础上添加了参数解析的支持，可以使用命名参数替换?占位符。具体方法介绍查看上一小节的JdbcTemplate，这里只介绍他们的区别，也就是参数部填充分 对于sql字符串中的参数，可以使用:name的形式定义参数； 可以使用SqlParameterSource的实现对参数进行填充，它的实现有 MapSqlParameterSource：和Map类似通过K/V方式设置参数 BeanPropertySqlParameterSource：直接传递一个自定义类对象，会根据器属性进行参数设置 可以使用Map进行属性填充 123456789101112131415161718192021222324//结果映射RowMapper&lt;Animal&gt; animalRowMapper = (resultSet, rowNum)-&gt;{ Animal a = new Animal(); a.setId(resultSet.getInt(&quot;id&quot;)); a.setName(resultSet.getString(&quot;name&quot;)); return a;};String sql = &quot;select * from animal where id=:id and name=:name&quot;;//参数填充(方式一)MapSqlParameterSource ParameterSource1 = new MapSqlParameterSource();ParameterSource1.addValue(&quot;id&quot;,124);ParameterSource1.addValue(&quot;name&quot;,&quot;火花&quot;);//参数填充(方式二)BeanPropertySqlParameterSource parameterSource2 = new BeanPropertySqlParameterSource(new Animal(10, &quot;水蓝蓝&quot;));//参数填充(方式三)Map&lt;String, Object&gt; parameterSource3 = new HashMap&lt;&gt;();parameterSource3.put(&quot;id&quot;,124);parameterSource3.put(&quot;name&quot;,&quot;火花&quot;);List&lt;Animal&gt; animalList = nPJdbcTemplate.query(sql, parameterSource2, animalRowMapper); SQLExceptionTranslatorSQLExceptionTranslator是一个异常转换接口 12345@FunctionalInterfacepublic interface SQLExceptionTranslator { @Nullable DataAccessException translate(String task, @Nullable String sql, SQLException ex);} 它负责的是将SQLExceptions与spring自己定义的DataAccessException 之间进行转换。默认实现是SQLErrorCodeSQLExceptionTranslator todo(不明白这东西有什么用) 数据库连接","link":"/2021/03/06/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%9AJDBC/"},{"title":"Spring 数据访问：事务管理","text":"事务是为了保证业务逻辑前后数据的一致性而提供的功能，可以分为全局事务和本地事务 全局事务：全局事务跨越多个资源（比如数据库和消息队列），常见的有分布式事务 本地事务：本地事务是特定于资源的（比如JDBC连接关联的事务），在编码过程中更长被使用 底层组件TransactionManager事务策略由TransactionManager定义，它是一个空实现 12public interface TransactionManager {} 他的实现如下： PlatformTransactionManager ReactiveTransactionManager 在应用程序中应该需要根据工作环境选择正确的TransactionManager实现（JDBC、JTA、Hibernate 等），然后注册到ioc容器中，例如JDBC环境下： 1234567&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&quot;&gt; &lt;!--...--&gt;&lt;/bean&gt; PlatformTransactionManagerPlatformTransactionManager接口用于命令式事务管理 1234567891011public interface PlatformTransactionManager extends TransactionManager { //如果当前调用堆栈中存在匹配的事务， //则返回的 TransactionStatus 可能表示新事务或可以表示现有事务。 TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; //提交事务 void commit(TransactionStatus status) throws TransactionException; //回滚事务 void rollback(TransactionStatus status) throws TransactionException;} ReactiveTransactionManagerReactiveTransactionManager接口用于反应式事务管理 12345678910public interface ReactiveTransactionManager extends TransactionManager { //获取响应式事务 Mono&lt;ReactiveTransaction&gt; getReactiveTransaction(@Nullable TransactionDefinition definition) throws TransactionException; //提交事务 Mono&lt;Void&gt; commit(ReactiveTransaction transaction) throws TransactionException; //回滚事务 Mono&lt;Void&gt; rollback(ReactiveTransaction transaction) throws TransactionException;} TransactionStatus12345678910111213141516171819202122232425public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable { boolean hasSavepoint(); void flush();}//public interface TransactionExecution { boolean isNewTransaction(); void setRollbackOnly(); boolean isRollbackOnly(); boolean isCompleted();}//public interface SavepointManager { Object createSavepoint() throws TransactionException; void rollbackToSavepoint(Object savepoint) throws TransactionException; void releaseSavepoint(Object savepoint) throws TransactionException;} TransactionStatus接口提供了简单的控制事务执行和状态查询方式 TransactionDefinition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface TransactionDefinition { //传播行为 int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; //隔离级别 int ISOLATION_DEFAULT = -1; int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; int TIMEOUT_DEFAULT = -1; //获取传播行为 default int getPropagationBehavior() { return 0; } //获取事务隔离级别 default int getIsolationLevel() { return -1; } //获取超时时间：此事务在超时并被回滚之前运行了多久时间 default int getTimeout() { return -1; } //是否是只读事务 //在不修改数据，只读取数据的情况下可以使用read-only事务 default boolean isReadOnly() { return false; } //获取事务名 @Nullable default String getName() { return null; } static TransactionDefinition withDefaults() { return StaticTransactionDefinition.INSTANCE; }} 工具类spring为各种提供了工具类，他们处于较低级别 JDBC：DataSourceUtils JPA：EntityManagerFactoryUtils Hibernate：SessionFactoryUtils 在获取连接时会返回现有连接，如果没有，则会创建新连接 1Connection conn = DataSourceUtils.getConnection(dataSource); TransactionInterceptorspring支持的事务是通过aop代理实现的，它的通知是通过xml或注解进行配置元数据进行驱动。底层使用TransactionInterceptor与TransactionManager结合实现环绕方法的事务调用。 TransactionAwareDataSourceProxyTransactionAwareDataSourceProxy类是最底层的类，它是包装DataSource的代理类，增加了对spring管理事务的功能 基于xml配置事务spring的声明式事务管理是通过AOP实现的，可以通过xml文件进行配置，配置流程如下 引入依赖123456789101112&lt;!--事务依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt; xml配置必须在&lt;beans&gt;根标签添加如下配置 1234xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot; 主要使用的是&lt;tx:method&gt;标签，其属性对应TransactionDefinition的方法，具体如下： name：匹配方法名，可以使用*作为占位符，表示0个或多个字符，一个方法可以被多个&lt;tx:method&gt;标签的name属性匹配时选择。name是必须配置的； read-only：代表事务是只读的，默认是false表示使用默认事务； rollback-for：spring事务回滚的推荐方式是抛出异常，spring会在调用栈中捕获未处理的异常，然后决定是否将事务标记为回滚。默认情况下如果抛出RuntimeException异常（或发生Error）就会标记回滚，也可以通过rollback-for属性指定检测到什么异常会将事务标记为回滚。也可以使用java代码方式进行回滚，不过存在耦合官方并不推荐； 1TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); no-rollback-for：不回滚规则。指定某些异常及其子类即便抛出，事务也不会标记回滚。当no-rollback-for和rollback-for同时存在时，更具体的异常更优先。测试时发现当rollback-for为Exception时，no-rollback-for配置不生效； timeout：事务超时时间，仅适用于事务传播行为为REQUIRED或REQUIRES_NEW； isolation：事务隔离级别，默认为DEFAULT，仅适用于事务传播行为为REQUIRED或REQUIRES_NEW； propagation：事务传播行为，默认为REQUIRED 全部配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation= &quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--包扫描器--&gt; &lt;context:component-scan base-package=&quot;项目包路径&quot;/&gt; &lt;!--声明事务的通知--&gt; &lt;tx:advice id=&quot;事务通知id&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;!--配置需要添加事务的方法--&gt; &lt;tx:attributes&gt; &lt;!--使用tx:method标签配置方法的匹配名称和事务类型--&gt; &lt;tx:method name=&quot;名称匹配表达式&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;!--切入点，需要添加事务的类--&gt; &lt;aop:pointcut id=&quot;切入点id&quot; expression=&quot;切入点表达式&quot;/&gt; &lt;!--将通知加入到需要添加事务的方法上--&gt; &lt;aop:advisor advice-ref=&quot;事务通知id&quot; pointcut-ref=&quot;切入点id&quot;/&gt; &lt;/aop:config&gt; &lt;!--数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;!--事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 示例代码实体类 12345678@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Animal { private int id; private String name;} Service层事务测试代码 123456789101112131415161718192021222324252627282930313233343536373839public interface IAnimalService { public int insert(String name) throws Exception; public int delete(int id); public int update(int id,String newName); public String queryNameById(int id);}@Servicepublic class AnimalService implements IAnimalService { @Autowired public JdbcTemplate jdbcTemplate; @Override public int insert(String name) throws Exception { int res = jdbcTemplate.update(&quot;insert into animal(name) value(?)&quot;, name); //一定会抛出异常 if(name.length()&gt;=0){ throw new RuntimeException(&quot;配置不会回滚&quot;);// throw new Exception(&quot;配置会回滚&quot;); } return res; } @Override public int delete(int id) { return jdbcTemplate.update(&quot;delete from animal where id=?&quot;,id); } @Override public int update(int id, String newName) { jdbcTemplate.update(&quot;update animal set name=? where id=?&quot;,newName,id); return 0; } @Override public String queryNameById(int id) { return jdbcTemplate.queryForObject(&quot;select name from animal where id=?&quot;, String.class, id); }} 配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;context:component-scan base-package=&quot;springStudy&quot;/&gt;&lt;!--事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;!--配置事务方法--&gt; &lt;tx:attributes&gt; &lt;!--query开头方法都是制度的--&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;!--除了RuntimeException及其子类，其他异常或错误都会回滚--&gt; &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Throwable&quot; no-rollback-for=&quot;RuntimeException&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置切面--&gt;&lt;aop:config&gt; &lt;!--切入点，需要添加事务的类--&gt; &lt;aop:pointcut id=&quot;animalServicePointCut&quot; expression=&quot;execution(* springStudy.service.AnimalService.*(..))&quot;/&gt; &lt;!--将通知加入到需要添加事务的方法上--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;animalServicePointCut&quot;/&gt; &lt;!--根据需要定义多个切入点和通知...--&gt; &lt;!--在这里声明其他aop切面--&gt; &lt;aop:aspect id=&quot;...&quot; ref=&quot;...&quot;&gt; &lt;aop:pointcut id=&quot;...&quot; expression=&quot;...&quot;/&gt; &lt;aop:around method=&quot;...&quot; pointcut-ref=&quot;...&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!--数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!--事务管理器--&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--jdbc模板--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 基于注解配置事务引入依赖123456789101112&lt;!--事务依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt; 开启注解支持xml形式 12&lt;!--如果TransactionManager名称为transactionManager，可以省略transaction-manage属性--&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; 注解形式 123@Configuration@EnableTransactionManagementpublic class AppConfig {} @Transactional 使用使用范围spring官方建议用于注释类或类方法，但也可以用于注释接口和接口方法，如果采用了多种方式配置事务，派生类层次越多优先级越高，同一类中方法级别优先于类级别。想要使用接口或接口方法必须将proxyTargetClass设置为false或默认： 接口：表示为接口实现类声明默认事务。基于接口的事务代理方法必须始终是在接口中定义的public方法 接口方法： 类：表示为类及其子类的所有方法都声明事务； 类方法：声明方法使用事务。应该用于public方法上，否则会失效。可以通过注册自定义的transactionAttributeSource的方式使包可见（default）方法具有事务，代码如下： 1234@BeanTransactionAttributeSource transactionAttributeSource() { return new AnnotationTransactionAttributeSource(false);} 注解属性@Transactional属性如下： mode：其值内容如下： proxy（默认）：代表使用spring的aop处理被注解的bean，； AspectJ：将受影响的类与spring的AspectJ事务切面编织在一起，修改目标字节码以应用于任何类型的方法调用。需要用到spring-aspects.jar； proxyTargetClass：表示注释的类创建什么类型的事务代理，其值内容如下： true：创建基于类的代理； false（默认）：创建基于标准JDK接口的代理； order：定义事务应用于注释了@Transactional的bean的通知的顺序。不指定默认由aop子系统指定通知的顺序； timeout：事务超时时间，默认-1； readOnly：声明只读事务，默认false； rollbackFor：触发回滚异常，默认RuntimeException； rollbackForClassName：传递字符串，功能同上； noRollbackFor：声明不回滚异常； noRollbackForClassName：传递字符串，功能同上； isolation：事务隔离级别，默认为Isolation.ISOLATION_DEFAULT； propagation：事务传播行为，默认为Propagation.PROPAGATION_REQUIRED； value：声明多个事务管理器时可通过value值设置beanName； 事务名称当前还无法自定义事务的名称（事务监听器和日志输出的事务名称），对于声明式事务，事务名称为全类名.声明事务方法名 组合注释如果在很多地方的@Transactional配置一样，自己也不想每次都要写一遍，那么就可以自定义一个注解，将@Transactional封装一下 12345@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Transactional(transactionManager = &quot;txManager&quot;,readOnly = true,rollbackFor = Throwable.class)public @interface MyTransactional {} 示例代码实体类 12345678@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Animal { private int id; private String name;} Service层事务测试代码 12345678910111213141516171819202122232425public interface IAnimalService { public int insert(String name) throws Exception;}@Service//为类内所有方法声明默认事务@Transactionalpublic class AnimalService implements IAnimalService { @Autowired public JdbcTemplate jdbcTemplate; @Override public int insert(String name) throws Exception { int res = jdbcTemplate.update(&quot;insert into animal(name) value(?)&quot;, name); //一定会抛出异常 if(name.length()&gt;=0){ //默认会回滚 throw new RuntimeException(&quot;1&quot;); //默认不会回滚 throw new Exception(&quot;aaa&quot;); } return res; }} 事务传播行为一般来说事务范围内的所有代码都在该事务中运行，事务传播行为表示在事务上下文已存在运行时事务的情况下在开启事务时的行为。一共七种，如下表： 事务传播行为 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。","link":"/2021/03/20/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"title":"Spring 核心功能：Spring 表达式语言（SpEL）","text":"SpEL是Spring 表达式语言的缩写，但它不直接与 Spring 绑定，可以独立使用 相关组件表达式解析器spring提供了pelExpressionParser类作为表达式解析器，用来解析SpEL表达式，解析SpEL使用以下方法 parseExpression(String expressionString) parseExpression(String expressionString, ParserContext context) 12ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(&quot;'Hello'.concat('!')&quot;); ParserContext上面解析方法参数中ParserContext是提供给表达式分析器的输入 123456789101112131415161718192021222324public interface ParserContext { // 是否是模版表达式 boolean isTemplate(); // 模版的前缀、后缀 String getExpressionPrefix(); String getExpressionSuffix(); // 表达式模板形式，默认为#{},自己可以改变 ParserContext TEMPLATE_EXPRESSION = new ParserContext() { @Override public boolean isTemplate() { return true; } @Override public String getExpressionPrefix() { return &quot;#{&quot;; } @Override public String getExpressionSuffix() { return &quot;}&quot;; } };} TemplateParserContext 是其默认实现 1234567891011121314151617181920public class TemplateParserContext implements ParserContext { private final String expressionPrefix; private final String expressionSuffix; // 默认就是它了~~~ public TemplateParserContext() { this(&quot;#{&quot;, &quot;}&quot;); } @Override public final boolean isTemplate() { return true; } @Override public final String getExpressionPrefix() { return this.expressionPrefix; } @Override public final String getExpressionSuffix() { return this.expressionSuffix; }} 解析器解析器的继承结果如下 ![image-20220119164942892](../../../../images/Spring核心功能：Spring 表达式语言（SpEL）/image-20220119164942892.png) TemplateAwareExpressionParser是一个支持解析模版Template（1.1.1 中的TemplateParserContext）的解析器，它的子类实现有： InternalSpelExpressionParser： SpelExpressionParser： 他们都有各自的doParseExpression()方法实现 表达式对象使用parser.parseExpression()方法解析表达式后会返回一个Expression类型对象，它是一个接口，有三个实现类，其中SpEL表达式类为SpelExpression。它提供方法如下 getValue()： setValue()： isWritable()： getValueType()： 表达式上下文对象EvaluationContext接口代表戒子表达式是使用的上下文对象。在解析解析属性、方法或字段并帮助执行类型转换时使用该接口。Spring 提供了两种实现 SimpleEvaluationContext：公开仅支持部分的SpEL的支持。它有意限制的表达式类别。旨在仅支持SpEL语言语法的一个子集，它不包括 Java类型引用，构造函数和bean引用等等。它还要求明确选择对表达式中属性和方法的支持级别。 StandardEvaluationContext：公开支持全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。 1234567891011121314151617181920//解析器SpelExpressionParser parser = new SpelExpressionParser();//表达式上下文StandardEvaluationContext context = new StandardEvaluationContext();//向上下文中添加变量context.setVariable(&quot;key&quot;,&quot;value&quot;);//从上下文中获取变量Object value = parser.parseExpression(&quot;#key&quot;).getValue(context);System.out.println(value); //valuePerson person = new Person();person.setName(&quot;张三&quot;);//表达式上下文StandardEvaluationContext context2 = new StandardEvaluationContext();//将person设置为rootcontext2.setRootObject(person);//root不需要#就能取出属性Object name = parser.parseExpression(&quot;name&quot;).getValue(context2);System.out.println(name); //张三 作用位置xml配置可以通过SpEL设置bean的属性或构造函数的Value值 123&lt;bean id=&quot;user&quot; class=&quot;cn.spy.spel.method.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&quot;ZhangSan&quot;.toLowerCase()}&quot;/&gt;&lt;/bean&gt; 注解配置可以在@Value注解中使用SpEL 1234public class Person { @Value(&quot;#{(test.name).toLowerCase()}&quot;) private String name;} SpEL用法获取解析器与表达式上下文，接下来代码省略这部分。 1234//解析器SpelExpressionParser parser = new SpelExpressionParser();//表达式上下文StandardEvaluationContext context = new StandardEvaluationContext(); 另外省略对结果的强制转换 123Object name = (String)parser.parseExpression(&quot;#list[0]&quot;).getValue(context);//写为parser.parseExpression(&quot;[0]&quot;).getValue(context); 文本表达可以直接在声明数值、boolean、字符串和null，字符串需要放在单引号中，数字支持使用负号，指数表示，小数点和多种进制的方式表示 12int v = (Integer) parser.parseExpression(&quot;0x7FFFFFFF&quot;).getValue();int v = (String) parser.parseExpression(&quot;'0x7FFFFFFF'&quot;).getValue(); 变量和函数变量引用变量可以通过#引用表达式上下文中的变量，对于root对象属性不需要写#，具体示例查看属性和方法 #this 和 #root 变量#this变量引用当前的评估对象 1234int[] arr = {1,3,5,7,9};context.setVariable(&quot;arr&quot;,arr);//下面表达式得到的是[7,9]parser.parseExpression(&quot;#arr.?[#this&gt;5]&quot;).getValue(context); #root变量引用根上下文对象，如果没有设置root上下文对象，则为null； 123context.setRootObject(person);//得到的是person对象Object name = parser.parseExpression(&quot;#root&quot;).getValue(context); 函数可以在表达式上下文对象中注册自定义的函数来扩展SpEl，使用时通过#方法名调用即可 123Method method = ...;EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();context.setVariable(&quot;myFunction&quot;, method); 属性和方法如果在root下获取属性或方法直接调用属性或方法名即可，不需要加#，如果获取表达式上下文中变量的属性需要使用#和. 1234567891011121314151617//创建对象，设置属性Person person = new Person();person.setName(&quot;张三&quot;);//设置上下文变量context.setVariable(&quot;person&quot;,person);//获取变量属性parser.parseExpression(&quot;#person.name&quot;).getValue(context);//调用变量方法parser.parseExpression(&quot;#person.name&quot;).getValue(context);//设置root对象context.setRootObject(person);//获取root对象属性parser.parseExpression(&quot;name&quot;).getValue(context);//调用root对象方法parser.parseExpression(&quot;toString()&quot;).getValue(context2); 集合和Map数组数组访问12345678910111213141516//创建数组String[] arr = new String[]{&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;};//设置数组变量到表达式上下文context.setVariable(&quot;arr&quot;,arr);//使用[]获取元素parser.parseExpression(&quot;#arr[0]&quot;).getValue(context);//使用方法Object value = parser.parseExpression(&quot;#arr.toString()&quot;).getValue(context);//数组设置为root对象context.setRootObject(arr);//索引元素parser.parseExpression(&quot;[0]&quot;).getValue(context);//调用方法parser.parseExpression(&quot;toString()&quot;).getValue(context); 数组构造1234567int[] arr1 = (int[]) parser.parseExpression(&quot;new int[4]&quot;).getValue(context);//声明并初始化int[] arr2 = (int[]) parser.parseExpression(&quot;new int[]{1,2,3}&quot;).getValue(context);//多维数组int[][] arr3 = (int[][]) parser.parseExpression(&quot;new int[4][5]&quot;).getValue(context); 列表列表访问列表在表达式追踪可以通过[]访问 1234567891011121314151617//声明列表LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();list.add(&quot;ddd&quot;);list.add(&quot;eee&quot;);list.add(&quot;fff&quot;);//设置list变量context.setVariable(&quot;list&quot;,list);//可以通过[]获取值，也可以通过[]获取值在表达式中使用其各种方法parser.parseExpression(&quot;#list.get(1)&quot;).getValue(context);parser.parseExpression(&quot;#list[0]&quot;).getValue(context);//设置为root对象context.setRootObject(list);//访问时和访问变量类似，只不过去掉变量名即可parser.parseExpression(&quot;get(1)&quot;).getValue(context)parser.parseExpression(&quot;[0]&quot;).getValue(context) 内联列表可以在表达式在直接使用{}声明列表 123List numbers = (List) parser.parseExpression(&quot;{1,2,3,4}&quot;).getValue(context);List listOfLists = (List) parser.parseExpression(&quot;{{'a','b'},{'x',1}}&quot;).getValue(context); MapMap索引在表达式中可以通过[key]的方式获取value，其中key的单引号是可选的。另外还可以调用map的方法，此处不演示 1234567891011121314//创建mapHashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;name&quot;,&quot;魔力猫&quot;);map.put(&quot;age&quot;,3);//设置map为表达式上下文变量context.setVariable(&quot;map&quot;,map);//访问key为name的值Object value = parser.parseExpression(&quot;#map[name]&quot;).getValue(context);//设置为root对象context.setRootObject(map);//访问key为name的值parser.parseExpression(&quot;[0]&quot;).getValue(context); 内联Map在表达式中可以直接使用{key:value}表示一个Map,其中key的单引号是可选的 1Map map = (Map) parser.parseExpression(&quot;{name:'魔力猫',age:3}&quot;).getValue(context); 集合选择使用.?[selectionExpression]语法可以对集合进行过滤，返回包含原始元素子集的新集合，评估Map时可以访问Key和Value属性 1Map newMap = parser.parseExpression(&quot;map.?[value&lt;27]&quot;).getValue(); 只获取与选择匹配的第一个元素，语法为：.^[selectionExpression] 只获得最后一个匹配的选择，语法是 .$[selectionExpression] 集合投影使用.![projectionExpression]语法可以对集合进行投影操作，返回一个新集合 1List names = (List)parser.parseExpression(&quot;persons.![name]&quot;); 运算符SpEL内允许使用以下类型运算符： 关系运算符： 标准关系运算符：&gt;(gt)、&gt;=(ge)、==(eq)、!=(ne)、&lt;=(le)、&lt;(lt)； 额外支持：instanceof； 正则表达式运算符：matches； 逻辑运算符：&amp;&amp;(and)、||(or)、!(not)； 数学运算符：+、-、*、/(div)、%(mod)、^； 赋值运算符：=； 三元运算符：布尔表达式?Exp1:Exp2； 1name != null ? name : &quot;张三&quot; Elvis运算符：变量?:exp。变量为空则将:后的值赋给该变量； 1name?:'张三' 空安全运算符：使用?声明变量，执行变量时不会抛出异常，而是返回null 1isNull?.toString() 类型使用T来指定java.lang.Class类型实例 1Class stringClass = parser.parseExpression(&quot;T(String)&quot;).getValue(Class.class); 创建对象可以使用new关键字调用构造函数，除了位于java.lang包中的类型之外，都需要使用类型的全类名 1Person person = (Person) parser.parseExpression(&quot;new test.anno.Person()&quot;).getValue(context); Bean引用如果表达式上下文配置了bean解析器 123ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.setBeanResolver(new MyBeanResolver()); 可以使用@符号从表达式中查找bean 1Object bean = parser.parseExpression(&quot;@beanName&quot;).getValue(context); 如果想要访问beanFactory本身，可以在bean名称前加上一个&amp;符号 1Object bean = parser.parseExpression(&quot;&amp;beanName&quot;).getValue(context); 表达式模板表达式模板允许将文本与多个评估块混合，使用#{}分隔 1234String randomPhrase = parser.parseExpression( &quot;随机数为#{T(java.lang.Math).random()}&quot;, new TemplateParserContext()).getValue(String.class); 关于TemplateParserContext()请查看解析器","link":"/2020/03/28/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9ASpring%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%EF%BC%88SpEL%EF%BC%89/"},{"title":"Spring 核心功能：控制反转（IOC）","text":"控制反转（IOC）也被称为依赖注入（DI）。这是一个由对象通过构造函数的参数、工厂方法的参数或者配置来定义依赖性，然后会在创建 bean 时注入这些依赖项的过程。而原本的 bean 如果想要获取依赖项，需要通过构造函数或者单例模式、构造器模式等方式获取依赖项的实例，所以可以发现Spring的依赖注入其实是原本bean 获取以来的逆过程，所以得名：控制反转。 BeanDefinition在Spring中，构成应用程序主干并由Spring IOC管理的对象称为bean，它由IOC容器实例化、组装和管理。可以通过配置元数据对bean之间的依赖关系进行配置。bean以beanDefinition形式存在于IOC容器中。 BeanDefinition 是一个接口，包含了很多配置信息 bean 的实际限定类名 bean 行为配置元素，说明 bean 在容器中的行为方式（范围、声明周期回调等） 对其他依赖的 bean 的引用 在新创建的对象中设置的其他配置设置——例如，池的大小限制或在管理连接池的 bean 中使用的连接数 bean 属性AbstractBeanDefinition是beanDefinition的子类，其中定义了一组属性： scope：bean的作用范围 lazyInit：是否延迟加载，对应bean的lazy-init autowireMode：自动注入模式 AUTOWIRE_NO = 0; AUTOWIRE_BY_NAME = 1; AUTOWIRE_BY_TYPE = 2; AUTOWIRE_CONSTRUCTOR = 3; dependencyCheck：依赖检查 dependsOn：依赖项数组，对应bean属性depend-on autowireCandidate：装配该bean时是否对把其他bean注入进来 primary：有多个备案候选项时作为首选者，对应bean属性primary lenientConstructorResolution：是否一个宽松的模式解析构造函数 nonPublicAccessAllowed：允许访问非公开的构造器和方法，程序设置 qualifiers：用于记录Qualifier，对应子元素qualifier constructorArgumentValues：构造函数注入属性，对应bean属性constructor-arg propertyValues：普通属性集合 factoryBeanName：对应bean属性factory-bean factoryMethodName：对应bean属性factory-method initMethodName：对应bean属性init-method destroyMethodName：对应bean属性destroy-method synthetic：创建AOP或不是用户定义时为true role：bean的角色 ROLE_APPLICATION = 0 :用户 ROLE_SUPPORT = 1：某些复杂配置一部分 ROLE_INFRASTRUCTURE = 2：完全内部使用，与用户无 description：bean描述 resource：bean定义的资源 bean 实例化BeanDefinition本质上时创建一个或多个对象的方法。在bean被访问时，容器会查看该bean，如果当前容器中没有，则会使用BeanDefinition创建对应的bean对象并加入到容器中 嵌套类名如果在OutClass在com.example包中，并且OutClass类中有一个静态内部类 InnerClass，则他们之间可以使用美元符号（$）或点（.）分隔，比如 com.example.SomeThing$InnerClass或com.example.SomeThing.InnerClass。 构造函数实例化点击查看示例 静态工厂方法实例化定义使用静态工厂方法创建的 bean 时，使用class 属性指定包含static工厂方法的类和命名属性以factory-method指定工厂方法本身的名称 12345&lt;bean id=&quot;clientService&quot; &lt;!--工厂类 --&gt; class=&quot;examples.ClientService&quot; &lt;!--工厂类中创建bean的静态方法 --&gt; factory-method=&quot;createInstance&quot;/&gt; 实例工厂方法初始化实力工厂方法从容器中调用现有的bean的非静态方法创建bean。使用此方式需要将**class属性留空**，使用factory-bean属性中指定当前（或父或祖先）容器中 bean 的名称，使用factory-method属性设置工厂方法本身的名称 123456789&lt;!-- 工厂的bean，其中包含createInstance()方法 --&gt;&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- 通过上面的工厂bean创建bean --&gt;&lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt; BeanDefinition继承BeanDefinition包含很多配置信息，包括构造其参数，属性值、初始化方法等。BeanDefinition之间可以存在继承关系，一个子BeanDefinition能够根据需要覆盖或增加一些值。使用BeanDefinition继承可以节省定义bean的工作量，相当于一种模板。可以通过parent属性来指定父子关系： 1234567891011@Datapublic class ParentBean { private String name; private Integer age;}@Datapublic class ChildBean { private String name; private Integer age;} xml配置如下 123456789&lt;bean name=&quot;parentBean&quot; class=&quot;test.pojo.ParentBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;6&quot;/&gt;&lt;/bean&gt;&lt;bean name=&quot;childBean&quot; class=&quot;test.pojo.ChildBean&quot; parent=&quot;parentBean&quot;&gt; &lt;!--覆盖父beanDefinition属性--&gt; &lt;property name=&quot;age&quot; value=&quot;1000&quot;/&gt;&lt;/bean&gt; 其中还可以继承或覆盖构造函数参数、属性、方法、初始化/销毁方法、静态工厂设置等信息，但也有一些配置始终是子类配置： depends on autowire mode dependency check singleton lazy init 父BeanDefinition也可以不指定类，只需要将abstract属性设置为true 1234&lt;bean name=&quot;parentBean&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;6&quot;/&gt;&lt;/bean&gt; 此时父bean不能实例化也不能用于ref，只能当作模板来使用 BeanFactory 接口beanFactory 接口提供了spring ioc基本功能的规范，也是访问ioc容器的根接口 ApplicationContext 接口ApplicationContext是beanFactory 的一个扩展，它在其基础上添加了更多企业特定的功能，是beanFactory的超集。它补充了如下内容： 更容易与Spring AOP集成 消息资源处理（用于国际化） 活动发布 应用特定上下文，注解、配置文件等 ApplicationContext 接口代表IOC容器。通过读取配置元数据执行bean的实例化、组装和管理。ApplicationContext提供了几种实现，类图如下： 容器实例化ApplicationContext的不同实现类用于读取不同的配置元数据： 读取xml文件 FileSystemXmlApplicationContext ClassPathXmlApplicationContext GenericXmlApplicationContext 读取Groovy配置 GenericGroovyApplicationContext StaticApplicationContext 基于Java配置类 AnnotationConfigApplicationContext 结合读者委托 GenericApplicationContext 基于xml 配置12345public static void main(String[] args) { //提供给 ApplicationContext 构造函数的一个或多个字符串形式的位置路径 ClassPathXmlApplicationContext application = new ClassPathXmlApplicationContext(&quot;service.xml&quot;, &quot;daos.xml&quot;);} 基于Groovy 配置一般用法 123public static void main(String[] args) { ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);} 使用读者委托 123456789public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); new GroovyBeanDefinitionReader(context) .loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;); context.refresh();} 基于Java 注解配置方式一：通过指定配置类或组件类，读取其上声明的组件扫描器，进而读取包内的bean 1234567891011//启动器代码public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfig.class); Person person = ctx.getBean(&quot;person&quot;, Person.class); System.out.println(person);}//组件扫描@ComponentScan(&quot;test&quot;)public class MyConfig {} 方式二：通过register方法进行注入 1234567public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.register(AppConfig.class, OtherConfig.class); ctx.register(AdditionalConfig.class); ctx.refresh(); MyService myService = ctx.getBean(MyService.class);} AnnotationConfigApplicationContext是spring 3.0引入的。种通用ApplicationContext的实现不仅能够接受 @Configuration类作为输入，还能够接受普通@Component类和使用 JSR-330 元数据注释的类 当@Configuration类作为输入提供时，@Configuration类本身被注册为 beanDefinition，并且@Bean类中所有声明的方法也被注册为beanDefinition； 当@Component提供 JSR-330 类时，它们被注册为beanDefinition，并且根据提供的@Autowired或@Inject进行依赖注入； 基于Reader委托不同Reader负责读取不同来源的信息： AnnotatedBeanDefinitionReader XmlBeanDefinitionReader GroovyBeanDefinitionReader PropertiesBeanDefinitionReader（已过时） GenericApplicationContext可以结合不同Reader来读取对应的配置文件 123456789public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); //用对应的Reader包装上下文对象 new XmlBeanDefinitionReader(context) //加载对应bean配置 .loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;); //最后需要刷新上下文 context.refresh();} 附加功能开头介绍了位于org.springframework.context包内的 ApplicationContext 类提供了几个附加功能，下面逐个介绍 国际化ApplicationContext扩展了一个MessageSource接口，这个接口提供了国际化功能。该接口介绍如下： 123456789101112public interface MessageSource { //用于从MessageSource找到指定语言环境的消息，如果未找到，使用默认消息 @Nullable String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale); //与上一个方法基本相同，只不过这个不能指定默认消息，找不到消息直接报错 String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException; //上述方法中使用的所有属性都包装在一个名为MessageSourceResolvable中 String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;} spring在加载ApplicationContext时会自动搜索类型和名称为MessageSource的bean，如果找到了，就将所有信息的调用委托给这个信息源。如果没有找到，则从父容器查找同名bean，如果还没找到，则实例化一个空的DelegatingMessageSource用来接受上述的方法调用。 spring提供了三个MessageSource的实现：ResourceBundleMessageSource、ReloadableResourceBundleMessageSource和StaticMessageSource，他们都实现了 HierarchicalMessageSource接口，用来嵌套消息。其中StaticMessageSource很少使用，示例如下 ResourceBundleMessageSource： 1234567891011&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;format&lt;/value&gt; &lt;value&gt;exception&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--设置字符集，解决中文乱码--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;&lt;/bean&gt; 上面示例配置了两个资源文件 12345#format.properties name=马冬梅#exceptions.propertiename=马什么梅 获取消息 12345public static void main(String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(&quot;test.xml&quot;); String message = resources.getMessage(&quot;name&quot;, null, &quot;Default&quot;, Locale.CHINA); System.out.println(message);} 如果正常情况会输出”马冬梅”。程序会顺序查找定义的basenames列表中配置的配置文件。对于每个配置文件都可以设置不同的语言环境，只需要在properties文件名后加上语言环境。拿上面的例子举例 123456#format.properties 下面两个不匹配会选这个，作为备胎name=xxx#format_en_GB.propertiesname=madongmei#format_zh_CN.propertiesname=马冬梅 只需要更改第四个参数就可以读取不同配置文件了，不了解添加什么后缀可以看Locale类 1resources.getMessage(&quot;name&quot;, null, &quot;Default&quot;, Locale.CHINA); 标准和自定义事件spring中时间是通过ApplicationEvent和ApplicationListener接口提供的。如果自定义~实现ApplicationListener接口，每次ApplicationEvent发布到ApplicationContext，都会通知该bean 标准事件spring内置事件 事件 解释 ContextRefreshedEvent 上下文初始化或刷新时发布。初始化表示所有bean都已加载，后置处理器执行，单例被实例化并且上下文对象已准备好使用。刷新戴白哦热刷新或直接调用refresh()方法手动刷新 ContextStartedEvent 上下文已启动时发布 ContextStoppedEvent 上下文停止时发布 ContextClosedEvent 上下文关闭时发布 RequestHandledEvent 一个http请求已获得服务，请求完成后发布，只适用于web的DispatcherServlet ServletRequestHandledEvent RequestHandledEvent的父类 基于代码自定义事件自定义事件，首先创建类集成ApplicationEvent 类并声明初始化方法 123456//自定义事件public class MyCustomEvent extends ApplicationEvent { public MyCustomEvent(Object source) { super(source); }} 然后定义事件发布者 123456789101112131415public class MyCustomPublisher implements ApplicationEventPublisherAware { private ApplicationEventPublisher publisher; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) { this.publisher = applicationEventPublisher; } //发布自定义事件 public void publish(){ //该方法是阻塞式的 publisher.publishEvent(new MyCustomEvent(this)); }} 定义事件监听 12345678public class MyCustomListener implements ApplicationListener&lt;MyCustomEvent&gt; { //收到事件后，触发该方法 @Override public void onApplicationEvent(MyCustomEvent event) { //业务逻辑... }} 上面定义的三个类都需要注册到容器中，没啥营养这里不再列出。spring运行时会检测到MyCustomPublisher并自动调用setApplicationEventPublisher方法传入spring容器本身。通过其ApplicationEventPublisher接口的publishEvent方法发布事件，然后阻塞，之到接收者接收到事件进行处理。 基于注释的事件监听器还是根据上面例子，改为基于注解的方式的监听器 12345678public class MyCustomListener{ //收到事件后，触发该方法 @EventListener public void onApplicationEvent(MyCustomEvent event) { //业务逻辑... }} 如果要监听多个事件 1234@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})public void handleContextStart() { // ...} 可以添加监听事件的条件 1234@EventListener(condition = &quot;#blEvent.content == 'my-event'&quot;)public void onApplicationEvent(MyCustomEvent event) { //业务逻辑...} 时间的SpEL表达式可以使用如下数据 名称 描述 举例 Event ApplicationEvent #root.event 或者 event 参数数组 访问参数数组 #root.args[i] 或 args[i] 参数名称 任何方法参数和名称 #blEvent o或#a0 异步监听器使用@Async开启异步监听 12345@EventListener@Asyncpublic void onApplicationEvent(MyCustomEvent event) { //业务逻辑...} 异步监听不能通过返回值来发布后续事件。如果发生异常也不会传播给调用者 监听顺序使用@Order注解可以设置监听器监听顺序（越小优先级越高） 12345@EventListener@Order(42)public void onApplicationEvent(MyCustomEvent event) { //业务逻辑...} 通用事件监听可以通过泛型进一步定义事件结构 1234@EventListenerpublic void onPersonCreated(MyCustomEvent&lt;Animal&gt; event) { // ...} 访问底层资源点击跳转 应用程序启动追踪todo 常用方法ApplicationContext是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过getBean方法 getType(...)：调用指定的bean名称，确定bean运行时类型 getBean(...)：获取bean实例 12345//创建和配置beansApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);//获取beanPetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class); 元数据详细配置配置元数据表示在应用程序中Spring应该如何实例化、配置和组装bean。一般使用xml格式提供，但也可以使用其他形式 xml 配置 XML 的配置元数据基本格式如下 1234567&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;misterkaoli&quot;/&gt;&lt;/bean&gt; Spring也支持嵌套属性标签，在解析时会将内部元素&lt;value/&gt;的文本转换为的对应属性 1234567891011&lt;bean id=&quot;mappings&quot; class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt; &lt;!-- 类型为 java.util.Properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; jdbc.driver.className=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; p-namespace允许使用bean标签的属性代替&lt;property/&gt;子标签，如下所示 123456789101112&lt;bean name=&quot;exampleBean&quot; class=&quot;com.example.ExampleBean&quot;&gt; &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt; &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;&lt;/bean&gt;&lt;!--等价于--&gt;&lt;bean name=&quot;exampleBean&quot; class=&quot;com.example.ExampleBean&quot; p:email=&quot;someone@somewhere.com&quot; p:spouse-ref=&quot;jane&quot;/&gt;&lt;!--等价于--&gt; &lt;c-namespace&gt;允许使用bean标签属性代替&lt;constructor-arg&gt;子标签，如下所示 1234567891011&lt;!-- traditional declaration with optional argument names --&gt;&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt; &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt; &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt; &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;&lt;/bean&gt;&lt;!--等价于--&gt;&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot; c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt; 复合属性名称 当一个bean中由属性A，A包含属性B，B又包含属性C，此时我想要给C赋值，就可以使用符合属性名称 123&lt;bean id=&quot;test&quot; class=&quot;test.TestBean&quot;&gt; &lt;property name=&quot;A.B.C&quot; value=&quot;123&quot; /&gt;&lt;/bean&gt; &lt;bean&gt;&lt;bean&gt;标签内容如下： **id**：指定一个字符串，表示bean的标识符，由字母、数字和特殊字符组成，只能指定一个； **name**：能指定多个标识符，不同标识符用逗号、分号或空格分隔； **class**：使用完全限定的类名定义bean的类型； **scope**：bean的作用域，[详细说明](#bean 作用域) **destroy-method**：指定销毁回调方法，详细说明 **init-method**：指定初始化回调方法，详细说明 **parent**：指定BeanDefinition的父子关系，详细说明 **abstract**：指定BeanDefinition是否是纯模板，详细说明 **&lt;lookup-method&gt;**：通过方法注入bean，详细说明 **&lt;replaced-method&gt;**：替换目标bean的方法，详细说明 **depends-on**：显式指定一个或多个单例的bean在初始化/销毁当前bean之前进行初始化/销毁，多个bean使用逗号、空格和分包分隔； **lazy-init**：bean懒加载，在第一次使用到时才加载； **autowire**：为bean定义指定自动装配模式，&lt;property&gt;和&lt;constructor-arg/&gt;的依赖项会覆盖自动装配，不能装配简单属性 no：没有自动装配（默认） byName：按属性名称自动装配，若未找到，则不设置属性值 byType：按属性类型自动装配，若未找到，则不设置属性值 constructor：类似与byType，但是指定的是构造函数参数，若未找到，则报错 **autowire-candidate**：设置为false，则按类型的自动装配不可用（包括@Autowired注解），不会影响按名称的引用； **default-autowire-candidates**：通过表达式限制bean的名称，多个表达式以逗号分隔。例如*Repository指定依赖的bean必须以Repository结尾； **&lt;property&gt;**：定义bean的属性 **name**：JavaBean属性的名称 **value**：属性的值，spring会自动将值转换为实际类型 **&lt;value&gt;**：作用同value，一般值比较复杂时使用 **ref**：所引用Bean的定义名称 **&lt;ref&gt;**：功能同ref **bean**：目标bean名称 **parent**：通过该属性指定目标bean是对当前容器父容器中的bean的引用 **idref**：一个防错方式，功能类似value属性，但他会在会在容器部署时查看指定id的bean是否存在，而不是在实例化时； **&lt;bean&gt;**：内部bean定义不需要指定id或name，创建时会忽略id、name和scope。这是个匿名bean，外部的其他bean不能访问 **&lt;list&gt;**：List类型，详细说明 **&lt;set&gt;**：set类型，详细说明 **&lt;map&gt;**：map类型，详细说明 **&lt;props&gt;**：props类型，详细说明 **&lt;null/&gt;**：表示null值 **&lt;constructor-arg/&gt;**：构造函数实例化bean时的的参数 name：JavaBean中构造函数的参数名 **value**：参数的值，spring会自动将值转换为实际类型 **type**：参数类型 **index**：参数索引，从0开始 **ref**：所引用Bean的定义名称 **&lt;qualifier&gt;**：[详细说明](#@Qualifier 对应的 xml 配置) 集合属性可以使用&lt;list/&gt;，&lt;set/&gt;，&lt;map/&gt;，和&lt;props/&gt;标签表示Collection类型List，Set，Map，和Properties详细配置如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;property name=&quot;myProperties&quot;&gt; &lt;props&gt; &lt;!--Properties单个值的定义--&gt; &lt;prop key=&quot;p1&quot;&gt;p1&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;p2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;!--list单个值的定义--&gt; &lt;value&gt;l1&lt;/value&gt; &lt;!--引用外部bean--&gt; &lt;ref bean=&quot;refBean&quot;/&gt; &lt;!--list和set还可以定义其他任意集合元素--&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;!--map单个值的定义--&gt; &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;/&gt; &lt;!--key和value都可以引用外部bean--&gt; &lt;entry key-ref=&quot;refBean&quot; value-ref=&quot;refBean&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;!--set单个值的定义--&gt; &lt;value&gt;s1&lt;/value&gt; &lt;!--引用外部bean--&gt; &lt;ref bean=&quot;refBean&quot;/&gt; &lt;!--set和list还可以定义其他任意集合元素--&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean name=&quot;refBean&quot; class=&quot;test.pojo.RefBean&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 上面引用的java类如下： 12345678910111213141516@Data@NoArgsConstructor@ToStringpublic class TestBean { private List myList; private Set mySet; private Map myMap; private Properties myProperties;}@Data@NoArgsConstructor@AllArgsConstructorpublic class RefBean { private String name;} 集合合并Spring容器还支持集合合并，可以定义父&lt;list/&gt;，&lt;map/&gt;，&lt;set/&gt;或&lt;props/&gt;元素，然后定义其子元素，这样最终子元素的值就是子集合和父集合的并集，如果有相同的元素，子集合会覆盖父集合的值，配置如下 12345678910111213141516171819&lt;bean name=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;test.pojo.CollectionMerge&quot;&gt; &lt;property name=&quot;myProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;p1&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;p2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--指明parent，不需要指明class--&gt;&lt;bean name=&quot;child&quot; parent=&quot;parent&quot;&gt; &lt;property name=&quot;myProperties&quot;&gt; &lt;!--子集合指定merge=&quot;true&quot;开启集合合并--&gt; &lt;props merge=&quot;true&quot;&gt; &lt;prop key=&quot;p2&quot;&gt;p22&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;p33&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 对应的bean类如下 12345@Data@NoArgsConstructorpublic class CollectionMerge { private Properties myProperties;} 最终子集合的结果为 1CollectionMerge(myProperties={p3=p33, p2=p22, p1=p1}) 补充： 如果不指定id和name，容器会为该bean生成一个唯一名称。但如果想根据名称引用bean，则需要指定名称； 对于指定泛型的集合Spring会自动进行转换； &lt;import&gt;&lt;import&gt;标签内容如下： resource：其他xml文件位置。默认位置路径是相对于当前xml文件的，也可以使用绝对路径。不建议使用 ../ 和 classpath:URL，因为这样会创建当前应用程序之外的文件的依赖关系 &lt;alias&gt;&lt;alias&gt;标签内容如下： name：bean名字 alias：别名 1&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt; &lt;beans&gt;&lt;beans&gt;标签内容如下： **default-init-method**：默认初始化回调，详细介绍 **default-destroy-method**：默认销毁回调，详细介绍 **profile**：项目配置环境 &lt;beans&gt;标签可以内嵌&lt;beans&gt;标签 profile 示例12345678910111213141516171819&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xsi:schemaLocation=&quot;...&quot;&gt; &lt;!-- 不同环境使用不同的bean配置，也可以把beans拆分为多个xml文件 --&gt; &lt;beans profile=&quot;development&quot;&gt; &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=&quot;production&quot;&gt; &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt; &lt;/beans&gt;&lt;/beans&gt; &lt;context:XXX&gt;注解组件扫描&lt;context:component-scan/&gt;标签内容如下： **base-package**：要扫描的包 **&lt;context:include-filter&gt;**：扫描过滤器，查看详情 **&lt;context:exclude-filter/&gt;**：扫描过滤器，查看详情 扫描包配置： 1&lt;context:component-scan base-package=&quot;test.annotation&quot;&gt;&lt;/context:component-scan&gt; 使用&lt;context:component-scan&gt;隐式启用 &lt;context:annotation-config&gt;。&lt;context:component-scan&gt;使用时通常不需要包含 &lt;context:annotation-config&gt; 1&lt;context:annotation-config/&gt; &lt;context:annotation-config/&gt;的作用是引入了以下后置处理器，用于处理了相应注解： ConfigurationClassPostProcessor AutowiredAnnotationBeanPostProcessor： @Autowired CommonAnnotationBeanPostProcessor： @Resource @PostConstruct @PreDestroy PersistenceAnnotationBeanPostProcessor： @PersistenceContext EventListenerMethodProcessor： 引入properties文件123&lt;beans&gt; &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;&lt;/beans&gt; jdbc.properties内容如下 1234jdbc.properties jdbc.url=jdbc:hsqldb:hsql://localhost/xdb jdbc.username=sa jdbc.password=111111 java 注解配置此处只列出spring常用和官方提供的注解，如果想要查看其他注解，索引如下 JSR 330 标准注释：[查看详情](#JSR 330 标准注释) @Bean使用范围 类 方法 作用 用来将bean加入到ioc容器中，[查看详情](#@Bean 注解) @Autowired使用范围 构造方法 属性 属性 required：是否必须。默认为true，若不存在则会报错。详细内容下文列出 作用 用于注入属性，[详细内容](#@Autowired 注解) @Resouece使用范围 方法 字段 作用 注入bean依赖，[查看详情](#@Resource 注解) @ConstructorProperties使用范围 构造方法 作用 显示命名构造方法的参数，查看详情 @Required (弃用)使用范围 作用在setXXX()的方法上 作用 只起到提示的作用，如果注释的方法所对应的bean没有配置，就会报错。spring 5.1已经弃用@Required注解，推荐使用构造函数注入进行所需设置。 @Lookup使用范围 方法 作用 用来指定需要注入的方法，点击方法注入查看例子 @PostConstruct使用范围 方法 作用 指定bean初始化回调方法，查看详情 @PreDestroy使用范围 方法 作用 指定bean销毁回调方法，详细说明 @Primary使用范围 @bean注解的方法上 组件类上 作用 指定优先的候选项，[查看详情](#@primary 注解) @Qualifier使用范围 方法参数 和@Autowired配合使用 作用 根据名字过滤bean，[查看详情](#@Qualifier 注解) @PropertySource使用范围 配置类上 作用 读取外部配置，查看详情 @Value使用范围 方法参数 字段 作用 读取外部配置，[查看详情](#@Value 注解) @Scope使用范围 @bean标记的方法 组件注解标记的类 作用 为bean设置作用域，[查看详情](#@Scope 注解) @Configuration使用范围 配置类 作用 声明配置类，[查看详情](#@Configuration 注解) @import使用范围 配置类 作用 导入外部配置类，[查看详情](#@import 注解) @Conditional使用范围 @bean标记的方法 配置类上 作用 用于判断配置类或bean是否引入，[查看详情](#@Conditional 注解) @ImportResource使用范围 配置类 作用 引入外部xml文件，[查看详情](#@ImportResource 注解) @Profile使用范围 配置类 组件类 @bean方法 作用 根据当前环境判断注释的类或bean是否应该被注册，[查看详情](#@Profile 注解) @Component使用范围 bean类上 作用 声明组件类并注册到ioc容器中，又根据语义不同用其封装了多个注解，[查看详情](#@Component 及其组合注解) 依赖注入依赖注入就是在容器创建bean时注入所需要的依赖项，依赖注入由两种方式： 基于构造函数的依赖注入 基于 Setter 的依赖注入 基于构造函数的依赖注入基于构造函数的DI是通过让其调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。和静态工厂方法构造bean几乎是等效的 123456789101112131415161718192021//当前bean@Data@NoArgsConstructorpublic class TestBean { private String name; private int age; private RefBean refBean; public TestBean(String name, int age, RefBean refBean) { this.name = name; this.age = age; this.refBean = refBean; }}//被引用的bean@Datapublic class RefBean { private String name;} 通过构造方法进行依赖注入 123456789&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg value=&quot;张三&quot;/&gt; &lt;constructor-arg value=&quot;6&quot;/&gt; &lt;constructor-arg ref=&quot;refBean&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;refBean&quot; class=&quot;test.pojo.RefBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 也可以通过@ConstructorProperties注解代替xml配置文件，代码如下： 123456@ConstructorProperties({&quot;name&quot;,&quot;age&quot;,&quot;refBean&quot;})public TestBean(String name1, int age1, RefBean refBean) { this.name = name1; this.age = age; this.refBean = refBean;} 构造参数函数解析 &lt;constructor-arg/&gt; 标签中如果不指定name属性，参数会按照顺序传入构造函数，只要参数类型都对应正确，属性就能正确注入。如果参数类型对应不上，比如把 &lt;constructor-arg/&gt; 标签位置调换一下，那么就会报错。 123456&lt;!--运行会报错--&gt;&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg value=&quot;6&quot;/&gt; &lt;constructor-arg value=&quot;张三&quot;/&gt; &lt;constructor-arg ref=&quot;refBean&quot;/&gt;&lt;/bean&gt; 为了防止这种问题的发生，可以指定name、index或type属性，这三个属性指的都是构造函数的参数，目的就是消除歧义。下面以name举例（点击查看其他属性） 123456&lt;!--运行成功--&gt;&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;6&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;constructor-arg ref=&quot;refBean&quot;/&gt;&lt;/bean&gt; 另外，可以通过 [@ConstructorProperties()](# @ConstructorProperties)注解指定构造函数的参数 基于 Setter 的依赖注入基于 Setter 的 DI 是通过容器在调用无参数构造函数或无参数static工厂方法来实例化bean 后调用 bean 上的 setter 方法来完成的。 12345678910111213141516//当前类@Data@NoArgsConstructorpublic class TestBean { private String name; private int age; private RefBean refBean;}//被引用bean@Data@NoArgsConstructor@AllArgsConstructorpublic class RefBean { private String name;} 通过 Setter 进行依赖注入 123456789&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;refBean&quot; ref=&quot;refBean&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;refBean&quot; class=&quot;test.pojo.RefBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; 点击查看标签属性 基于构造函数和 setter 两种方式可以混合使用，也就是通过构造函数注入依赖项后，还支持使用 setter 进行依赖注入，下面配置是可行的 12345&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;refBean&quot; ref=&quot;refBean&quot;/&gt;&lt;/bean&gt; 依赖注入方式的选择选择规则 对必须依赖项使用构造函数，Spring官方提倡使用构造函数注入，理由如下： 这样可以将应用程序组件实现为不可变对象，并确保所需的依赖项不是null； 构造函数注入的组件大多是以初始化完毕的状态返回的； 对可选依赖项使用setter，理由如下： 如果只使用setter，则必须在代码使用依赖项的任何地方执行非空检查； 可以在在setter方法上使用 @Request 注释可用于使属性成为必须的依赖项； 对于不公开任何setter函数的第三方类，构造函数注入可能是唯一可用形式； 依赖解析过程容器执行bean依赖解析过程如下： 使用ApplicationContext扫描所有的配置元数据执行 bean 创建和初始化。配置元数据可以由 XML、Java 代码或注释指定； 对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数（如果您使用它而不是普通构造函数）的形式表示。在实际创建 bean 时，将这些依赖关系提供给 bean； 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用； 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，例如int、 long、String、boolean等； 每个bean作为依赖项注入到其他bean中时就都已经完全配置了； 循环依赖如果使用构造函数注入，则可能会产生循环依赖。例如A的构造函数需要B，B的构造函数需要依赖A，这样A和B都不会初始化成功，Spring检测到后会抛出BeanCurrentlyInCreationException异常。为了解决这类问题，spring在容器加载时检测配置问题，解析依赖项，并且会尽可能晚的设置属性。 方法注入大多数情况下，容器中的bean基本都是单例的。当一个单例的bean依赖另一个非单例的bean时，就可能因为bean的周期不同而出现问题。比如A是单例的，B不是单例的，A依赖B，并且A中有一个方法每次调用都需要B，但A只会在初始化时注入B，无法在每次需要时都为A提供B的新实例。 可以通过实现ApplicationContextAware接口，并在A需要B时调用getBean(&quot;B&quot;)方法获取B实例，代码如下： 123456789101112131415161718192021222324252627282930313233public class A implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } protected B CreateB() { return this.applicationContext.getBean(&quot;b&quot;, B.class); } public Object process(String State) { // 从ioc容器中获取B实例 B b =CreateB(); // 设置B实例状态 b.setState(State); // 执行业务逻辑 return b.execute(); }}@Datapublic class B { private String state; public B execute() { //业务代码 System.out.println(state); return this; }} 这种方式可以解决问题，但A的业务代码与Spring存在耦合。使用方法注入可以更简洁的解决问题，代码如下： 123456789101112public abstract class A { protected abstract B CreateB(); @Lookup public Object process(String State) { B b = CreateB(); b.setState(State); return b.execute(); }} 上面代码使用@Lookup注解进行配置，如果不使用注解也可以使用xml文件配置 12345678&lt;bean name=&quot;b&quot; class=&quot;test.pojo.B&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;a&quot; class=&quot;test.pojo.A&quot;&gt; &lt;!--b如果是单例，每次返回的都是一个实例，如果不是单例，每次返回不同实例--&gt; &lt;lookup-method name=&quot;CreateB&quot; bean=&quot;b&quot;/&gt;&lt;/bean&gt; 使用方法注入后代码量小了很多，而且类中看不到Spring的部分，耦合度也降低了。 查找方法注入查找方法注入是一种覆盖被容器管理的bean的方法的功能，通过&lt;lookup-method&gt;标签或@Lookup注解指定bean中应该覆盖的方法并将容器中对应名字的bean作为方法的返回结果返回。Spring会通过CGLIB进行动态代理来动态生成覆盖该方法的子类并实现该方法的注入。使用时需要注意以下内容： 需要方法注入的类不能被final修饰，需要注入的方法也不能被final修饰； 对具有abstract方法的类进行单元测试需要自己实现子类和方法？ 组件扫描需要到具体类中的具体方法 不适合用于工厂方法，特别是配置类中以@bean修饰的方法，这种情况下，容器不会创建实例，无法在运行时生成子类 要注入的方法格式如下： 1&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments); 如果方法时abstract的，则动态生成的子类实现该方法，负责，动态生成的子类会覆盖原始类中的具体方法。 任意方法替换任意方法替换也可以实现方法注入，但一般没什么用。如果使用xml配置，可以使用 &lt;replaced-method&gt;为已部署的bean中咸鱼的方法替换为另一个方法的实现。举例如下： 假设A中有一个replace()方法，我希望将这个方法替换掉 12345678public class A { public String replace(){ System.out.println(&quot;我是原版的&quot;); return &quot;我是原版的&quot;; }} 定义一个ReplaceA并继承MethodReplacer接口实现reimplement方法，这个方法就是用于替换A中的方法 1234567891011121314public class ReplaceA implements MethodReplacer { /** * @param o * @param method 被替换的方法 * @param objects 参数列表 * @return * @throws Throwable */ @Override public String reimplement(Object o, Method method, Object[] objects) throws Throwable { System.out.println(&quot;我要替换A的方法&quot;); return &quot;我要替换A的方法&quot;; }} 在xml文件中如下配置 123456789&lt;bean name=&quot;replaceA&quot; class=&quot;test.pojo.ReplaceA&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;a&quot; class=&quot;test.pojo.A&quot;&gt; &lt;replaced-method name=&quot;replace&quot; replacer=&quot;replaceA&quot;&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt; 配置完成之后，ioc容器中的A的replace()方法就已经被替换掉了 123ClassPathXmlApplicationContext application = new ClassPathXmlApplicationContext(&quot;collections.xml&quot;);A a = application.getBean(&quot;a&quot;, A.class);a.replace(); //输出：我要替换A的方法&quot; 在&lt;replaced-method&gt;中可以使用一个或多个&lt;arg-type&gt;来指定被覆盖方法的签名，只有在方法被覆盖并且类中存在多个变体时参数的签名才是必须的 bean 作用域声明了一个beanDefination相当于创建了一个这个bean的模板，spring通过这个模板创建多个实例。spring中不仅可以配置bean的依赖和配置，还可以定义beanDefination创建的对象的范围（作用域）。spring定义了六个作用域，下面表格已列出，其中后四个仅在web-aware的上下文情况下有效，另外还可以自定义作用域 Scope 描述 singleton 单例（默认），每个ioc容器中只有一个该对象实例 prototype 任意数量的对象实例 request 单个bean在单个http请求内有效 session 单个bean在http session内有效 application 单个bean在ServletContext内有效 websocket 单个bean在websocket有效 单例当定义一个bean作用域为singleton时，让其会创建该beanDefination的一个实例，存储在单例bean的缓存中，并且对名为该bean的所有后续请求都返回该缓存实例。 原型scope为prototype时，每次对特定bean发出的请求都会创建一个新的bean实例。可以通过注入或者通过容器的getBean方法来进行请求。通常对一些有状态的bean建议声明为prototype作用域，对无状态的bean使用singleton作用域。 spring不会管理prototype的bean的完整的声明周期，只有容器实例化、配置以及组装原型对象并返回给客户端，之后就没有在进一步的操作了.不论作用域是什么，都会调用初始化声明周期回调方法。但是，在prototype情况下不会调用配置的销毁的生命周期回调方法，需要客户端清理prototype的bean并释放所持有的资源，可以通过自定义bean post-processor对bean进行清理 使用具有原型依赖的单例bean当使用的一个单例bean中需要用到原型bean时可以使用方法注入来解决问题 其他作用域request，session，application，和websocket这四个作用域仅用于使用一个web-aware的ApplicationContext实现（例如XmlWebApplicationContext）。不在ClassPathXmlApplicationContext等常规容器下使用，否则会报错 todo 自定义bean扩展生命周期回调可以通过实现InitializingBean和DisposableBean接口的方式与容器对 bean 生命周期的管理进行交互。容器为前者调用 afterPropertiesSet() 为后者调用 destroy() 以让 bean 在初始化和销毁 bean 时执行某些操作。除了初始化和销毁的回调外，还可以实现Lifecycle接口来管理Spring中对象的生命周期。 初始化回调可以通过实现InitializingBean接口并重写afterPropertiesSet()方法来进行bean的初始化。但官方不建议使用这种方式，因为它会使业务代码与Spring耦合。建议使用以下方式 12345678public class SpringLifeCycle { //bean初始化回调 @PostConstruct public void init(){ System.out.println(&quot;初始化回调&quot;); }} 上面使用注解方式，也可以使用xml指定初始化回调方法 12345&lt;!--init-method 设置 bean初始化回调--&gt;&lt;bean name=&quot;lifeCycle&quot; class=&quot;test.pojo.SpringLifeCycle&quot; init-method=&quot;init&quot;&gt;&lt;/bean&gt; 销毁回调可以通过实现DisposableBean接口并重写destroy()方法来进行bean的初始化。但官方不建议使用这种方式，因为它会使业务代码与Spring耦合。建议使用以下方式 12345678public class SpringLifeCycle { //bean销毁回调 @PreDestroy public void destroy(){ System.out.println(&quot;销毁回调&quot;); }} 上面使用注解方式，也可以使用xml指定销毁回调方法 12345&lt;!--destroy-method 设置 bean初始化回调--&gt;&lt;bean name=&quot;lifeCycle&quot; class=&quot;test.pojo.SpringLifeCycle&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt; 默认初始化和销毁方法在&lt;beans&gt;顶级标签上可以定义默认的回调方法名，这样在此&lt;beans&gt;标签内的&lt;bean&gt;标签如果不指定默认的初始化回调那么就会使用设置的默认的回调名的方法 12345678910public class SpringLifeCycle { public void init(){ System.out.println(&quot;初始化回调&quot;); } public void destroy(){ System.out.println(&quot;销毁回调&quot;); }} xml配置 123456&lt;beans default-init-method=&quot;init&quot; default-destroy-method=&quot;destroy&quot;&gt; &lt;bean name=&quot;lifeCycle&quot; class=&quot;test.pojo.SpringLifeCycle&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 多个生命周期机制 上面说明了三种配置生命周期回调的机制： 在InitializingBean和 DisposableBean回调接口 自定义init()和destroy()方法，使用xml配置 使用@PostConstruct和@PreDestroy 注释修饰方法 一个bean可能通过不同机制配置多个回调函数，如果每个配置的方法名都一样，那么只会执行一次，否则每个配置的方法会按照如下顺序执行： 用@PostConstruct和@PreDestroy 注释的方法 InitializingBean和DisposableBean回调接口定义的方法 自定义配置init()和destroy()方法 bean生命周期调用顺序 bean实例化：容器寻找bean的定义信息并将其实例化 依赖注入：按照BeanDefination配置bean的属性 BeanNameAware：如果实现该接口，调用setBeanName()方法 BeanFactoryAware：如果实现该接口，调用setBeanFactory()方法 BeanPostProcessors：如果实现该接口，调用ProcessBeforeInitialization()方法 initializingBean：如果实现该接口，调用afterPropertiesSet()方法 init-method：如果有该配置，调用init-method指定的方法 BeanPostProcessors：如果实现该接口，调用ProcessaAfterInitialization()方法 bean配置完成，可以在业务代码中使用 DisposableBean：如果实现该接口，调用destroy()方法 destroy-method：如果有该配置，调用destroy-method指定的方法 容器级生命周期回调Lifecycle 接口123456789public interface Lifecycle { //容器启动回调 void start(); //容器关闭回调 void stop(); boolean isRunning();} 任何spring所管理的对象都可以实现该接口，当ApplicationContext接收到启动和停止信号时，就会级联调用当前上下文中Lifecycle的所有实现。 LifecycleProcessor 接口LifecycleProcessor是Lifecycle的扩展接口，它添加了刷新和关闭上下文的回调方法 1234567public interface LifecycleProcessor extends Lifecycle { //刷新上下文回调 void onRefresh(); //关闭上下文回调 void onClose();} SmartLifecycle 接口不同bean启动和关闭的顺序可能比较重要，比如A依赖B，那么在启动时B应该在A之前启动，在关闭时A应该在B之前关闭，所以他们两个顺序时固定的，可以使用Phased接口，它提供了getPhase()方法，该方法会返回一个int值，表示执行顺序，启动时最小的phase最先启动，停止时相反。比如上面的例子就可以设置A为200，B为100 12345public interface Phased { //返回值表示启动顺序 int getPhase();} 要对特定 bean 的自动启动（包括启动阶段）进行细粒度控制需要使用SmartLifecycle接口，它实现了Phased接口 12345678910111213141516171819202122public interface SmartLifecycle extends Lifecycle, Phased { int DEFAULT_PHASE = 2147483647; //刷新回调会调用该方法，判断是否在该点启动， //返回true时，Spring容器启动时会去执行start()方法。 default boolean isAutoStartup() { return true; } //DefaultLifecycleProcessor会调用该方法 default void stop(Runnable callback) { this.stop(); //调用回调的run()方法 //相当于开启异步关闭功能 callback.run(); } //返回的是优先级 default int getPhase() { return 2147483647; }} 如上面代码所示，SmartLifecycle接口的getPhase()方法返回的如果返回的是2147483647，如果没有实现SmartLifecycle接口的Lifecycle对象默认为0，因此负的phase会在常规Lifecycle之前启动，之后停止。 LifecycleProcessor接口的默认实现是DefaultLifecycleProcessor，负责在每个阶段中调用对象组的stop()方法，直到超时为止，默认是30秒，可以在上下文中定义bean的timeoutPerShutdownPhase 1234&lt;bean id=&quot;lifecycleProcessor&quot; class=&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;&gt; &lt;!-- timeout value in milliseconds --&gt; &lt;property name=&quot;timeoutPerShutdownPhase&quot; value=&quot;10000&quot;/&gt;&lt;/bean&gt; 实际使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class SpringLifeCycle implements SmartLifecycle { //启动信号 private boolean isRunning; //Lifecycle方法 @Override public void start() { System.out.println(&quot;start-&gt;容器启动回调&quot;); //正在运行 isRunning = true; } @Override public void stop() { System.out.println(&quot;stop-&gt;容器关闭回调&quot;); //标记停止 isRunning = false; } //容器是否正在运行 @Override public boolean isRunning() { System.out.println(&quot;isRunning&quot;); return isRunning; } //SmartLifecycle方法 //容器启动时是否去执行start()方法 @Override public boolean isAutoStartup() { System.out.println(&quot;isAutoStartup&quot;); return true; } @Override public void stop(Runnable callback) { System.out.println(&quot;stop-&gt;生命周期结束&quot;); isRunning = false; callback.run(); } //优先级 @Override public int getPhase() { System.out.println(&quot;getPhase-&gt;获取优先级&quot;); return Integer.MAX_VALUE; }} Awarespring提供了很多的Aware接口，他们的目的是让bean可以获取Spring容器的服务。其实就是一堆用来做依赖注入的回调方法，通过这些方法可以在某些阶段向bean注入一些东西。但这种方式不太好，因为bean代码与spring存在耦合，相比之下用注解进行依赖注入更好 名称 注入依赖 ApplicationContextAware 应用上下文对象 ApplicationEventPublisherAware BeanClassLoaderAware BeanFactoryAware BeanNameAware bean的名字 LoadTimeWeaverAware MessageSourceAware NotificationPublisherAware ResourceLoaderAware ServletConfigAware ServletContextAware ApplicationContextAware如果需要将ApplicationContext注入到bean中，可以创建一个bean并实现ApplicationContextAware接口 123public interface ApplicationContextAware extends Aware { void setApplicationContext(ApplicationContext applicationContext) throws BeansException;} ApplicationContextAware接口中包含setApplicationContext方法，通过实现这个方法完成对applicationContext的注入 12345678public class TestAware implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; }} ApplicationEventPublisherAware如果需要将配置的beanName注入到bean中，可以创建一个bean并实现BeanNameAware接口 123public interface BeanNameAware extends Aware { void setBeanName(String var1);} 通过实现该接口的setBeanName方法完成对beanName的设置 123456789public class TestAware implements BeanNameAware { private String beanName; @Override public void setBeanName(String s) { this.beanName = s; }} 其他Aware接口每个Aware接口的使用方式其实没有区别，关键在于理解每个Aware接口注入实例的作用。关于其他的Aware接口的使用方式不再列出，参照上面两个例子写即可。 其他扩展点BeanPostProcessorSpring框架提供了BeanPostProcessor接口，通过实现该接口并重写之内的方法来定义回调逻辑，Spring会负责自动检测并调用适当的方法 1234567891011public interface BeanPostProcessor { @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; }} 可以配置多个BeanPostProcessor实例，并且BeanPostProcessor可以通过实现Ordered接口设置order来控制这些实例的运行顺序。 当在配置类中使用@bean注解一个定义BeanPostProcessor的工厂方法时，工厂方法的返回值应该是实现或者至少是BeanPostProcessor接口，明确指定post-processor。否则ApplicationContext无法自动检测到。 BeanFactoryPostProcessor此接口用于对bean配置元数据进行操作，可以通过这个接口读取配置元数据并在容器实例化bean之前更改配置元，和BeanPostProcessor类似，但BeanPostProcessor接口时是用来更改bean实例的。该接口也需要与Ordered解耦一起使用指定顺序。 1234@FunctionalInterfacepublic interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;} FactoryBeanFactoryBean接口用于ioc容器的实例化逻辑，如果有复杂的初始化逻辑，可以通过java代码的方式替换冗长的xml。FactoryBean接口提供了三种方法： T getObject()：返回此工厂创建的对象的实例。实例可能会被共享，这取决于这个工厂是返回单例还是原型； boolean isSingleton():true代表FactoryBean返回单例，false表示其他情况 。此方法的默认实现返回true； Class&lt;?&gt; getObjectType(): 返回getObject()方法返回的对象类型，如果不知道类型就返回null； 12345678910111213public interface FactoryBean&lt;T&gt; { String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;; @Nullable T getObject() throws Exception; @Nullable Class&lt;?&gt; getObjectType(); default boolean isSingleton() { return true; }} 代码举例： 1234567891011121314public class MyFactoryBean implements FactoryBean&lt;MyBean&gt; { @Override public MyBean getObject() throws Exception { return new MyBean(); } @Override public Class&lt;?&gt; getObjectType() { return MyBean.class; }}public class MyBean {} 基于java和注解的容器配置注解注入在XML注入之前执行，所以，如果两种方式同时使用，XML可能会覆盖注释的某些配置。 组件扫描与组件组件扫描@ComponentScan和@ComponentScans@ComponentScan注解和@ComponentScans注解用于扫描spring组件。一般声明在配置类上，主要扫描@Component注解和包含@Component的组合注解。 @ComponentScan注解内声明扫描组件所在的包，比较重要的属性如下： value/basePackages：扫描的包，默认是该配置类所在的包。 excludeFilters：排除要扫描的项，查看详情 includeFilters：指定要扫描的包，查看详情 123@ComponentScan(&quot;com.test&quot;)public class MyConfig {} @ComponentScans注解内部是一个@ComponentScan注解的数组 123@ComponentScans({@ComponentScan(value = &quot;test&quot;)})public class MyConfig {} 如果需要使用xml的方式扫描可以如下配置 1&lt;context:component-scan base-package=&quot;org.example&quot;/&gt; 组件扫描过滤可以通过指定@ComponentScan的excludeFilters和includeFilters属性自定义过滤器，每个过滤器都需要type和expression属性 过滤器类型 示例表达式 说明 annotation（默认） org.example.SomeAnnotation 在目标组件的类级别存在该注释或其组合注释 assignable org.example.SomeClass 目标组件继承或实现了该类 aspectj org.example..*Service+ 与目标组件匹配的aspectj表达式 regex org.example.Default.* 与目标组件匹配的正则表达式 custom org.example.MyTypeFilter 根据接口的自定义实现 也可以使用等效的xml标签： &lt;context:exclude-filter /&gt; &lt;context:include-filter /&gt; 下面例子表示扫描test包，然后排除符合test.anno.*Value的类 123456@ComponentScan(value = &quot;test&quot;, excludeFilters = { @ComponentScan.Filter( type = FilterType.REGEX, pattern = &quot;test.anno.*Value&quot;)}, ) 上面例子等效于xml文件 123456&lt;beans&gt; &lt;context:component-scan base-package=&quot;test&quot;&gt; &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;test.anno.*Value&quot;/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; spring默认会自动检测使用@Component、@Repository、@Service、@Controller、@RestController或@Configuration进行注释或元注释的类。如果希望ji禁用这个默认行为可以设置 123@ComponentScan(value = &quot;xxx&quot;, useDefaultFilters = false ) 等效的xml配置 1234&lt;context:component-scan base-package=&quot;xxx&quot; use-default-filters=&quot;false&quot;&gt;&lt;/context:component-scan&gt; @Component 及其组合注解@Component注解用来标记spring的一个组件，是一个通用注解，使用@Component注解提供给各个层的注解有： @Repository：持久层 @Service：服务层 @Controller：表示层 @Configuration：配置类 他们用来标记应该注册进容器的bean类上 123@Component(&quot;dog&quot;)public class Dog implements Animal{} 这些组件注解如果没指明value，他的bean名称会由BeanNameGenerator生成。默认情况下是首字母小写的名称，比如上面例子如果不指定名称则为dog。 如果不想使用默认的名称生成策略，可以实现 BeanNameGenerator 接口，并确保包含一个默认的无参数构造函数。然后，在配置扫描器时提供完全限定的类名，如下配置 1234567891011121314@Configuration@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)public class AppConfig { // ...}public class MyNameGenerator implements BeanNameGenerator { //在该方法中指定命名策略即可 @Override public String generateBeanName(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry) { return null; }} @Bean 注解可以在组件中使用@bean注解向容器中注入bean，也可以在该bean工厂方法上添加其他spring注解设置该beanDefinition，一般声明在@Configuration修饰的类上，这时是完整模式。声明在其他类上时被称为精简模式，精简模式不能声明依赖，也就是说这个bean工厂方法的参数不能引入其他bean依赖 1234567891011121314151617181920212223@Configurationpublic class MyConfig { //指定bean的name，默认是方法名，多个名字可使用一个数组传递 @Bean(name = &quot;cat&quot;) //可以声明为static static public Animal getCat(){ return new Cat(); } @Bean //限定修饰符? @Qualifier(&quot;public&quot;) //作用域 @Scope(&quot;singleton&quot;) //懒加载 @Lazy @Description(&quot;bean的描述信息&quot;) public Animal getDog(){ return new Dog(); } } 方法中可以定义参数，会自动进行依赖注入 1234567public interface BaseConfig { @Bean default TransferServiceImpl transferService() { return new TransferServiceImpl(); }} 可以同时定义bean的各种声明周期配置 12345678910111213@Configurationpublic class AppConfig { @Bean(initMethod = &quot;init&quot;) public BeanOne beanOne() { return new BeanOne(); } @Bean(destroyMethod = &quot;cleanup&quot;) public BeanTwo beanTwo() { return new BeanTwo(); }} @Scope 注解@Scope 使用@Scope 注解用于指定bean的scope，如果想要使用自定义策略可以实现ScopeMetadataResolver接口 1234567public class MyBeanScope implements ScopeMetadataResolver { @Override public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) { return null; }} 然后在类扫描器中指定它 12345@Configuration@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)public class AppConfig { // ...} xml形式 1234&lt;beans&gt; &lt;context:component-scan base-package=&quot;org.example&quot; scope-resolver=&quot;org.example.MyScopeResolver&quot;/&gt;&lt;/beans&gt; scoped-proxyspring提供了一种通过作用域代理来处理依赖的方式。使用 XML 配置时创建此类代理的最简单方法是&lt;aop:scoped-proxy/&gt;元素。使用注释在 Java 中配置 bean提供了对属性@Scope的等效支持。proxyMode默认值为ScopedProxyMode.DEFAULT，这通常表示不应创建作用域代理，除非在组件扫描指令级别配置了不同的默认值。您可以 指定ScopedProxyMode.TARGET_CLASS、ScopedProxyMode.INTERFACES或ScopedProxyMode.NO @Configuration 注解@Configuration 使用@Configuration是一个类级别的注解，用来表示一个配置类，内部可声明多个@bean，本身是用来替代xml的，也可以和xml配合使用 12345678910111213141516@Configurationpublic class MyConfig { @Bean(name = &quot;cat&quot;) public Cat getCat(){ return new Cat(); } @Bean(name = &quot;dog&quot;) public Dog getDog(){ return new Dog(); }} 查找方法注入在单例范围的 bean 依赖于原型范围的 bean 的情况下，会用到查找方法注入。 12345678910111213141516171819202122232425262728293031public abstract class CommandManager { public Object process(Object commandState) { // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } // okay... but where is the implementation of this method? protected abstract Command createCommand();}@Bean@Scope(&quot;prototype&quot;)public AsyncCommand asyncCommand() { AsyncCommand command = new AsyncCommand(); // inject dependencies here as required return command;}@Beanpublic CommandManager commandManager() { // return new anonymous implementation of CommandManager with createCommand() // overridden to return a new prototype Command object return new CommandManager() { protected Command createCommand() { return asyncCommand(); } }} @import 注解@import注解用来引入另一个配置类并进行加载，这个注解也是spring boot的核心 123456789101112131415161718@Configurationpublic class ConfigA { @Bean public A a() { return new A(); }}@Configuration@Import(ConfigA.class)public class ConfigB { @Bean public B b() { return new B(); }} @Conditional 注解@Conditional一般用于配置类中，与@bean一起使用。表示必须满足某些条件才能实例化bean。它内部引入了一个实现了Condition接口的类，并且重写了matches方法，在改方法中会条件判断是否成立，如果成立返回true，否则返回false，下面举例说明 @Profile 注解此处只是为了解释@Conditional，@Profile的使用会在后文详细介绍。 @Profile 注解内部就是条件注解实现的，判断依据是当前项目的环境 12@Profile(&quot;test&quot;)//测试环境才加载@Profile(&quot;dev&quot;)//开发环境标识 他一般作用在@bean方法上和配置类上 1234567@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional({ProfileCondition.class})public @interface Profile { String[] value();} 他引入了一个ProfileCondition类，其内部的matches方法定义了判断条件的逻辑，参数有条件上下文和注解的元数据 123456789101112131415161718192021222324class ProfileCondition implements Condition { ProfileCondition() { } public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) { Iterator var4 = ((List)attrs.get(&quot;value&quot;)).iterator(); Object value; do { if (!var4.hasNext()) { return false; } value = var4.next(); } while(!context.getEnvironment().acceptsProfiles(Profiles.of((String[])((String[])value)))); return true; } else { return true; } }} @ImportResource 注解@ImportResource 注解用于导入外部的xml文件，一般声明在@Configuration类上 123456789101112131415161718@Configuration@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)public class AppConfig { @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean public DataSource dataSource() { return new DriverManagerDataSource(url, username, password); }} 生成候选组件索引路径扫描速度很快，但仍可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。现有的扫描注解和配置必须不变，然后加入以下jar包 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt; &lt;version&gt;6.0.0-SNAPSHOT&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果是gradle 12345678910//5.6及以下版本dependencies { compileOnly &quot;org.springframework:spring-context-indexer:6.0.0-SNAPSHOT&quot;}//4.6及以上版本dependencies { annotationProcessor &quot;org.springframework:spring-context-indexer:6.0.0-SNAPSHOT&quot;} 合格jar包会生成一个META-INF/spring.components的文件，挡在类路径找到该文件时，索引会自动启动 依赖注入@Autowired 注解@Autowired 注解只按照类型匹配，想要通过bean名字匹配需要结合@Qualifier使用 应用于构造函数只有一个构造函数时不需要 @Autowired 注解，属性会自动注入 12345678910@Componentpublic class Person { private Cat cat; public Person(Cat cat) { this.cat = cat; } } 扫描到Person类时会自动调用构造函数，然后注入属性 如果有多个构造函数需要通过@Autowired 注解指定要解析的构造函数，若不指定默认调用无参构造，若无参构造也没有则报错 1234567891011121314151617@Componentpublic class Person { private Cat cat; private Dog dog; public Person(Cat cat) { this.cat = cat; } @Autowired public Person(Cat cat, Dog dog) { this.cat = cat; this.dog = dog; }} 多个构造函数标记@Autowired必须都将required设置为false，spring会优先选取匹配参数最多的构造函数，如果一个都不满足，则使用默认构造函数。如果只有一个构造函数标记@Autowired则可以为true。 应用于setter 方法12345678910@Componentpublic class Person { private Cat cat; @Autowired public void setCat(Cat cat) { this.cat = cat; }} 应用于任意名称和多个参数的方法12345678910@Componentpublic class Person { private Cat cat; @Autowired public void ohohohoh(Cat cat) { this.cat = cat; }} spring会自动调用该方法注入依赖 应用于字段1234567@Componentpublic class Person { @Autowired private Cat cat; } 获取对应类型的所有bean123456789101112131415161718192021@Componentpublic class Person { //Cat和Dog的bean会被注入到animals @Autowired private Animal[] animals; //不是必须要用数组，也可以是任何适用的集合类型 private List&lt;Animal&gt; animals;}public interface Animal {}@Componentpublic class Cat implements Animal {}@Componentpublic class Dog implements Animal{} 如果希望列表中的bean按特定顺序注入可以在目标bean实现Ordered接口，或者使用@Order或@Priority注释，否则会按容器中相应bean加载顺序注入 Map会根据value的值进行匹配，只要类型相同就都注入 12345678@Componentpublic class Person { //会将所有Animal类型的bean注入，key是bean的name @Autowired private Map&lt;String,Animal&gt; animals;} 使用集合类型接收时至少要匹配到一个元素，如果一个都没匹配到，自动装配会失败 补充： 可以使用泛型作为隐式的限定，同一个类型的bean，不同的泛型类型也会作为限定条件； @Primary 注解由于@Autowired注解是根据类型进行注入的，所以可能出现多个候选者，这时候就需要使用 @primary 注解指定应有限考虑特定的bean 12345678910111213141516@Componentpublic class Cat implements Animal {}@Primary@Componentpublic class Dog implements Animal{}@Componentpublic class Person { @Autowired private Animal animal;} 如果不加@Primary因为cat和dog都是Animal类型的bean，不知道该注入哪个于是就会报错。上面指定dog为@primary，最终注入的就是dog； 如果是通过@bean注解注册bean，也可以在@bean注解的方法上加@primary，效果是一样的 123456@Bean @Primary public MovieCatalog firstMovieCatalog() { ... } @Bean public MovieCatalog secondMovieCatalog() { ... } @Qualifier 注解如果有多个bean候选项，可以通过@Qualifier注解指定bean的限定值，一般使用beanName作为限定值，用于过滤候选项。 应用于构造函数上12345678910@Componentpublic class Person { private Animal animal; public Person(@Qualifier(&quot;cat&quot;) Animal animal) { this.animal = animal; }} 应用于 @Autowired 注释的方法上1234@Autowiredpublic void sss(@Qualifier(&quot;cat&quot;) Animal animal) { this.animal = animal;} 和 @Autowired 一起使用123@Autowired@Qualifier(&quot;cat&quot;)private Animal animal; @Qualifier 对应的 xml 配置todo 1234&lt;bean class=&quot;xxx&quot;&gt; &lt;qualifier value=&quot;xxx&quot;/&gt; &lt;!-- ... --&gt;&lt;/bean&gt; 自定义限定注解123456@Target({ElementType.FIELD, ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface MyQualifier { String value();} 补充： 除了上面的例子外，@Qualifier 还可以用于过滤bean后注入到集合依赖中； 如果只想使用name主bean有先考虑使用@Resource； @Resource 注解@Resource注解默认根据名称和类型注入bean name：bean的名字，默认值下面例子中列出 type：对于类型，默认值下面例子中列出 应用于字段上如果没有指定name默认是字段名称，如果没有指定type，默认类型就为字段的类型 1234567@Componentpublic class Person { @Resource(name = &quot;cat&quot;) private Animal animal; } 应用于方法上如果没有指定name会将注入的变量名作为名称，比如下面例子默认就是cat。方法名可以随意。如果没有指定type，默认是参数类型，下面例子默认就是Animal 1234@Resource(name = &quot;cat&quot;)public void setCat(Animal cat) { this.cat = cat;} 环境配置Environment接口是集成在spring上下文中的环境抽象，他存储了当前应用程序中的配置文件和属性。配置文件会根据当前的活跃状态向容器中注册bean，而属性包括JVM、操作系统环境变量、命令行参数，一般会在所有应用程序中发挥作用。 @PropertySource注解@PropertySource用于导入外部配置内容，导入的配置会存储在上下文中的environment对象中 12345@PropertySource(&quot;classpath:MyConfig.properties&quot;)@Configurationpublic class MyConfig {} @PropertySource内部可以存在${…}占位符，此占位符会根据环境中的属性进行解析 1@PropertySource(&quot;classpath:/com/${test.placeholder:default/path}/MyConfig.properties&quot;) 上面环境中如果有test.placeholder属性则被解析，否则会使用冒号后的默认配置default/path，如果未指定默认配置则会报错 补充： Spring Boot 默认配置一个PropertySourcesPlaceholderConfigurer的bean，该bean 将从application.properties和application.yml文件中获取属性。 PropertySource 接口Environment对象内中存在propertySources属性，它内部包含一个PropertySource的CopyOnWriteArrayList 列表，上下文的环境信息以这种形式保存在这个列表中。Spring的StandardEnvironment配置了两个 PropertySource 对象，一个代表 JVM 系统属性集（System.getProperties()），一个代表系统环境变量集（System.getenv()）。想要获取配置可以使用以下方法 12345ConfigurableEnvironment environment = ctx.getEnvironment();//是否包含配置environment.containsProperty(&quot;key&quot;);//获取配置信息environment.getProperty(&quot;key&quot;); 搜索配置是分层的，会按照propertySources从头向后变量，默认顺序如下： ServletConfig 参数（如果适用——例如，在DispatcherServlet上下文的情况下） ServletContext 参数（web.xml 上下文参数条目） JNDI 环境变量（java:comp/env/条目） JVM 系统属性（-D命令行参数） JVM系统环境（操作系统环境变量） 上面的是默认顺序，也可以自己选择添加的位置 123MutablePropertySources sources = ctx.getEnvironment().getPropertySources();//设置为头部，最高优先级sources.addFirst(new MyPropertySource()); @Value 注解@Value通常用于注入外部属性，如果值不带${…}占位符则直接注入，如果值带${…}占位符，请看下面的例子 12# 配置文件名：MyConfig.propertiestest.value=aaa 引入配置文件 12345@PropertySource(&quot;classpath:MyConfig.properties&quot;)@Configurationpublic class MyConfig {} 应用于字段上12345678@Componentpublic class TestValue { @Value(&quot;${test.value}&quot;) public String value;} 应用于构造方法上123456789@Componentpublic class TestValue { public String value; public TestValue(@Value(&quot;${test.value}&quot;) String value) { this.value = value; }} 默认属性值spring 提供了一个默认的宽松嵌入式值解析器。它将尝试解析属性值，如果无法解析占位符，会将@Value注解中的值注入属性，下面例子中因为根本没有test.value1这个配置，所以解析失败，默认将${test.value1}字面量注入属性。属性只能是字符串类型，其他类型会报错 12@Value(&quot;${test.value1}&quot;)public String value; 如果要严格控制不存在的值，可以声明一个PropertySourcesPlaceholderConfigurer的bean，如果通配符解析错误会初始化失败 1234@Beanpublic static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() { return new PropertySourcesPlaceholderConfigurer();} spring提供了内置转换器支持允许自动处理简单的类型转换，多个逗号分隔的值会自动转换为字符数组。举例如下 123456789//注入值@Value(&quot;${test.value}&quot;)public float value;@Value(&quot;${test.value1}&quot;)public String[] value;//配置test.value=1test.value1=one,two,three 设置属性默认值可以使用如下配置 123//如果取值失败会使用默认值@Value(&quot;${xxx.xxx:默认值}&quot;)public String[] value; 自定义类型转换spring使用ConversionService来处理@Value注解中将String类型转换为目标类型的过程，如果想要自定义这个转化过程可以提供自定义的ConversionService的bean实例 12345678910@Configurationpublic class AppConfig { @Bean public ConversionService conversionService() { DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(); conversionService.addConverter(new MyCustomConverter()); return conversionService; }} todo @Value 包含SpEL表达式当@Value包含SpEL表达式时，该值会在运行时动态计算 1 todo（看到SpEL时补充） @Profile 注解Environment对象中粗壮乃activeProfiles的set集合，里面存放着当前的激活状态 @Profile 作用@Profile 用于声明一个或多个配置文件处于活动状态，如果指定配置不处于活跃状态，那么标记该注解的类不被解析和注册。可以包含一个配置文件名称（production）或者配置文件表达式。还可以使用更复杂的逻辑表达式（production &amp; test），逗号分隔按或算： !：配置文件的逻辑“非”； &amp;：配置文件的逻辑“与”； |：配置文件的逻辑“或”； 如果一个@Configuration类标有@Profile，如果指定的配置文件不是活跃状态，呢么其内的方法和注释都将被跳过。如果通过@Import引入了一个标有@Profile注解的@Component或@Configuration类，如果指定的配置文件没有激活，那么不会注册该类 1234567891011121314151617181920@Configuration//这两个环境时生效@Profile({&quot;production&quot;,&quot;development&quot;})public class MyConfig { //不同环境使用不同数据源配置 @Bean(&quot;dataSource&quot;) @Profile(&quot;development&quot;) public DataSource standaloneDataSource() { //... } //使用不同配置的@Bean的方法名称应不同 @Bean(&quot;dataSource&quot;) @Profile(&quot;production&quot;) public DataSource jndiDataSource() throws Exception { //... }} 激活配置文件方式一：在启动类中通过代码配置 12AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(&quot;development&quot;); 方式二：使用spring.profiles.active属性激活配置文件，可以在系统环境变量、JVM系统属性、servlet 上下文参数等方式配置 1-Dspring.profiles.active=&quot;profile1,profile2&quot; 方式三：通过Environment配置 1ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;); 如果没有配置激活文件，默认激活default 123456789@Configuration@Profile(&quot;default&quot;)public class DefaultDataConfig { @Bean public DataSource dataSource() { //... }} 自定义读取配置文件todo 123456789@Beanpublic static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() { PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); //设置前缀 placeholderConfigurer.setPlaceholderPrefix(&quot;pre.&quot;); //设置后缀 placeholderConfigurer.setPlaceholderSuffix(&quot;.suf&quot;); return placeholderConfigurer;} 12the.value1=bbbthe.value2=ccc 12@Value(&quot;pre.the.value1.suf-pre.the.value2.suf&quot;)public String value;//bbb-ccc JSR 330 标准注释spring 3开始spring提供了对JSR 330 标准注释的支持。这些注释的扫描方式与spring注解相同。如果想要使用，需要引入相关jar包 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.inject&lt;/groupId&gt; &lt;artifactId&gt;jakarta.inject-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt; 其中注解对比如下表： spring注解 JSR 330 注解 说明 @Autowired @Inject @Inject没有required属性，可以使用Optional替代 @Component @Named / @ManagedBean JSR-330 does not provide a composable model, only a way to identify named components. @Scope(“singleton”) @Singleton 默认也是单例 @Qualifier @Qualifier / @Named ObjectFactory Provider Provider使用get方法 破东西，呸，不好用！ 注册 LoadTimeWeaver当spring需要动态转换类时，会用到LoadTimeWeaver类。将其加载到JVM中，可以使用@EnableLoadTimeWeaving注解到配置类上，以此来引入该类 1234@Configuration@EnableLoadTimeWeavingpublic class AppConfig {} 对应的xml配置 123&lt;beans&gt; &lt;context:load-time-weaver/&gt;&lt;/beans&gt; 一般这个类会在jpa转换时用到，此处不再赘述，详细查看spring data jpa","link":"/2020/02/05/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IOC%EF%BC%89/"},{"title":"Spring 核心功能：数据绑定与验证","text":"spring提供了一个数据绑定（DataBinder）与验证（Validator）的设计，目的是不用将验证视为业务逻辑、更易于本地化和可以插入任何可用的验证器 数据验证Jakarta Bean Validationspring提供对Bean Validation（Jakarta Bean Validation）的支持，它是一个java规范，允许开发人员通过注解或自定义注解来表达对象模型（数据验证）的约束。他的一个被认可的实现是Hibernate Validator，这里使用Hibernate Validator为例 引入依赖Maven： 1234567891011121314151617&lt;!--hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;7.0.2.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; Gradle： 123456//hibernate-validatorimplementation group: 'org.hibernate.validator', name: 'hibernate-validator', version: '7.0.2.Final'//javax.el-apiimplementation group: 'javax.el', name: 'javax.el-api', version: '3.0.0'//javax.elimplementation group: 'org.glassfish', name: 'javax.el', version: '3.0.0' 声明约束Hibernate Validator 包含一组基本的常用约束。这些是 Jakarta Bean 验证规范定义的主要约束，此外，Hibernate Validator 提供了有用的自定义约束。每个约束都可以声明message字段值，在验证失败时可以通过方法查看错误值 基本约束 约束名称 作用范围 作用 @AssertFalse 布尔 元素为false @AssertTrue 布尔 元素为true @DecimalMax(value=, inclusive=) 数字、字符序列等 元素值小于value，inclusive表示是否带等于 @DecimalMin(value=, inclusive=) 数字、字符序列等 元素值大于value，inclusive表示是否带等于 @Digits(integer=, fraction=) 数字、字符序列等 值最多为integer位数，和fraction位小数 @Max(value=) 数字、字符序列等 元素值小于等于value @Min(value=) 数字、字符序列等 元素值大于等于value @Negative 数字、字符序列等 元素是否为负 @NegativeOrZero 数字、字符序列等 元素是否为负或0 @Positive 数字、字符序列等 元素是否为正 @PositiveOrZero 数字、字符序列等 元素是否为正或0 @Future 日期类型 日期在未来 @FutureOrPresent 日期类型 日期在现在或未来 @Past 日期类型 日期在过期 @PastOrPresent 日期类型 日期在现在或过去 @Email 字符序列 检查电子邮箱格式 @NotBlank 字符序列 元素不为空 @Pattern(regex=, flags=) 字符序列 检查是否匹配正则 @NotEmpty Collection、map、字符序列 元素不为空 @Size(min=, max=) Collection、map、字符序列 元素大小介于min、max之间（包含） @NotNull 任意类型 元素值不为null @Null 任意类型 元素为null 说明： 字符序列（CharSequence）是一个接口，他的子类有String、StringBuffer、StringBuilder； 附加约束 约束名称 作用范围 作用 @Currency(value=) MonetaryAmount 货币单位是否是指定货币单位的一部分 @DurationMax(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=) Duration 元素不大于根据注释参数构造的元素，inclusive代表是否允许相等 @DurationMin(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=) Duration 元素不小于根据注释参数构造的元素，inclusive代表是否允许相等 @CreditCardNumber(ignoreNonDigitCharacters=) 字符序列 检查元素是否通过Luhn 校验和测试 @EAN 字符序列 检查带注释的字符序列是否为有效的EAN条形码。type 确定条码的类型。默认值为 EAN-13 @ISBN 字符序列 检查带注释的字符序列是否是有效的ISBN。type确定 ISBN 的类型。默认值为 ISBN-13。 @Length(min=, max=) 字符序列 元素长度在min和max之间 @CodePointLength(min=, max=, normalizationStrategy=) 字符序列 字符序列的代码点长度是否介于两者之间min并max包括在内。如果设置，则验证标准化值normalizationStrategy @LuhnCheck(startIndex= , endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=) 字符序列 字符序列中的数字是否通过了 Luhn 校验和算法 @Mod10Check(multiplier=, weight=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=) 字符序列 检查带注释的字符序列中的数字是否通过了通用 mod 10 校验和算法 @Mod11Check(threshold=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=, treatCheck10As=, treatCheck11As=) 字符序列 检查带注释的字符序列中的数字是否通过了 mod 11 校验和算法 @Normalized(form=) 字符序列 验证带注释的字符序列是否根据给定的form @URL(protocol=, host=, port=, regexp=, flags=) 字符序列 根据 RFC2396 检查带注释的字符序列是否是有效的 URL @Range(min=, max=) 数字、字符序列等 检查注释值是否介于（包括）指定的最小值和最大值之间 @ScriptAssert(lang=, script=, alias=, reportOn=) 任意类型 检查是否可以根据注释元素成功评估给定脚本 @UniqueElements Collection 检查带注释的集合是否仅包含唯一元素 Hibernate Validator 还提供了一些特定于国家/地区的限制条件，例如用于验证社会安全号码，有需要点击查看 约束声明位置 字段约束 12@NotNullprivate String name; getter约束 12@NotNullpublic String getxxx() {return xxx;} 容器约束 1private Set&lt;@ValidPart String&gt; set = new HashSet&lt;&gt;(); 类约束 12@ValidPassengerCountpublic class Car {...} 参数约束 12//name不能为空,可以连续加多个约束，空格分隔public void funName(@NotNull String name) {...} 返回值约束 1234//返回值不能为null@NotNull//返回集合不能包含nullpublic List&lt;@NotNull Customer&gt; funName() {return null;} 级联约束：级联约束需要在将要进行约束的字段标记@Valid即可 约束继承：父类声明的约束在子类也一样有效 验证字段验证字段使用Validator类 123ValidatorFactory factory = Validation.buildDefaultValidatorFactory();Validator validator = factory.getValidator(); Validator方法： validate()：对给定 bean 的所有约束执行验证 1validator.validate(person); validateProperty()：验证给定对象的单个命名属性，不能检查级联 12//第二个参数是字段名字符串validator.validateProperty(person,&quot;name&quot;); validateValue()：给定对象的单个命名属性进行验证，不能检查级联 1validator.validateValue( person.class,&quot;name&quot;,null); 验证方法验证方法使用ExecutableValidator类 123ValidatorFactory factory = Validation.buildDefaultValidatorFactory();ExecutableValidator executableValidator = factory.getValidator().forExecutables(); ExecutableValidator方法： validateParameters()：验证方法参数 12345Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateParameters( person, Person.class.getMethod(&quot;printMessage&quot;,String.class), new Object[]{&quot;参数1&quot;}); validateReturnValue()：验证方法返回值 12345Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateReturnValue( person, Person.class.getMethod(&quot;printMessage&quot;,String.class), Collections.&lt;Person&gt;emptyList()); validateConstructorParameters()：验证构造函数参数 1234Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateParameters( Person.class.getConstructor(String.class), new Object[]{&quot;参数1&quot;}); validateConstructorReturnValue()：验证构造函数返回值 1234executableValidator.validateConstructorReturnValue( Person.class.getConstructor(), new Person()); 获取验证结果ConstraintViolation类用于包装验证结果，常用方法如下： getMessage()：内插错误消息 getMessageTemplate()：非插值错误消息 getRootBean()：正在验证的根 bean getRootBeanClass()：正在验证的根 bean类 getPropertyPath()：从根 bean 到验证值的属性路径 getInvalidValue()：值未能通过约束 getConstraintDescriptor()：约束元数据报告失败 getExecutableParameters()：验证方法时返回方法或构造函数验证的参数数组 getExecutableReturnValue()：验证返回值时提供对验证对象的访问 约束示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Data@AllArgsConstructor@NoArgsConstructorpublic class Person { @NotNull(message = &quot;名字不能为空&quot;) @Length(min = 1,max = 5,message = &quot;名字长度在1-5之间&quot;) private String name; @Range(min = 0,max = 150,message = &quot;年龄在0-150之间&quot;) private int age; @NotNull(message = &quot;生日不能为空&quot;) @Past(message = &quot;生日要在过去&quot;) private Date birthday; @NotNull(message = &quot;邮箱不能为空&quot;) @Email(message = &quot;邮箱格式不正确&quot;) private String email; //返回值约束 @NotBlank(message = &quot;返回值不能为空&quot;) public String getFormatPrint(){ return String.format(&quot;name=%s,age=%d,birthday=%s&quot;,name,age,birthday); } //参数约束 public void printMessage(@NotBlank(message = &quot;参数不能为空&quot;) String message){ System.out.println(message); } //级联验证 @Valid @NotEmpty private List&lt;Cat&gt; cats; @Data @NoArgsConstructor public static class Cat{ @NotBlank(message = &quot;猫名字不能为空&quot;) private String name; public Cat(String name) { this.name = name; } }} 验证代码 12345678910111213141516171819202122232425262728ValidatorFactory factory = Validation.buildDefaultValidatorFactory();//字段验证Validator validator = factory.getValidator();//方法验证ExecutableValidator executableValidator = factory.getValidator().forExecutables();//构造beanPerson person = new Person();//名字长度大于5person.setName(&quot;克里斯蒂安刘能&quot;);//不给猫加名字person.setCats(Collections.singletonList(new Person.Cat()));//验证字段Set&lt;ConstraintViolation&lt;Person&gt;&gt; constraintViolationSet = validator.validate(person);for (ConstraintViolation&lt;Person&gt; constraintViolation : constraintViolationSet) { System.out.println(constraintViolation.getMessage());}//验证方法Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateParameters( person, Person.class.getMethod(&quot;printMessage&quot;,String.class), new Object[]{&quot;&quot;});for (ConstraintViolation&lt;Person&gt; constraintViolation : printMessage) { System.out.println(constraintViolation.getMessage());} 自定义约束创建约束注释123456789101112131415161718@Target({ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(validatedBy = {MyConstraintValidator.class})public @interface MyCheck { //违反约束的默认消息 String message() default &quot;字符串值必须为yes&quot;; //此约束所属的验证组的属性 Class&lt;?&gt;[] groups() default {}; //Jakarta Bean Validation API 的客户端可以使用该属性将自定义有效负载对象分配给约束 Class&lt;? extends Payload&gt;[] payload() default {}; //允许指定所需的案例模式,一般不需要 String[] value() default {};} 实现一个验证器实现ConstraintValidator&lt;A extends Annotation, T&gt; 接口并实现其方法即可 12345678910111213141516171819202122/** * 父类泛型解释 * A extends Annotation：这里是MyCheck，表示要验证的注释类型 * T：这里是String，表示要处理的元素类型 */public class MyConstraintValidator implements ConstraintValidator&lt;MyCheck, String&gt; { //访问当前验证注解的属性值 @Override public void initialize(MyCheck constraintAnnotation) { } //包含实际的验证逻辑 @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) { if(&quot;yes&quot;.equals(s)){ return true; } return false; }} 接下来只需要把注解放到想要验证的地方就可以了，此处不演示 验证单个对象（spring）spring提供了Validator接口，可以创建一个验证类实现该接口，并实现其中的方法，用于数据的验证 12345678910111213141516171819202122232425262728293031323334353637public class Person { private String name; private int age; //getters/setters}public class PersonValidator implements Validator { /** * Validator是否可以提供验证该clazz类的实例 * @param clazz * @return */ @Override public boolean supports(Class&lt;?&gt; clazz) { return Person.class.equals(clazz); } /** * 验证给定的对象，并将错误信息返稿errors里 * @param target 验证码目标对象 * @param errors 包装错误信息，内部包括target对象 */ @Override public void validate(Object target, Errors errors) { //拒绝该属性 ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name为空&quot;); Person p = (Person) target; if (p.getAge() &lt; 0) { errors.rejectValue(&quot;age&quot;, &quot;年龄为负数&quot;); } else if (p.getAge() &gt; 110) { errors.rejectValue(&quot;age&quot;, &quot;年纪过大&quot;); } }} 说明： ValidationUtils是spring提供的工具类； 拒绝字段时除了自定义的拒绝code（例如rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)），还会自动注册其他code（还会注册too.darn.old.ageand too.darn.old.age.int）； 上述代码可通过如下代码调用验证和获取结果 1234567Person person = new Person();person.setName(&quot;张三&quot;);DataBinder binder = new DataBinder(person);binder.setValidator(new PersonValidator());binder.validate();BindingResult results = binder.getBindingResult();System.out.println(results); 验证嵌套对象（spring）验证嵌套对象时最好将每个对象的验证逻辑封装在自己的Validator实现中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Person { private String name; private Cat cat; //getters/setters}public class Cat { private String name; //getters/setters}public class CatValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; clazz) { return Cat.class.equals(clazz); } @Override public void validate(Object target, Errors errors) { ValidationUtils.rejectIfEmptyOrWhitespace(errors,&quot;cat.name&quot;,&quot;没名字&quot;); }}public class PersonValidator implements Validator { private CatValidator catValidator; public PersonValidator(CatValidator catValidator) { this.catValidator = catValidator; } /** * Validator是否可以提供验证该clazz类的实例 * @param clazz * @return */ @Override public boolean supports(Class&lt;?&gt; clazz) { return Person.class.equals(clazz); } /** * 验证给定的对象，并将错误信息返稿errors里 * @param target 验证码目标对象 * @param errors 包装错误信息 */ @Override public void validate(Object target, Errors errors) { ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name为空&quot;); Person p = (Person) target; //去执行cat的验证 ValidationUtils.invokeValidator(this.catValidator,p.getCat(),errors); }} 数据绑定DataBinderDataBinder是spring提供的数据绑定机制，可以与Validator接口的实现类配合使用，进行数据验证，用法如下 123456789Person person = new Person();person.setName(&quot;张三&quot;);DataBinder binder = new DataBinder(person);binder.setValidator(new PersonValidator());//执行验证binder.validate();//获取错误信息BindingResult results = binder.getBindingResult();System.out.println(results); BeanWrapper 接口BeanWrapper接口以及其对应实现（BeanWrapperImpl）位于org.springframework.beans包内。BeanWrapper提供了设置和获取属性值、获取属性描述符和查询属性以确定他们是可读还是可写的功能。此外BeanWrapper还提供对嵌套属性的支持，还有对设置索引属性的支持。BeanWrapper会在DataBinder和BeanFactory中被使用 表达式 说明 name 属性名 cat.name 嵌套属性 list[1] 集合属性 map[key] 键值对映射 举例如下： 1234567891011121314151617181920212223@Datapublic class Cat { private String name;}@Datapublic class Person { private String name; private Cat cat;}BeanWrapperImpl person = new BeanWrapperImpl(new Person());//设置值（方式一）person.setPropertyValue(&quot;name&quot;,&quot;张三&quot;);//设置值（方式二）PropertyValue value = new PropertyValue(&quot;cat&quot;, new Cat());person.setPropertyValue(value);//设置嵌套属性person.setPropertyValue(&quot;cat.name&quot;,&quot;猫咪&quot;);//获取person对象Person rootInstance = (Person)person.getRootInstance();System.out.println(rootInstance); PropertyEditor 接口Spring内部使用PropertyEditor接口进行属性编辑，将这些字符串装换为对应的Object类型。比如使用xml声明bean属性时，spring就会尝试使用ClassEditor将参数解析为Class对象。如果需要在绑定属性时做自定义操作，可以自己实现PropertyEditor并注册到ioc容器中 内置 PropertyEditor 实现spring内置了很多PropertyEditor的实现，BeanFactory和ApplicationContext都会通过他们来使用BeanWrapper进行属性转换。他们都位于org.springframework.beans.propertyeditors包中，并且大多数由PropertyEditor 注册 ByteArrayPropertyEditor：将字符串转换为对应的字节表示 ClassEditor：将表示类的字符串解析为实际类 CustomBooleanEditor：可自定义的Boolean编辑器 CustomCollectionEditor：将任意原集合转换为目标集合类型 CustomDateEditor：自定义DateFormat，默认未注册 CustomNumberEditor：处理数字类型 FileEditor：将字符串解析为java.io.File对象 InputStreamEditor：将字符串转换为InputStream LocaleEditor：将字符串（格式[language]_[country]_[variant]）转换为Locale对象，反之亦然 PatternEditor：字符串解析为java.util.regex.Pattern对象，反之亦然 PropertiesEditor：将字符串转换为Properties对象 StringTrimmerEditor：修剪字符串的属性编辑器。可选地允许将空字符串转换为null值，默认未注册 URLEditor：将url字符串转化为url对象 自定义 PropertyEditor自定义 PropertyEditor可以通过属性注入时的字符串value值创建自己希望的实例，然后注入到bean中。 bean类如下 1234567891011121314@Datapublic class Cat { private String name; public Cat(String name) { this.name = name; }}@Datapublic class Person { private String name; private Cat cat;} 将Cat注入到Person中 12345&lt;!--注入属性--&gt;&lt;bean name=&quot;person&quot; class=&quot;test.anno.Person&quot;&gt; &lt;!--此时使用的是value--&gt; &lt;property name=&quot;cat&quot; value=&quot;猫名字&quot;/&gt;&lt;/bean&gt; 自定义Cat类型的编辑器CatTypeEditor 123456public class CatTypeEditor extends PropertyEditorSupport { @Override public void setAsText(String text) throws IllegalArgumentException { super.setValue(new Cat(text)); }} 通过xml文件配置属性的映射关系并注册进ioc容器中 12345678&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt; &lt;property name=&quot;customEditors&quot;&gt; &lt;map&gt; &lt;!--配置类型和编辑器的映射--&gt; &lt;entry key=&quot;test.anno.Cat&quot; value=&quot;test.anno.CatTypeEditor&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 也可以通过实现PropertyEditorRegistrar接口进行注册 12345678//这里直接使用注解注入了，使用xml也一样@Configurationpublic class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar { @Override public void registerCustomEditors(PropertyEditorRegistry propertyEditorRegistry) { propertyEditorRegistry.registerCustomEditor(Cat.class,new CatTypeEditor()); }} xml文件中配置注册器 12345678&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt; &lt;!--注册自定义注册器--&gt; &lt;property name=&quot;propertyEditorRegistrars&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;customPropertyEditorRegistrar&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 类型转换spring 3引入了一个core.convert的包，用于提供通用的类型转换。它可以用来替代自定义 PropertyEditor，将外部的字符串value值转化为所需的属性类型 自定义转换器创建转换器类，实现Converter接口，实现convert方法 12345678910111213@FunctionalInterfacepublic interface Converter&lt;S, T&gt; { @Nullable T convert(S source); default &lt;U&gt; Converter&lt;S, U&gt; andThen(Converter&lt;? super T, ? extends U&gt; after) { Assert.notNull(after, &quot;After Converter must not be null&quot;); return (s) -&gt; { T initialResult = this.convert(s); return initialResult != null ? after.convert(initialResult) : null; }; }} 泛型S、T表示将数据从S类型转换为T类型 123456public class StringToCatConverter implements Converter&lt;String,Cat&gt; { @Override public Cat convert(String source) { return new Cat(source); }} 自定义转换器工厂当需要集中定义将字符串转化为有公共接口的多个类时，应该实现ConverterFactory接口 123public interface ConverterFactory&lt;S, R&gt; { &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);} 其中泛型表示将S转换为T类型，T必须是R的子类型 12345678910111213141516171819202122232425262728293031public class StringToAnimalConverterFactor implements ConverterFactory&lt;String,Animal&gt; { @Override public &lt;T extends Animal&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) { return null; } //根据不同的T类型创建不同的转换器，T可能是Cat也可能时Dog都实现了Animal private final class StringToAnimalConverter&lt;T extends Animal&gt; implements Converter&lt;String, T&gt; { private Class&lt;T&gt; AnimalType; public StringToAnimalConverter(Class&lt;T&gt; AnimalType) { this.AnimalType = AnimalType; } @SneakyThrows public T convert(String source) { Animal a = (Animal)AnimalType.newInstance(); a.setName(source); return (T)a; } } //使用反射效率低，个人觉得还是每个目标类型都定义一个转换器比较好，如下所示 private final class StringToAnimalConverter&lt;T&gt; implements Converter&lt;String, Cat&gt; { public Cat convert(String source) { return new Cat(&quot;猫名字&quot;); } }} 多对源类型与目标类型转换GenericConverter提供多对源类型和目标类型之间进行转换。它提供了可用的源和目标字段的上下文，可以在实现逻辑时使用。 1234567891011121314151617181920212223242526272829303132public interface GenericConverter { //返回支持的源→目标类型对 @Nullable Set&lt;GenericConverter.ConvertiblePair&gt; getConvertibleTypes(); //类型转换方法 @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType); //元-&gt;目标类型对 public static final class ConvertiblePair { private final Class&lt;?&gt; sourceType; private final Class&lt;?&gt; targetType; public ConvertiblePair(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType) { Assert.notNull(sourceType, &quot;Source type must not be null&quot;); Assert.notNull(targetType, &quot;Target type must not be null&quot;); this.sourceType = sourceType; this.targetType = targetType; } public Class&lt;?&gt; getSourceType() { return this.sourceType; } public Class&lt;?&gt; getTargetType() { return this.targetType; } //equals()/hashCode()/toString() }} 此接口一般只有在非常复杂的情况下才会使用 类型转换条件通过ConditionalGenericConverter接口可以定义类型转换条件。比如希望在目标字段上存在特定注解时才进行转换，或者时在目标类型上定义了特定方法才进行转换 123456public interface ConditionalConverter { boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);}public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {} 举例如下 12345678910111213141516171819public class StringToCatConditionalGenericConverter implements ConditionalGenericConverter { //转换条件 @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return false; } //可以转换的源类型-目标类型对 @Override public Set&lt;ConvertiblePair&gt; getConvertibleTypes() { return null; } //转换方法 @Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { return null; }} 通用类型转换逻辑ConversionService接口定义了一个统一的api，用于在运行时执行类型转换逻辑 1234567891011public interface ConversionService { boolean canConvert(@Nullable Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType); boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType); @Nullable &lt;T&gt; T convert(@Nullable Object source, Class&lt;T&gt; targetType); @Nullable Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);} 1 GenericConversionService类和ConversionServiceFactory类是ConversionService的实现类，特们提供了大多数环境的通用实现，默认可以在字符串、数字、枚举、集合、映射和其他常见类型之间进行转换。如果想用自定义转换器进行补充，只需要补充或覆盖默认转换器，配置如下 12345678&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;example.MyCustomConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 字段格式Formatter 接口Formatter 接口提供了简单的字段格式化功能 123456789101112public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {}@FunctionalInterfacepublic interface Printer&lt;T&gt; { String print(T object, Locale locale);}@FunctionalInterfacepublic interface Parser&lt;T&gt; { T parse(String text, Locale locale) throws ParseException;} 自定义格式转换，需要实现Formatter接口，实现其中的方法 1234567891011121314151617181920212223242526272829303132@Datapublic class MyDateFormatter implements Formatter&lt;Date&gt; { //时间格式 private String pattern; public MyDateFormatter(String pattern) { this.pattern = pattern; } public MyDateFormatter() { this.pattern = &quot;yyyy-MM--dd&quot;; } //解析方法，将字符串转化为对应的类型 @Override public Date parse(String formatted, Locale locale) throws ParseException { return getDateFormat(locale).parse(formatted); } //输出方法，将对象转换为对应格式的字符串 @Override public String print(Date date, Locale locale) { return getDateFormat(locale).format(date); } protected DateFormat getDateFormat(Locale locale) { DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale); dateFormat.setLenient(false); return dateFormat; }} 通过FormattingConversionServiceFactoryBean注册到ioc容器中 123456789&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt; &lt;!--自定义的formatter加入到该属性结合中--&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;test.anno.MyDateFormatter&quot; /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 也可以通过java代码形式 12345678910@Beanpublic FormattingConversionService conversionService() { DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); conversionService.addFormatter(new MyDateFormatter()); return conversionService;} 通过以下格式注入会调用自定义的MyDateFormatter类的parse方法进行转换 1234&lt;!--注入属性--&gt;&lt;bean name=&quot;person&quot; class=&quot;test.anno.Person&quot;&gt; &lt;property name=&quot;birthday&quot; value=&quot;2000-3--2&quot;/&gt;&lt;/bean&gt; 注解格式转换字段格式可以通过字段类型和注解进行配置，想要将注解绑定到Formatter，需要实现AnnotationFormatterFactory接口 1234567891011//A是一个注解类型，用来修饰与格式化逻辑的相关字段public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; { //返回能使用注解的字段类型 Set&lt;Class&lt;?&gt;&gt; getFieldTypes(); //返回一个Printer打印注解字段的值 Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType); //返回一个Parser用来解析注解字段的值 Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);} 自定义注解 12345678910111213141516171819@Documented@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})public @interface MyDateFormat { MyDateFormat.Style style() default MyDateFormat.Style.DEFAULT; //时间格式化类型 String pattern() default &quot;&quot;; //默认为英文格式 public static enum Style { DEFAULT, CHINESE; private Style() { } }} 实现AnnotationFormatterFactory接口并实现抽象方法，将需要使用的注解作为其泛型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//父类传递的泛型为MyDateFormatpublic class MyDateFormatAnnotationFormatterFactory implements AnnotationFormatterFactory&lt;MyDateFormat&gt; { public static Set&lt;Class&lt;?&gt;&gt; Types; static { Set&lt;Class&lt;?&gt;&gt; fieldTypes = new HashSet(8); fieldTypes.add(Date.class); Types = Collections.unmodifiableSet(fieldTypes); } public MyDateFormatAnnotationFormatterFactory() { } //返回可以解析的类集合 @Override public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() { return Types; } //获取打印器 @Override public Printer&lt;?&gt; getPrinter(MyDateFormat annotation, Class&lt;?&gt; fieldType) { return this.configureFormatterFrom(annotation); } //获取解析器 @Override public Parser&lt;?&gt; getParser(MyDateFormat annotation, Class&lt;?&gt; fieldType) { return this.configureFormatterFrom(annotation); } //这里获取打印器和解析器是上一小节自定义的Formatter类 //也可以直接返回SimpleDateFormat值? private Formatter&lt;Date&gt; configureFormatterFrom(MyDateFormat annotation) { String pattern = annotation.pattern(); //如果制定了时间格式 if (StringUtils.hasLength(pattern)) { return new MyDateFormatter(pattern); } else { MyDateFormat.Style style = annotation.style(); if (style == MyDateFormat.Style.CHINESE) { return new MyDateFormatter(&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;); } else { return new MyDateFormatter(&quot;yyyy:MM:dd HH:mm:ss&quot;); } } }} 创建注册器，用于同一添加 1234567891011121314151617181920@Datapublic class MyDateFormatterRegistrar implements FormatterRegistrar { private MyDateFormatter myDateFormatter; private MyDateFormatAnnotationFormatterFactory myDateFormatAnnotationFormatterFactory; public MyDateFormatterRegistrar() { myDateFormatter = new MyDateFormatter(); myDateFormatAnnotationFormatterFactory = new MyDateFormatAnnotationFormatterFactory(); } @Override public void registerFormatters(FormatterRegistry registry) { registry.addFormatter(myDateFormatter); //添加myDateFormatter，其实这里不添加也可以 registry.addFormatterForFieldType(Date.class,myDateFormatter); //添加myDateFormatAnnotationFormatterFactory registry.addFormatterForFieldAnnotation(myDateFormatAnnotationFormatterFactory); }} 和上一小节一样，通过FormattingConversionServiceFactoryBean注册进ioc容器 123456789&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt; &lt;!--将自定义的formatterRegistrar注入到该属性集合中--&gt; &lt;property name=&quot;formatterRegistrars&quot;&gt; &lt;set&gt; &lt;bean class=&quot;test.anno.MyDateFormatterRegistrar&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 或者也可以通过java代码配置 1234567891011@Beanpublic FormattingConversionService conversionService() { DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); MyDateFormatterRegistrar registrar = new MyDateFormatterRegistrar(); registrar.registerFormatters(conversionService); return conversionService;} 接下来只需要在需要用到的地方加上自定义的@MyDateFormat注解 12@MyDateFormatprivate Date Birthday; 然后在注入属性时就会自动调用MyDateFormatAnnotationFormatterFactory类的getParser方法获取解析器，然后进行解析了 1234&lt;!--注入属性--&gt;&lt;bean name=&quot;person&quot; class=&quot;test.anno.Person&quot;&gt; &lt;property name=&quot;birthday&quot; value=&quot;2000:7:7 7:7:7&quot;/&gt;&lt;/bean&gt;","link":"/2020/05/20/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%AA%8C%E8%AF%81/"},{"title":"Spring 核心功能：资源访问","text":"由于JDK提供的资源访问类并不能很好的满足底层资源的访问需求，所以Spring设计了一个Resource接口。Spring框架使用Resource装载各种资源，包括配置文件资源、国际化属性文件资源等 Resource 接口Resource位于org.springframework.core.io包中，用于抽象对低级资源的访问。 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Resource extends InputStreamSource { //此资源是否存在 boolean exists(); default boolean isReadable() { return this.exists(); } //当前是否能打开资源，比如如果已经被打开了就不能再次打开 default boolean isOpen() { return false; } default boolean isFile() { return false; } //资源实际的url URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; default ReadableByteChannel readableChannel() throws IOException { return Channels.newChannel(this.getInputStream()); } long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; @Nullable String getFilename(); //获取资源描述信息 String getDescription();} 它继承了InputStreamSource 接口 1234public interface InputStreamSource { //定位并打开资源，每次调用返回一个新的输入流 InputStream getInputStream() throws IOException;} Spring内部大量使用Resource，有如下内置实现： UrlResource ClassPathResource FileSystemResource PathResource ServletContextResource InputStreamResource ByteArrayResource 上面每种Resource的内置实现都支持将路径转化为 java.net.URL 1、UrlResourceUrlResource内部包装了一个类型为java.net.URL的url属性，它用来访问任何可以通过url访问的对象，通过标准化的字符串前缀来表示资源类型： file：用于访问文件系统路径； https：同于通过https协议访问资源； ftp：通过ftp访问资源； UrlResource是通过构造函数来创建的。通常会在调用api方法时隐式创建，此时PropertyEditor会根据前缀创建适当的资源，如果前缀不能识别，则会假定该前缀是个标准url字符串并创建一个UrlResource 2、ClassPathResourceClassPathResource类表示从类路径获取资源。使用线程上下文加载器和给定的加载器或给定的资源加载类进行加载。ClassPathResource支持将资源的类路径在文件系统中的资源解析为java.io.File。但不支持资源的类路径位于jar包中且没有拓展到文件系统中的资源，此时只能解析为 java.net.URL。通过构造函数创建ClassPathResource时会检查classpath:前缀，如果识别到了，就创建ClassPathResource 3、FileSystemResourceFileSystemResource类内部包装了java.io.File类，也支持java.nio.file.Path类，内部的方法都是通过File类的api方法实现的。解析路径一般可以使用绝对路径和相对路径，绝对路径是相对于文件系统的根目录，而相对路径是相对于当前工作目录，但FileSystemResource中无论开头有没有/，都将路径视为相对路径，，所以加与不加/没什么区别。如果确实需要使用绝对路径，应该避免使用FileSystemResource，或者使用file:前缀强制使用UrlResource 1ctx.getResource(&quot;file:/src/main/resources/test.properties&quot;); 4、PathResourcePathResource与FileSystemResource类似，但它内部是纯java.nio.file.Path实现的，通过Path类的api实现操作和转换 5、ServletContextResource这是ServletContext 资源的Resource实现，它解析web应用根目录中的相对路径。如果web应用程序被扩展并且资源位于文件系统上时，他始终支持流访问和url访问。它是否被扩展并在文件系统上或直接从 JAR 或其他地方（如数据库）访问实际上取决于 Servlet 容器 6、InputStreamResourceInputStreamResource 是给定 InputStream 的资源实现。仅当没有特定的资源实现适用时才应使用它。尽可能首选 ByteArrayResource 或任何基于文件的资源实现。与其他 Resource 实现相比，这是一个已打开资源的描述符。因此，它从 isOpen() 返回 true。如果您需要将资源描述符保存在某处或需要多次读取流，请不要使用它 7、ByteArrayResource这是给定字节数组的资源实现。它为给定的字节数组创建一个 ByteArrayInputStream ResourceLoader 接口ResourceLoader 接口用来返回Resource实例对象 12345678public interface ResourceLoader { String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;; Resource getResource(String location); @Nullable ClassLoader getClassLoader();} 所有应用程序上下文都实现了ResourceLoader接口，随意可以直接通过应用上下文你对象获取Resource实例 12ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;test.xml&quot;);Resource resource = ctx.getResource(&quot;test.properties&quot;); 不同上下文获取的resource类型不同 ClassPathXmlApplicationContext：ClassPathResource FileSystemXmlApplicationContext：FileSystemResource WebApplicationContext：ServletContextResource 可以通过指定前缀强制使用对应的Resource 前缀 例子 说明 classpath: classpath:com/myapp/config.xml 从类路径加载 file: file:///data/config.xml 从文件系统加载 https: https://myserver/logo.png 加载为url 无 /data/config.xml 取决于使用的ApplicationContext ResourcePatternResolver 接口1、接口说明ResourcePatternResolver接口是ResourceLoader接口的扩展接口它定义了将位置模式转化为Resource转化为Resource对象 12345public interface ResourcePatternResolver extends ResourceLoader { String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;; Resource[] getResources(String locationPattern) throws IOException;} 接口中定义了一个classpath*:资源前缀，并且getResources()方法返回的是一个Resource数组。 ApplicationContext 中默认的ResourceLoader 实际上是PathMatchingResourcePatternResolver 的一个实例。 1public class PathMatchingResourcePatternResolver implements ResourcePatternResolver {...} PathMatchingResourcePatternResolver是一个独立的实现，可在ApplicationContext外部使用，并且可以通过使用ResourceArrayPropertyEditor填充Resource[]的bean属性。PathMatchingResourcePatternResolver 能够将指定的资源位置路径解析为一个或多个匹配的资源对象。 资源路径可能是一对一的简单路径，也可能是包含classpath*:前缀内部 Ant 样式模式的特殊路径。 2、通配符【1】classpath* 前缀classpath* 前缀表示类路径中的JAR文件或不同目录可以包含多个同路径同名文件。也就是说classpath*:会搜索当前类路径和jar包中的类路径，而classpath:只会搜索当前项目的类路径。 1ctx.getResource(&quot;classpath*:conf/appContext.xml&quot;); 【2】Ant 风格当路径位置包含 Ant 样式模式时遵循最长匹配原则，并且可使用如下通配符 ?：匹配任意一个字符 *：匹配零个、一个、多个字符 **：匹配零个、一个、多个目录 补充： 当classpath*与Ant一起使用时，在模式开始之前，至少要与一个根目录匹配，否则只会查找文件系统。例如声明为classpath*:*.xml时可能不会从jar根目录中检索文件 ResourceLoaderAware 接口ResourceLoaderAware 接口用于将ResourceLoader保存到bean中 123public interface ResourceLoaderAware extends Aware { void setResourceLoader(ResourceLoader resourceLoader);} 当一个类实现ResourceLoaderAware接口并注册到容器中，在上下文启动时会自动调用setResourceLoader()方法，并将自己作为参数传递进去。也可以通过@Autowired进行注入，当路径包含classpath*:前缀时应优先使用@Autowired","link":"/2020/07/25/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"title":"Spring 核心功能：数据缓冲器和编解码器","text":"java的NIO提供了ByteBuffer，很多库基于ByteBuffer构建自己的缓冲区api。spring-core模块提供了一组抽象来处理字节缓冲区api： DataBufferFactory：创建抽象数据缓冲区 DataBuffer：字节缓冲区，可以被池化 DataBufferUtils：数据缓冲区的工具类 Codecs：将数据缓冲区流编码或解码为更高级别对象 DataBufferFactory1234567891011public interface DataBufferFactory { DataBuffer allocateBuffer(); DataBuffer allocateBuffer(int initialCapacity); DataBuffer wrap(ByteBuffer byteBuffer); DataBuffer wrap(byte[] bytes); DataBuffer join(List&lt;? extends DataBuffer&gt; dataBuffers);} 他又两个实现类DefaultDataBufferFactory和NettyDataBufferFactory。 DataBufferFactory有两种创建DataBuffer的方式 分配一个新的数据缓冲区，可以指定容量，也可按需增长或缩小 12345DefaultDataBufferFactory bufferFactory = new DefaultDataBufferFactory();//不指定大小，默认为256DefaultDataBuffer dataBuffer = bufferFactory.allocateBuffer();//指定缓冲区大小DefaultDataBuffer dataBuffer1 = bufferFactory.allocateBuffer(10); 包装现有的byte[]或java.nio.ByteBuffer，他使用DataBuffer装饰给定的数据，不会重新分配空间 123DefaultDataBufferFactory bufferFactory = new DefaultDataBufferFactory();byte[] bytes = new byte[]{};DefaultDataBuffer dataBuffer = bufferFactory.wrap(bytes); DataBufferDataBuffer提供了与Netty类似的操作，另外还包括以下功能 以独立的位置读取和写入，不需要flip()进行读写反复切换 自动扩容 通过PooledDataBuffer实现池化缓冲区和引用计数 将缓冲区视为java.nio.ByteBuffer、InputStream或OutputStream 对于给定的byte，确定其索引或最后的索引 PooledDataBuffer字节缓冲区可以是直接或非直接的。直接市值可以分配在java堆之外，这就节省了I/O的复制操作，但他们创建和释放的成本呢也很高，所以引入了池技术来解决这一问题。 PooledDataBuffer 是 DataBuffer 的扩展，使用引用计数方式管理资源的创建和释放。当分配 PooledDataBuffer 时，引用计数为 1。调用 retain() 增加计数，调用 release() 减少计数。只要计数大于0，就保证缓冲区不会被释放。当计数减少到 0 时，可以释放池化缓冲区，这实际上可能意味着为缓冲区保留的内存返回到内存池。 DataBufferUtils很多情况下，不推荐对PooledDataBuffer直接进行操作，最好使用DataBufferUtils 中的便捷方法，这些方法只在DataBuffer 是 PooledDataBuffer 的实例时才对 DataBuffer 应用释放或保留。DataBufferUtils提供了很多实用的方法来操作数据缓冲区 release(dataBuffer)：读取缓冲区并准备释放 join(dataBuffers)：将数据缓冲区流聚合到单个数据缓冲区中 Codecsorg.springframework.core.codec提供了以下接口 Encoder：编码器，将Publisher&lt;T&gt;成转换数据缓冲区流。 Decoder：解码器，将Publisher&lt;DataBuffer&gt;转换成更高级别的对象流。 spring-core提供了对byte[]、ByteBuffer、DataBuffer、Resource和 String编码器和解码器实现。spring-web模块添加了 Jackson JSON、Jackson Smile、JAXB2、Protocol Buffers 和其他编码器和解码器。","link":"/2020/06/01/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%99%A8%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"},{"title":"Spring 核心功能：面向切面编程（AOP）","text":"Spring AOP 是spring提供的一种AOP实现，目的不是提供最完整的 AOP 实现，而是提供 AOP 实现和Spring IOC之间的紧密集成。如果需要使用全面的AOP解决方案可以使用AspectJ。Spring IOC和Spring AOP可以与AspectJ无缝集成。另外Spring可以使用@AspectJ注解和模式两种方式配置AOP AOP概念AOP术语Advice（通知）：将要增加的功能，是织入到目标类连接点上的一段程序代码； Pointcut（切入点）：需要增强的方法集，可能包括多个连接点； Aspect（切面）：通知与切入点的结合； Join point（连接点）：使用通知的地方，spring中指方法的执行； introduction（引入）：引入是一种特殊的通知，它为类添加一些属性和方法； Target object（目标对象）：增强逻辑的织入目标类； AOP proxy（代理）：一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类； Weaving（织入）：把通知应用到目标对象来创建新的代理对象的过程； spring 通知类型 前置通知：连接点之前执行 返回通知：连接点正常执行完毕后（没有异常发生） 异常通知：方法抛出异常退出时执行 后置通知：无论连接点退出后执行（无论是异常还是返回），相当于finally 环绕通知：自定义通知，提供了全方位功能的通知类型 注解方式和xml文件形式通知的执行顺序不同，注解方式环绕通知是在外层，而xml方式的环绕通知在内层。上面只有返回通知没有异常通知是因为环绕通知里写了try-catch 注解通知的执行顺序为： 环绕前置 前置通知 连接点方法 返回通知/异常通知 后置通知 环绕返回/环绕异常 环绕后置 xml配置通知的执行顺序为： 前置通知 环绕前置 连接点方法 环绕返回/环绕异常 环绕后置 后置通知 返回通知/异常通知 基于注解配置AOP引入依赖Maven 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt; Gradle 1todo 启动@AspectJ支持@AspectJ是AspectJ 5的一部分，Spring使用AspectJ提供的用于切入点解析和匹配的库来解释与AspectJ 5相同的注释。不过，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ Java 配置添加@EnableAspectJAutoProxy 注释 12345@Configuration@EnableAspectJAutoProxypublic class AppConfig {} XML 配置1&lt;aop:aspectj-autoproxy/&gt; 需要在 &lt;beans&gt;中加入 12345678910111213141516&lt;!--必须包含--&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;!--完整配置如下--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 相关注解 @Aspect：声明切面 @Pointcut：声明切入点参数是一个切入点表达式 @DeclareParents：声明引入（introduction） @Before：前置通知 @AfterReturning：返回通知 @AfterThrowing：异常通知 @After：后置通知 @Around：环绕通知 @Pointcut内部接切入点表达式，advice的相关通知注解可以直接写切入点表达式，也可以时对命名切入点的简单引用（切入点方法的全限定名），每个通知都可以注入参数，具体可以看注解的声明，示例代码中会进行演示 切入点表达式切入点表达式中可以使用以下指示符： execution：用于匹配方法，格式如下 1execution([访问修饰符] 返回值类型 [类型].方法名称(参数类型列表) [抛出异常模式]) within：用于匹配指定的类的所有方法 1within(类型) this：this指代理对象，匹配指定类型的子代理对象类的所有方法 1this(类型) target：target指目标对象，匹配指定类型的子类（非代理类）的所有方法 1target(类型) args：用于匹配指定参数列表方法 1args(参数类型/参数名称) @within：用于匹配标记指定注解的类型的所有方法 1@within(注解类型) @target：用于匹配持有指定注解的对象的所有方法 1@target(注解类型) @args：匹配运行时传入的参数的类型持有指定注解的方法 1@args(注解类型列表) @annotation：匹配持有指定注解的方法 1@args(注解类型) 多个切入点表达式之间可使用以下操作符： &amp;&amp; || ! 切入点表达式通配符： *：匹配任何数量字符。*在参数中表示一个任意类型的参数； ..：匹配任何数量字符的多个部分。在类型中表示匹配任何数量子包；(..)可以匹配任意个参数的方法； +：匹配指定类型的子类型，仅能作为后缀放在类型模式后边； 切入点对象在任何使用通知注解标记的方法上可以直接将JoinPoint、ProceedingJoinPoint、JoinPoint.StaticPart作为参数注入。通过切入点对象可以获取aop相关的对象，用法如下 1234567891011@Before(value = &quot;pointCut(p1,p2)&quot;)public void doBefore(JoinPoint jp,Object bean,String p2,String p1) { //获取方法参数 Object[] args = jp.getArgs(); //获取代理对象 Object aThis = jp.getThis(); //获取目标对象 Object target = jp.getTarget(); //获取方法通知的描述信息 Signature signature = jp.getSignature();} 绑定参数args()切入点表达式有两个目的，其一是限制方法的参数列表，二是当使用参数名称代替参数类型时，声明的参数列表中的参数可以传递到通知方法中 12@Pointcut(value = &quot;execution(* test.aop.Cat.cry(String,String)) &amp;&amp; args(p1,p2)&quot;)private void pointCut(String p1,String p2) {...} 代理对象 ( this)、目标对象 ( target) 和注释 ( @within、 @target、@annotation和@args) 都可以以类似的方式绑定，只不过他们绑定的参数不是目标方法参数，而是他们对应的对象，比this就是代理对象。另外切入点对象直接作为参数即可不需要特别配置 12@Around(value = &quot;test.aop.MyAspect.pointCut(p1,p2) &amp;&amp; this(proxy) &amp;&amp; @annotation(myAuditable)&quot;)public void doAround(ProceedingJoinPoint pjp, String p1, String p2, Object proxy, Auditable myAuditable) throws Throwable {...} argNames属性用来指定参数的顺序，如果不使用这个属性，参数可以随意放置，只要名字和通知声明的一样就可以匹配到。如果使用这个属性，那么参数就必须和该属性声明的顺序一致 12@Before(value = &quot;pointCut(p1,p2) &amp;&amp; target(bean) &quot;,argNames = &quot;jp,bean,p2,p1&quot;)public void doBefore(JoinPoint jp,Object bean,String p2,String p1) {...} 声明引入使用@DeclareParents声明引入 1234567891011@Retention(RetentionPolicy.RUNTIME)//作用在字段上@Target({ElementType.FIELD})public @interface DeclareParents { //类型模式 String value(); //接口的实现类 Class defaultImpl() default DeclareParents.class;} 他作用在一个字段上，这个字段需要是一个接口，注解内部的defaultImpl时该接口的一个实现类 123456789101112131415@Aspectpublic class UsageTracking { //value中是却如点的类型 //DefaultMyInterface是MyInterface的子类 @DeclareParents(value=&quot;test.aop.*+&quot;, defaultImpl=DefaultMyInterface.class) //MyInterface是自定义接口 public static MyInterface mixin; @Before(&quot;com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)&quot;) public void recordUsage(UsageTracked usageTracked) { usageTracked.incrementUseCount(); }} 示例代码被代理类 12345678910111213@Componentpublic class Cat{ private String name; @Auditable(&quot;注解value&quot;) public String cry(String p1,String p2){ System.out.println(&quot;喵喵叫&quot;); if(p1.length()&gt;0){ throw new RuntimeException(&quot;出现异常&quot;); } return p1+&quot;:&quot;+p2; }} 自定义注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable { String value();} 切面编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//声明切面@Aspect//注入ioc容器@Componentpublic class MyAspect { //切入点 @Pointcut(value = &quot;execution(* test.aop.Cat.cry(String,String)) &amp;&amp; args(p1,p2)&quot;) private void pointCut(String p1,String p2) { } //前置通知 @Before(value = &quot;pointCut(p1,p2) &amp;&amp; target(bean) &quot;,argNames = &quot;jp,bean,p2,p1&quot;) public void doBefore(JoinPoint jp,Object bean,String p2,String p1) { //获取方法参数 Object[] args = jp.getArgs(); //获取代理对象 Object aThis = jp.getThis(); //获取目标对象 Object target = jp.getTarget(); //获取方法通知的描述信息 Signature signature = jp.getSignature(); System.out.println(&quot;前置通知-&gt;参数为：p1=&quot;+p1+&quot;,p2=&quot;+p2); } //返回通知 @AfterReturning( value = &quot;test.aop.MyAspect.pointCut(p1,p2)&quot;, returning = &quot;retVal&quot;) public void doReturn(Object retVal,String p1,String p2) { System.out.println(&quot;返回通知-&gt;返回值为：&quot; + retVal); } //异常通知 @AfterThrowing( value = &quot;test.aop.MyAspect.pointCut(p1,p2)&quot;, throwing = &quot;ex&quot;) public void doThrowing(Exception ex,String p1,String p2) { System.out.println(&quot;异常通知-&gt;异常为：&quot; + ex); } //后置通知 @After(&quot;test.aop.MyAspect.pointCut(p1,p2)&quot;) public void doAfter(String p1,String p2) { System.out.println(&quot;后置通知&quot;); } //环绕通知 @Around(value = &quot;test.aop.MyAspect.pointCut(p1,p2) &amp;&amp; this(proxy) &amp;&amp; @annotation(myAuditable)&quot;) public void doAround(ProceedingJoinPoint pjp, String p1, String p2, Object proxy, Auditable myAuditable) throws Throwable { //注释的value String value = myAuditable.value(); try { System.out.println(&quot;环绕前置&quot;); Object retVal = pjp.proceed(); System.out.println(&quot;环绕返回-&gt;返回值为：&quot; + retVal); }catch (Exception e){ System.out.println(&quot;环绕异常-&gt;异常为：&quot; + e); }finally { System.out.println(&quot;环绕后置&quot;); } }} 执行结果 123456789101112131415环绕前置前置通知-&gt;参数为：p1=参数1,p2=参数2喵喵叫返回通知-&gt;返回值为：参数1参数2后置通知环绕返回-&gt;返回值为：参数1参数2环绕后置 环绕前置前置通知-&gt;参数为：p1=参数1,p2=参数2喵喵叫异常通知-&gt;异常为：java.lang.RuntimeException: 出现异常后置通知环绕异常-&gt;发生异常：java.lang.RuntimeException: 出现异常环绕后置 通知的执行顺序为： 环绕前置 前置通知 连接点方法 返回通知/异常通知 后置通知 环绕返回/环绕异常 环绕后置 基于xml配置AOP基于模式就是基于xml标签的形式配置aop 引入依赖123456&lt;!--springIOC的包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 启动aop支持如论是使用模板形式还是使用注解形式都需要引入aop命名空间 12345678910111213141516&lt;!--必须包含--&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;!--完整配置如下--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 相关配置 &lt;aop:config&gt;：所有切面和通知的配置都要放在&lt;aop:config&gt;标签内 &lt;aop:pointcut&gt;：声明切入点，可以声明在&lt;aop:config&gt;和&lt;aop:aspect&gt;中 &lt;aop:aspect&gt;：声明切面， ref：表示引入的切面bean order：当有多个通知指向一个连接点时通过order指定执行顺序，值越小越先执行 关于切入点表达式等查看上一节相关部分。关于每个标签用法查看下一节的示例代码 通知标签属性所有通知标签的公共属性如下： method：通知方法 pointcut-ref：引用已声明切入点id pointcut：内联切入点表达式，不能与pointcut-ref一起使用 arg-names：同argNames，定义参数顺序 通知标签特殊属性如下： &lt;aop:before&gt;：前置通知 &lt;aop:after-returning&gt;：返回通知 returning：返回值参数名，通知方法必须声明一个为该名称的参数 &lt;aop:after-throwing&gt;：异常通知 throwing：异常参数名，通知方法必须声明一个为该名称的参数 &lt;aop:after&gt;：后置通知 &lt;aop:around&gt;：环绕通知，通知方法的第一个参数必须是ProceedingJoinPoint 另外&lt;aop:after-throwing&gt;和&lt;aop:after-throwing&gt;分别有和用于声明异常和返回值参数名 声明引入使用&lt;aop:declare-parents&gt;声明引入 12345&lt;aop:declare-parents types-matching=&quot;类型模式&quot; implement-interface=&quot;接口&quot; default-impl=&quot;接口实现&quot; delegate-ref=&quot;属性名称&quot;/&gt; advisor通过&lt;aop:advisor&gt;声明advisor，这是xml配置所独有的。advisor相当于一个独立的切面，只有一条通知。其属性包括 pointcut-ref：切入点引用 pointcut：切入点表达式 advice-ref：通知引用 order：定义Ordered值，越小优先级越高 12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id=&quot;businessService&quot; expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt; &lt;aop:advisor pointcut-ref=&quot;businessService&quot; advice-ref=&quot;tx-advice&quot;/&gt;&lt;/aop:config&gt;&lt;tx:advice id=&quot;tx-advice&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 示例代码被代理类 12345678910111213@Componentpublic class Cat{ private String name; @Auditable(&quot;注解value&quot;) public String cry(String p1,String p2){ System.out.println(&quot;喵喵叫&quot;); if(p1.length()&gt;0){ throw new RuntimeException(&quot;出现异常&quot;); } return p1+&quot;:&quot;+p2; }} 自定义注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable { String value();} 切面代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyAspect { //前置通知 public void doBefore(JoinPoint jp,Object bean,String p2,String p1) { //获取方法参数 Object[] args = jp.getArgs(); //获取代理对象 Object aThis = jp.getThis(); //获取目标对象 Object target = jp.getTarget(); //获取方法通知的描述信息 Signature signature = jp.getSignature(); System.out.println(&quot;前置通知-&gt;参数为：p1=&quot;+p1+&quot;,p2=&quot;+p2); } //返回通知 public void doReturn(Object retVal,String p1,String p2) { System.out.println(&quot;返回通知-&gt;返回值为：&quot; + retVal); } //异常通知 public void doThrowing(Exception ex,String p1,String p2) { System.out.println(&quot;异常通知-&gt;异常为：&quot; + ex); } //后置通知 public void doAfter(String p1,String p2) { System.out.println(&quot;后置通知&quot;); } //环绕通知 public void doAround(ProceedingJoinPoint pjp, String p1, String p2, Object proxy, Auditable myAuditable) throws Throwable { //注释的value String value = myAuditable.value(); try { System.out.println(&quot;环绕前置&quot;); Object retVal = pjp.proceed(); System.out.println(&quot;环绕返回-&gt;返回值为：&quot; + retVal); }catch (Exception e){ System.out.println(&quot;环绕异常-&gt;发生异常：&quot; + e); }finally { System.out.println(&quot;环绕后置&quot;); } }} xml配置 12345678910111213141516171819&lt;!--切面类--&gt;&lt;bean id=&quot;myAspectBean&quot; class=&quot;test.aop.MyAspect&quot;/&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;myPointCut&quot; expression=&quot;execution(* test.aop.Cat.cry(String,String)) and args(p1,p2)&quot;/&gt; &lt;!--切面--&gt; &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;myAspectBean&quot;&gt; &lt;!--前置通知--&gt; &lt;aop:before method=&quot;doBefore&quot; pointcut=&quot;execution(* test.aop.Cat.cry(String,String)) and args(p1,p2) and target(bean)&quot; arg-names=&quot;jp,bean,p2,p1&quot;/&gt; &lt;!--返回通知--&gt; &lt;aop:after-returning method=&quot;doReturn&quot; pointcut-ref=&quot;myPointCut&quot; returning=&quot;retVal&quot;/&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method=&quot;doThrowing&quot; pointcut-ref=&quot;myPointCut&quot; throwing=&quot;ex&quot;/&gt; &lt;!--后置通知--&gt; &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;myPointCut&quot;/&gt; &lt;!--环绕通知--&gt; &lt;aop:around method=&quot;doAround&quot; pointcut=&quot;execution(* test.aop.Cat.cry(String,String)) and args(p1,p2) and this(proxy) and @annotation(myAuditable)&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 执行结果 123456789101112131415前置通知-&gt;参数为：p1=参数1,p2=参数2环绕前置喵喵叫环绕异常-&gt;发生异常：java.lang.RuntimeException: 出现异常环绕后置后置通知返回通知-&gt;返回值为：null前置通知-&gt;参数为：p1=参数1,p2=参数2环绕前置喵喵叫环绕返回-&gt;返回值为：参数1参数2环绕后置后置通知返回通知-&gt;返回值为：null 通知的执行顺序为： 前置通知 环绕前置 连接点方法 环绕返回/环绕异常 环绕后置 后置通知 返回通知/异常通知 代理机制spring aop使用jdk和cglib两种方式实现动态代理，如果目标对象至少实现了一个接口，则使用jdk代理，如果类没有实现任何接口，则使用cglib代理。可以使用如下配置强行使用cglib代理 123456&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;!-- other beans defined here... --&gt;&lt;/aop:config&gt;&lt;!--要在使用 @AspectJ 自动代理支持时强制 CGLIB 代理--&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; 说明： 使用cglib，方法不能被final修饰，因为生成的子类无法覆盖该方法 方法自调在被代理方法中如果调用类内其他方法，那么被调用方法不是被代理的，这叫做自调。如果希望解决自调，可以通过更改被代理类代码的方式 123this.方法()//改为((被代理类) AopContext.currentProxy()).方法(); 创建代理&lt;aop:config&gt;方式123456789101112//创建代理工厂ProxyFactory factory = new ProxyFactory(new target());//添加被代理类实现接口factory.addInterface(targetUInterface.class);//添加通知factory.addAdvice(new myAdvice());//设置被代理类方法内部调用代理factory.setExposeProxy(true);//获取代理对象Pojo pojo = (target) factory.getProxy();//调用方法代理pojo.theMethod(); &lt;aop:aspectj-autoproxy&gt;方式12345678910//创建根据给定的targetObject创建代理的工厂AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);//添加一个被@AspectJ修饰的切面factory.addAspect(SecurityManager.class);//也可以添加切面的实例factory.addAspect(usageTracker);//获取代理对象MyInterfaceType proxy = factory.getProxy(); 事务使用@Transactional注解可以开启事务，底层是通过aop代理实现的 可以声明在类上和方法上 声明在类上表示该类的任何公共操作都使用事务 声明在方法上会覆盖声明在类上的事务语义 使用 AspectJtode Spring AOP API切入点核心接口切入点的核心接口如下 12345678910111213141516171819202122232425262728293031323334public interface Pointcut { Pointcut TRUE = TruePointcut.INSTANCE; //匹配部分 ClassFilter getClassFilter(); //细粒度组合操作 MethodMatcher getMethodMatcher();}//用于将切入点限制为给定的一组目标类@FunctionalInterfacepublic interface ClassFilter { ClassFilter TRUE = TrueClassFilter.INSTANCE; //如果该matches()方法始终返回 true，则所有目标类都匹配 boolean matches(Class&lt;?&gt; clazz);}public interface MethodMatcher { MethodMatcher TRUE = TrueMethodMatcher.INSTANCE; //用于测试此切入点是否曾经匹配目标类上的给定方法，可以在创建aop代理时评估 boolean matches(Method method, Class&lt;?&gt; targetClass); //如果MethodMatcher实现时静态的，则返回false boolean isRuntime(); //如果双参数匹配方法返回 true，isRuntime()方法返回true， //则在每次方法调用时都会调用三参数匹配方， //这让切入点在目标通知开始之前立即查看传递给方法调用的参数 boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args);} tode","link":"/2020/03/18/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%88AOP%EF%BC%89/"},{"title":"Spring 注解：@ControllerAdvice","text":"@ControllerAdvice 是 Spring3.2 提供的新注解，用来修饰一个类，在 Spring Boot 中可以搭配其他三个注解（@ExceptionHandler、@ModelAttribute、@InitBinder）使用。 可以用来实现以下几个功能： 全局异常处理 全局数据绑定 全局数据预处理 全局异常处理（@ExceptionHandler）12345678910@ControllerAdvicepublic class MyGlobalHandler { @ExceptionHandler(Exception.class) public ModelAndView customException(Exception e) { ModelAndView mv = new ModelAndView(); mv.addObject(&quot;message&quot;, e.getMessage()); mv.setViewName(&quot;myerror&quot;); return mv; }} 在该类中，可以创建多个方法，每个方法上添加@ExceptionHandler注解，参数填入异常的类型，这样就可以实现不同异常的全局处理。 全局数据绑定（@ModelAttribute）123456789@ControllerAdvicepublic class MyGlobalHandler { @ModelAttribute(name = &quot;keyName&quot;) public Map&lt;String,Object&gt; mydata() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;张三&quot;); return map; }} 被 @ModelAttribute 注解所标记方法的返回值是一个全局数据，可以在全局的其他地方获取到，默认全局数据的 key 就是返回的变量名，value 是方法返回值，如果想自定义key可以通过 @ModelAttribute 的name属性指定。 定义完成后，在任何一个Controller 的接口中，都可以获取到上面定义的数据： 123456789@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(Model model) { Map&lt;String, Object&gt; map = model.asMap(); System.out.println(map); return &quot;hello controller advice&quot;; }} 全局数据预处理（@InitBinder）在进行开发时前台发送请求到后台时经常会遇到的一种情况就是传过来的数据要组装成一种对象的格式，@InitBinder 注解可以对HTTP请求参数进行预处理，再绑定到对应的接口。这里我们就可以对参数做一些额外的处理，比如时间格式的转换等。 123456789@ControllerAdvicepublic class MyGlobalHandler { @InitBinder public void bindingPreparation(WebDataBinder binder) { DateFormat dateFormat = new SimpleDateFormat(&quot;MMM d, YYYY&quot;); CustomDateEditor orderDateEditor = new CustomDateEditor(dateFormat, true); binder.registerCustomEditor(Date.class, orderDateEditor); } } 对于request传递的简单数据类型（String、int、float等）springmvc可以自动的进行属性绑定，但复杂类型的却不行，WebDataBinder类可以用来绑定数据与属性解析器（PropertiesEditor），实现复杂属性的绑定。上述代码中的CustomDateEditor就是一个PropertiesEditor用于解析Date类型的数据。 当需要实现不同的实体类中要求的Date格式不同的需求时，可以如下配置： 123456789@InitBinder public void bindingPreparation(WebDataBinder binder) { DateFormat dateFormat1 = new SimpleDateFormat(&quot;d-MM-yyyy&quot;); CustomDateEditor orderDateEditor = new CustomDateEditor(dateFormat1, true); DateFormat dateFormat2 = new SimpleDateFormat(&quot;MMM d, YYYY&quot;); CustomDateEditor shipDateEditor = new CustomDateEditor(dateFormat2, true); binder.registerCustomEditor(Date.class, &quot;orderDate&quot;, orderDateEditor); binder.registerCustomEditor(Date.class, &quot;shipDate&quot;, shipDateEditor); } 只要为每个变量绑定一个不同的Editor就可以了，对于不同的变量进行不同的处理。","link":"/2021/04/24/%E6%A1%86%E6%9E%B6/Java/Spring/Spring%E6%B3%A8%E8%A7%A3%EF%BC%9A@ControllerAdvice/"},{"title":"Scrapy 基础知识","text":"介绍scrapy框架核心租价、基本命令、代码编写、以及各个组件的执行顺序 Scrapy 基础知识常用命令如果没有安装过scrapy应先执行 1$ pip install scrapy 创建爬虫工程该命令会在spiders下新建爬虫文件 1$ scrapy startproject 工程名 举例： 1$ scrapy genspider bilibili_test 创建爬虫文件该命令会在spiders下新建爬虫文件 1$ scrapy genspider 爬虫文件名 目标网站 举例： 1$ scrapy genspider bilibili www.bilibili.com 执行爬虫该命令会在spiders下新建爬虫文件 1$ scrapy crawl 爬虫文件名(不需要后缀) 参数： **–nolog:**不输出日志 **-o:**将parse()方法的返回值存储到指定输出文件，可以选择下列文件格式： csv json xml jl jsonlines marshal pickle 举例： 1$ scrapy crawl bilibili 项目结构创建爬虫工程后得到目录结构如下; 1234567891011- 工程名: spiders: #爬虫文件目录 __init__.py 爬虫文件.py #爬虫网站数据以及数据解析逻辑，将数据封装成item __init__.py items.py #数据封装对象 middlewares.py pipelines.py #管道，用于处理item类型对象，进行持久化 settings.py #爬虫配置- main.py- scrapy.cfg 项目包含的py文件中初始化了对应的类，在这些类中实现重写相应方法的逻辑代码，scrapy会按照顺序调用这些方法 核心组件 上面组件包括： 引擎(Scrapy Engine)：用来处理整个系统的数据流处理, 触发事务(框架核心)； 调度器(Scheduler)：用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址； 下载器(Downloader)：用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)； 爬虫(Spiders)：爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面； 项目管道(Pipeline)：负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据； 代码编写代码编写流程如下: 编写item用于封装解析到的数据； 编写spider用于指定访问的url和解析请求到的数据并将数据封装成item对象； 编写pipeline用于对item进行处理，一般是持久化； 编写middleware，一般用于配置代理以及user-agent等； 数据封装对象根据自身需求定义item类，封装需要的数据 下面例子是将文章封面图的link以及文章的title封装成item 12345678910# 封装文章数据class ArticleItem(scrapy.Item): # 属性的定义方式如下: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field()# 封装文章图片地址class ArticleImageItem(scrapy.Item): src = scrapy.Field() 爬虫文件爬虫文件中定义了将要请求的url以及页面数据的解析逻辑 下面是用于爬取b站某页专栏的代码，省略了解析表达式和网址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class BilibiliSpider(scrapy.Spider): name = 'bilibili' allowed_domains = ['www.bilibili.com'] # url方式一：初始请求数组 # start_urls = ['https://www.xxx.com/xxx'] # url方式二：start_requests()方法发起请求 def start_requests(self): print('Spider--start_requests()') # 爬取多页数据 for page in range(1, 2): print('Spider--start_requests()--for') # 手动发起请求，每次请求一个url，使用模板字符串拼接页数 yield scrapy.Request(f'https://search.bilibili.com/article?vt=67519417&amp;keyword=%E5%A4%8F%E6%97%A5%E9%87%8D%E7%8E%B0&amp;from_source=webtop_search&amp;spm_id_from=333.1007&amp;search_source=2&amp;page={page}') def parse(self, response: HtmlResponse): print('Spider--parse()') list_items = response.css('body &gt; #server-search-app .body-contain .article-item') for list_item in list_items: article_item = ArticleItem() # css()和xpath()方法返回的是selector列表 # extract()方法将selector列表解析成字符串列表 # extract_first()方法将selector列表中第一个数据解析成字符串并返回该字符串 article_item['link'] = list_item.css('a img::attr(src)').extract_first() article_item['title'] = list_item.css('.content &gt;.headline&gt;a::attr(title)').extract_first() article_url = &quot;https:&quot; + list_item.css('.content &gt;.headline &gt; a::attr(href)').extract_first() print('Spider--parse()--for') # 将article_item信息发送到管道 yield article_item # 调用parse_article()方法解析详细信息 # 请求传惨：通过meta参数传递一个map，目标方法可以接收 yield scrapy.Request(article_url, self.parse_article_image, meta={'article_item': article_item}) # 自定义解析文章详情页的方法，用于提取图片 def parse_article_image(self, response): # 获取传递的参数 article_item = response.meta['article_item'] print(f&quot;获取文章《{article_item['title']}》的图片&quot;) figure_list = response.css('#article-content &gt; #read-article-holder figure') for figure_item in figure_list: image_url = &quot;https:&quot; + figure_item.css('::attr(data-src)').extract_first() image_item = ArticleImageItem() image_item['src'] = image_url yield image_item 管道需要先配置开启管道 1234567# 开启管道# 可以配置任意个管道类，会按照优先级从小到大进行执行ITEM_PIPELINES = { # 管道类全类名: 优先级 'bilibili_test.pipelines.MysqlPipeline': 300, 'bilibili_test.pipelines.ArticleImagePipeline': 301,} 下面定义了两个管道： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 将文章信息存储到mysql数据库class MysqlPipeline: # 数据库连接 conn = None # 数据库游标多谢 cursor = None # 该方法会在爬虫开始时被调用并且只会被调用一次 def open_spider(self, spider): print('mysql管道--open_spider()') self.conn = pymysql.Connect( host='127.0.0.1', port=3306, user='root', password='123456', db='scrapy_test', charset='utf8', ) # 接收爬虫文件传递过来的item对象 def process_item(self, item: ArticleItem, spider): print('mysql管道--process_item()') if not isinstance(item, ArticleItem): # 如果不是需要的类型，直接发送到下一个管道 return item # 写入文件 self.cursor = self.conn.cursor() # 插入到mysql try: self.cursor.execute('insert into article(title,link) values(&quot;%s&quot;,&quot;%s&quot;)' % (item[&quot;title&quot;], item[&quot;link&quot;])) self.conn.commit() except Exception as e: print(e) self.conn.rollback() return item # 爬虫结束后会调用一次 def close_spider(self, spider): print('mysql管道--close_spider()') self.conn.close()# 声明父类是ImagesPipeline# ImagesPipeline是scrapy提供的专门用于图片存储的管道类class ArticleImagePipeline(ImagesPipeline): # 根据图片地址进行图片数据的请求 def get_media_requests(self, item, info): print('图片下载管道--get_media_requests()') if not isinstance(item, ArticleImageItem): # 如果不是需要的类型，直接发送到下一个管道 return item # 获取图片 yield scrapy.Request(item['src']) # 指定文件存储位置 def file_path(self, request, response=None, info=None, *, item=None): print('图片下载管道--file_path()') imageName = request.url.split('/')[-1] return imageName # 用于该管道执行结束向下一个将要执行的管道传递数据 # 如果不需要传递数据，则这个方法可以不重写 def item_completed(self, results, item, info): print('图片下载管道--item_completed()') # 把当前的item传递给下一个管道类 return item 中间件需要先配置开启管道 123456789# 开启爬虫中间件SPIDER_MIDDLEWARES = { 'bilibili_test.middlewares.BilibiliTestSpiderMiddleware': 543,}# 开启下载中间件DOWNLOADER_MIDDLEWARES = { 'bilibili_test.middlewares.BilibiliTestDownloaderMiddleware': 543,} 中间件有两个 爬虫中间件 下载中间件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192proxy_ip_list = [ '47.92.113.71:80', '117.157.197.18:3128', '111.23.16.250:3128',]user_agent_list = [ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot; # ......]# 爬虫中间件class BilibiliTestSpiderMiddleware: @classmethod def from_crawler(cls, crawler): print('爬虫中间件--from_crawler()') s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_spider_input(self, response, spider): print('爬虫中间件--process_spider_input()') # 返回None或一个异常 # 如果是None,就继续调用其他的spider middleware。 # 如果是一个异常，调用request里的errback()方法，再抛出异常是交给process_spider_exception(response, exception, spider)处理 return None def process_spider_output(self, response, result, spider): print('爬虫中间件--process_spider_output()') # 必须返回一个包括request或item对象的可迭代对象 for i in result: yield i # 当spider或其他中间件的process_spider_input()报错时被调用 def process_spider_exception(self, response, exception, spider): print('爬虫中间件--process_spider_exception()') # 应该返回 None 或一个可迭代的 Request 或 item 对象 pass # 爬虫启动请求 def process_start_requests(self, start_requests, spider): print('爬虫中间件--process_start_requests()') # 只能返回request对象 for r in start_requests: yield r def spider_opened(self, spider): print('爬虫中间件--spider_opened()') spider.logger.info('Spider opened: %s' % spider.name)# 下载中间件class BilibiliTestDownloaderMiddleware: @classmethod def from_crawler(cls, crawler): # Scrapy 使用此方法来创建爬虫 print('下载中间件--from_crawler()') s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s # 拦截请求，当每个request通过下载中间件时，该方法被调用 def process_request(self, request, spider): print('下载中间件--process_request()') # 随机选择user-agent ua = random.choice(user_agent_list) # 设置请求的ua request.headers['User-Agent'] = ua return None # 拦截响应， def process_response(self, request, response, spider): print('下载中间件--process_response()') return response # 拦截发生异常的请求 def process_exception(self, request, exception, spider): print('下载中间件--process_exception()') # 请求失败就设置代理ip if request.url.split(':') == 'https': # 设置代理ip request.meta['proxy'] = 'https//' + random.choice(proxy_ip_list) else: request.meta['proxy'] = 'http//' + random.choice(proxy_ip_list) # 返回request会重新进行请求发送 return request def spider_opened(self, spider): print('下载中间件--spider_opened()') spider.logger.info('Spider opened: %s' % spider.name) 执行顺序下面的爬虫中间件和下载中间件均的优先级相同；下列执行步骤中如果定义了多个管道，则会按照设置的优先值从小到大执行，并且位置是相邻的 初始化执行部分： 下载中间件–from_crawler() 爬虫中间件–from_crawler() 管道–open_spider() 下载中间件–spider_opened() 爬虫中间件–spider_opened() 爬虫开始部部分： 爬虫中间件–process_start_requests() Spider--start_requests() Spider--start_requests()--for 下载中间件–process_request() 下载中间件–process_response() 爬虫中间件–process_spider_input() 爬虫中间件–process_spider_output() Spider--parse() Spider--parse()--for 管道process_item() Spider--parse()--for 管道–process_item() 下载中间件–process_request()（调用scrapy.Request()触发该方法） Spider--parse()--for ……","link":"/2022/09/24/%E6%A1%86%E6%9E%B6/Python/Scrapy/Scrapy%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"Spring MVC 参数绑定","text":"SpringMVC 中前台发送的请求会被转发到对应的controller中相匹配的方法上，SpringMVC提供了多种参数绑定机制使得可以将参数直接绑定到方法参数 默认参数类型有些类型的参数只需要在controller中方法的形参列表中声明，SpringMVC 就会自动绑定，不需要其他额外操作，如： HttpServletRequest HttpServletResponse HttpSession Model/ModelMap 测试代码如下： 123456789101112131415@RequestMapping(path = &quot;/default&quot;,method = RequestMethod.GET)public String bindParam(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model, ModelMap modelMap){ System.out.println(request); System.out.println(response); System.out.println(session); System.out.println(model); System.out.println(modelMap); return &quot;&quot;;} 使用get发送请求，根据debug得到结果可以看到参数均被获取到 基本数据类型基本数据类型包括 byte、short、int、long、float、double、char、boolean。在参数是基本数据类型并且请求参数名称和方法参数名称相同时 SpringMVC 也会自动绑定，如果不同可以使用 @RequestParam注解和@PathVariable注解。 @RequestParam 注解 作用： 相当于request.getParameter(请求参数中的key) 将获取的值绑定到该注解修饰中的参数中 无论是请求体里的参数还是url上的参数@RequestParam 注解都能匹配 url请求格式：请求路径?param1=1&amp;param2=2 无法解析json类型，只能用String类型接收 属性： value：请求参数中的key required：true/false，表示该URL是否必须要带有该参数，默认是true default：如果required设置为true，但是URL中没有指定的key，则默认取该值进行参数绑定 测试代码如下： 12345678@RequestMapping(path = &quot;/basic&quot;,method = RequestMethod.POST)public String basic(int intValue,long longValue,char charValue,boolean boolValue){ System.out.println(intValue); System.out.println(longValue); System.out.println(charValue); System.out.println(boolValue); return &quot;&quot;;} 使用post请求发送请求，从结果中可以看出，参数被自动绑定了，值得注意的是boolean类型的参数如果缺少会自动置为false，其他类型则会报错，这是因为如果没有传值的话会默认赋值为null，但基本数据类型不能为null。 当请求参数与方法参数名不同时 12345@RequestMapping(path = &quot;/basic&quot;,method = RequestMethod.POST)public String basic(int intValue1){ System.out.println(intValue1); return &quot;&quot;;} 此时程序报错 加入 @RequestParam 注解后参数绑定成功，此时如果缺少请求参数也会抛出异常 @PathVariable注解 作用： 解析url上携带的参数，请求格式：请求路径/{param} 属性： name：参数的key value：同name required：是否必须，同@RequestParam 测试代码如下： 12345678@GetMapping(path = &quot;/PathVariable/{id}&quot;)public String testPath(@PathVariable(name = &quot;id&quot;) int a){ System.out.println(a); return &quot;&quot;;}//请求http://localhost:8080/PathVariable/3 结果： 包装类型包装类型包括Integer、Long、Byte、Double、Float、Short，（String 类型在这也是适用），与基本数据类型的绑定基本一致，唯一不同的是包装类的数据如果缺少请求参数不会抛出异常，而会置为默认值null。 实体类SpringMVC会将参数自动注入到实体类中，对于嵌套实体类可以通过”属性名.内部对象属性名”的方式绑定。 测试代码如下： 1234567//实体类@Datapublic class User { private String name; private int age; private boolean sex;} 123456//controller方法@RequestMapping(path = &quot;/pojo&quot;,method = RequestMethod.POST)public String pojo(User user){ System.out.println(user); return &quot;&quot;;} 发送请求，可以看到只要请求参数和而实体类的属性名称相同就可以绑定成功，而缺少请求参数的属性会为默认值，如果请求参数与实体类的属性类型不符则会报错 如果方法参数有多个实体类并且存在属性名相同的情况，则所有的实体类对应的属性都会被绑定 1234567//其中dog和user有共同属性为name@RequestMapping(path = &quot;/pojo&quot;,method = RequestMethod.POST)public String pojo(User user, Dog dog){ System.out.println(user); System.out.println(dog); return &quot;&quot;;} 结果中user和dog的name属性都被赋值为”张三” 如果存在复合实体类，例如： 1234567@Datapublic class User { private String name; private int age; private boolean sex; private Dog dog;} 此时，如果想为user的dog绑定参数则请求参数需要以dog.name形式传递 日期类型问题： 对于字符串类型的日期参数，转换成Data的参数，会有转换类型问题。 解决方法： 如果使用的是spring boot，有三种方式解决： 使用@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)注解在实体类的字段上，这种方式比较简单，但每个字段都要添加注解比较麻烦。 写一个BaseController，每一个需要处理的controller继承这个BaseController，在BaseController里使用@InitBinder写一个全局转换日期方法： @InitBinder 注解 @InitBinder 作用于Controller中的方法上，表示为当前控制器注册一个属性编辑器，只对当前的Controller有效。 @InitBinder 标注的方法必须有一个参数WebDataBinder。webDataBinder是用于表单到方法的数据绑定的。用于帮助我们完成参数绑定。 12345678910111213141516@RequestMapping(&quot;bindParam&quot;)public class BindParam { @InitBinder public void initBinder(ServletRequestDataBinder binder) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true)); } @RequestMapping(value = &quot;/date&quot;, method = RequestMethod.GET) public String test(Date dateTime) { System.out.println(dateTime); return &quot;&quot;; }} 自定义DateConverterConfig实现一下spring提供的Converter，重写里面的convert方法即可（推荐）： 1234567891011121314151617181920212223242526272829303132333435363738394041@Componentpublic class DateConvert implements Converter&lt;String, Date&gt; { private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4); static{ formarts.add(&quot;yyyy-MM&quot;); formarts.add(&quot;yyyy-MM-dd&quot;); formarts.add(&quot;yyyy-MM-dd hh:mm&quot;); formarts.add(&quot;yyyy-MM-dd hh:mm:ss&quot;); } @Override public Date convert(String source) { String value = source.trim(); if (&quot;&quot;.equals(value)) { return null; } if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(0)); }else if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(1)); }else if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} {1}\\\\d{1,2}:\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(2)); }else if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} {1}\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(3)); }else { throw new IllegalArgumentException(&quot;Invalid boolean value '&quot; + source + &quot;'&quot;); } } public Date parseDate(String dateStr, String format) { Date date=null; try { DateFormat dateFormat = new SimpleDateFormat(format); date = dateFormat.parse(dateStr); } catch (Exception e) { } return date; }} 如果未使用spring boot，配置和上面第三种方法类似，只不过需要到xml配置文件注册这个类： 1234567891011121314&lt;!-- 第一步: 创建自定义日期转换规则 --&gt; &lt;bean id=&quot;dateConvert&quot; class=&quot;自定义Convert的全类名&quot;/&gt;&lt;!-- 第二步： 创建convertion-Service ，并注入dateConvert--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;dateConvert&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 第三步：注册处理器映射器/处理器适配器 ，添加conversion-service属性--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 集合类型1. 数组 数组类型直接作为方法参数，可接受基本类型数据和包装类，映射不到的话数组为null。 1234567891011@RequestMapping(path = &quot;/array&quot;,method = RequestMethod.POST)public String array(@RequestParam(&quot;array&quot;) Integer[] ids){ System.out.println(ids); return &quot;&quot;;}@RequestMapping(path = &quot;/arrayBasic&quot;,method = RequestMethod.POST)public String arrayBasic(@RequestParam(&quot;array&quot;) Integer[] ids){ System.out.println(ids); return &quot;&quot;;} 以实体类作为形参，并且实体类中包含数组类型，那么数组类型可以成功接收（这种情况集合也适用，测试代码放到集合部分）2. 集合 如果集合类型直接作为方法形参，则会报错 以实体类作为形参，并且实体类中包含集合类型，那么集合类型可以成功接收 12345678910111213141516//实体类@Datapublic class Person { private String[] strings; private Integer[] integers; private int[] ints; private List&lt;String&gt; list; private List&lt;String&gt; set;}//controller中的方法，以Person作为参数@RequestMapping(path = &quot;/list&quot;,method = RequestMethod.GET)public String list(Person person){ System.out.println(person); return &quot;&quot;;} 请求参数key和实体类的属性名称要一致 结果显示数据全部绑定成功 Map Map直接作为形参无法获取到值，需要以实体类作为形参，实体类中包含map类型的属性 1234@Datapublic class Dog { private Map&lt;String,String&gt; map;} 请求参数格式如下： json类型前后端交互式常常使用json类型，SpringMVC接收json类型时有两种方式进行参数绑定 json类型的数据可以通过一个String类型的参数接收，然后使用fastjson进行解析 可以通过 @RequestBody 注解进行参数绑定 @RequestBody @RequestBody主要用来接收前端传递给后端的json字符串中的数据(请求体中的数据) 在后端的同一个接收方法里，@RequestBody 与 @RequestParam 可以同时使用，但一个请求，只有一个RequestBody和多个RequestParam所以@RequestBody只能使用一次，而@RequestParam可以使用多次。 json字符串中，如果value为””的话，后端对应属性如果是String类型的，那么接受到的就是””，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。 json字符串中，如果value为null的话，后端对应收到的就是null。 使用 @RequestBody 注解接收参数根据json格式不同主要有以下三种情况： 使用实体类进行接收1234567891011121314151617181920//实体类，并且属性包括包装类、基本数据类型、自定义类、集合类@Datapublic class Person { private String name; private int age; private Integer height; private Dog mainDog; private List&lt;Dog&gt; dogs;}@Datapublic class Dog { private String name;}@PostMapping(path = &quot;/json&quot;)public String json(@RequestBody Person person){ System.out.println(person); return &quot;&quot;;} 发送的json主要为对象的嵌套 1{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:2,&quot;height&quot;:180,&quot;mainDog&quot;:{&quot;name&quot;:&quot;白狗&quot;},&quot;dogs&quot;:[{&quot;name&quot;:&quot;黑狗&quot;},{&quot;name&quot;:&quot;黄狗&quot;}]} 得到结果，参数被成功接收 使用List进行接收12345@PostMapping(path = &quot;/json&quot;)public String json(@RequestBody List&lt;Dog&gt; dogs){ System.out.println(dogs); return &quot;&quot;;} 发送的json为数组形式 1[{&quot;name&quot;:&quot;白狗&quot;},{&quot;name&quot;:&quot;黑狗&quot;}] 结果显示参数被正确接收 使用Map进行接收12345@GetMapping(path = &quot;/json&quot;)public String json(@RequestBody Map&lt;String,Dog&gt; dogs){ System.out.println(dogs); return &quot;&quot;;} json类型主要为键值对形式 1{&quot;dog1&quot;:{&quot;name&quot;:&quot;黑狗&quot;},&quot;dog2&quot;:{&quot;name&quot;:&quot;白狗&quot;}} 结果显示参数被正确接收","link":"/2021/05/10/%E6%A1%86%E6%9E%B6/Java/Spring%20MVC/SpringMVC%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"},{"title":"Arch 常用操作","text":"常用操作 更新12$ sudo pacman -Syu$ yay -Syu 清除12345678# 清理安装包缓存$ sudo pacman -Scc$ sudo yay -Scc# 清理孤立的软件包$ sudo pacman -Rns $(pacman -Qtdq)$ sudo yay -Rns $(yay -Qtdq)# 清理日志$ journalctl --vacuum-size=50M","link":"/2023/03/01/linux/arch/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"Lambda","text":"Java8新特性，Lambda可以让 Java 进行简单的函数式编程 Lambda一般配合函数式接口（[[接口#函数式接口（java8新特性）]]）使用，用于替代匿名内部类的声明方式，更加方便简洁 声明方式1234567891011121314//一般形式(参数列表)-&gt;{ //方法体}// 只有一行且为返回值时可简写(参数列表)-&gt;返回值// 只有一个参数时可以省略()参数-&gt;返回值// 举例// Lambda最终返回的结果是函数式接口的匿名对象FunctionalInterface b = (int a, int b) -&gt; 0;// 参数列表的类型可以省略FunctionalInterface b = (a, b) -&gt; 0; 方法引用使用::引用具体的方法，返回类型是函数式接口 普通方法引用123456789101112131415161718192021// TestFunctionalInterface是一个函数式接口，内部有一个抽象想法，Integer::sum与函数式接口内部的抽象方法的参数以及返回值一致，可以直接使用Integer::sum的方法体作为抽象方法的实现// 1. 使用类名引用方法TestFunctionalInterface c = Integer::sum;// 2. 使用父类的sum方法TestFunctionalInterface c = super::sum;// 3. 使用实例引用方法SumClass sumClass = new SumClass(); TestFunctionalInterface d = sumClass::sum;// 定义抽象方法@FunctionalInterface public interface TestFunctionalInterface { int abstractMethod(int a, int b); }// 定义一个类public class sumClass { int sum(int a, int b){ return a+b; } } 构造方法引用Java内置了函数式接口可以用来引用构造方法，多于一个需要自己定义函数式接口： Supplier用于引用无参构造方法 Function用于引用一个参数构造方法1234567891011121314151617// 1. Supplier用于引用无参构造方法Supplier&lt;NoArgClass&gt; a = NoArgClass::new; NoArgClass noArgClass = a.get();// 2. Function用于引用一个参数构造方法Function&lt;Integer, OneArgClass&gt; b = OneArgClass::new;OneArgClass oneArgClass = b.apply(110);// 或者Function&lt;Integer, OneArgClass&gt; b = (weight) -&gt; new OneArgClass(weight);OneArgClass oneArgClass = b.apply(110); // 3. 引用多个参数的构造方法public interface TriFunction&lt;T, U, V, R&gt;{ R apply(T t, U u, V v);}TriFunction&lt;Integer, Integer, Integer, Color&gt; c = ThreeArgClass::new; ThreeArgClass threeArgClass = b.apply(110); 访问外部变量和匿名对象一样，Lambda可以引用当前声明对象的作用域内的变量 1234567891011121314int v = 1; // 匿名对象方式TestFunctionalInterface o1 = new TestFunctionalInterface() { @Override public int abstractMethod(int a, int b) { // 引用外部变量 return v + a; } }; // lambda方式TestFunctionalInterface o2 = (a, b) -&gt; { // 引用外部变量 return v + a; };","link":"/2019/07/07/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/Lambda/"},{"title":"反射","text":"反射机制允许 Java 程序在运行时调用Reflection API取得任何类的内部信息（比如成员变量、构造器、成员方法等），并能操作类的实例对象的属性以及方法 类加载机制在执行class文件时需要的步骤叫做类加载， 加载时机在Java中类是按需加载的，第一次用到的时候才会加载 - new对象时； - 调用类中的静态成员时； - 子类被加载时，其超类也会被加载； - 通过反射的方式，在程序运行时使用到哪个类，该类才会被加载； 加载阶段 加载阶段：使用类加载器将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象； 连接阶段：又分为验证、准备、解析三个小阶段，此阶段会将类的二进制数据合并到 JRE 中； 验证：确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，包括文件格式验证（是否以魔数开头）、元数据验证、字节码验证和符号引用验证 准备：JVM 会在该阶段对静态变量分配内存并进行默认初始化（不同数据类型会有其默认初始值，如：int-0，boolean-false 等）。这些变量的内存空间会在方法区中分配。 解析：JVM 将常量池内的符号引用替换为直接引用的过程。 初始化阶段：JVM 负责对类的静态成员进行初始化。 Class 类 Class也是一个类，其类名就叫Class，因此它也继承 Object 类； Class类对象不是由我们程序员创建（new）出来的，而是在类加载时由 JVM 自动创建的； 在堆内存中最多只会存在某个类的唯一的Class对象，因为类只会加载一次每个类的实例对象都会知道自己对应的Class对象； 通过Class类对象可以完整地得到其对应的类的信息，通过一系列反射 API； 类的字节码二进制数据，是存放在方法区的，又称为类的元数据（包括方法代码、变量名、方法名、访问权限等等）； 获取Class实例1234567891011121314// 1. 使用.classClass cls = String.class;Class cls = String[].classClass integerClass = int.class;Class characterClass = char.class;Class booleanClass = boolean.class;// 2. 使用对象的getClass()方法String s = &quot;Hello&quot;;Class cls = s.getClass();// 3. 根据类名加载Class cls = Class.forName(&quot;java.lang.String&quot;);// 4. 对于包装类，可以通过类中的静态变量TYPE获取Class type1 = Integer.TYPE;Class type2 = Character.TYPE; 获取Class信息1234567System.out.println(cls.getName());System.out.println(cls.getSimpleName());System.out.println(cls.getPackage());System.out.println(cls.isInterface());System.out.println(cls.isEnum());System.out.println(cls.isArray());System.out.println(cls.isPrimitive()); 创建实例1234Class cls = String.class;// 通过 String 的 Class 类对象创建一个 String 类的实例对象:String s = (String) cls.newInstance(); 访问字段1234567891011121314151617181920212223242526import java.lang.reflect.Field;public class Main { public static void main(String[] args) throws Exception { Person p = new Person(&quot;小刚&quot;); Class c = p.getClass(); // 获取 public 字段 Field f1 = c.getField(&quot;age&quot;); // 获取 private 字段 Field f = c.getDeclaredField(&quot;name&quot;); // 允许访问 private 成员 f.setAccessible(true); // 获取字段值 Object value = f.get(p); // 设置字段值 f.set(p, &quot;小明&quot;) }}class Person { private String name; public Integer age; public Person(String name) { this.name = name; }} 调用方法12345678910111213141516171819// 1. 调用方法String s = &quot;Hello world&quot;;// 获取 String substring(int)方法Method m = String.class.getMethod(&quot;substring&quot;, int.class);// 执行方法String r = (String) m.invoke(s, 6);// 2. 调用静态方法// 获取 Integer.parseInt(String) 方法Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);// 调用该静态方法并获取结果Integer n = (Integer) m.invoke(null, &quot;12345&quot;);// 3. 调用非public方法Person p = new Person();Method m = p.getClass().getDeclaredMethod(&quot;setName&quot;, String.class);// 设置允许访问，否则报错m.setAccessible(true);m.invoke(p, &quot;Bob&quot;); 调用构造方法一般情况： 1Person p = Person.class.newInstance(); 获取构造方法： getConstructor(Class)：获取某个public的Constructor； getDeclaredConstructor(Class)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor；1234// 获取构造方法 Integer(int)Constructor cons1 = Integer.class.getConstructor(int.class);// 调用构造方法:Integer n1 = (Integer) cons1.newInstance(123); 获取继承方法获取父类Class123Class i = Integer.class;// 获取父类classClass n = i.getSuperclass(); 获取接口Class12Class s = Integer.class; Class[] is = s.getInterfaces(); 继承关系使用instanceof判断对象和类之间的继承关系： 123Object n = Integer.valueOf(123);boolean isDouble = n instanceof Double; // falseboolean isInteger = n instanceof Integer; // true 可以调用isAssignableFrom()方法判断两个Class类对象之间的继承关系： 12345678// true，因为Integer可以赋值给IntegerInteger.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给NumberNumber.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给ObjectObject.class.isAssignableFrom(Integer.class); // false，因为Number不能赋值给IntegerInteger.class.isAssignableFrom(Number.class);","link":"/2019/07/06/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E5%8F%8D%E5%B0%84/"},{"title":"异常处理","text":"异常类型Throwable： Error：错误，不可恢复，例如Java虚拟机（JVM）内存不足，内存泄漏，堆栈溢出错误，库不兼容，无限递归等； Exception：异常，程序执行出错会创建一个异常对象，异常对象会包含异常的信息； 捕获异常1234567try { // 代码} catch (ExceptionType e) { // 捕获块} finally { //finally块} try-with-resources在后使用try(资源)创建或声明的变量会被自动关闭资源 123456789101112131415161718192021try (资源声明) { // ...} catch (ExceptionType e1) { // ...}// 举例BufferedInputStream bin = new BufferedInputStream(new FileInputStream(&quot;in.txt&quot;)); try ( // 1. 在try外创建对象，然后在try内声明（Java9新特性） bin; // 2. 在try内创建对象 BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(&quot;out.txt&quot;)) ) { int b; while ((b = bin.read()) != -1) { bout.write(b); } } catch (IOException e) { e.printStackTrace(); } 只有实现了AutoCloseable接口的资源对象才可以声明在try()内 抛出异常 throws：用于在方法上抛出异常，抛出的异常类型方法内不需要处理 throw：在方法内抛出异常12345// 方法上声明抛出异常void returnType fun() throws 异常类型1, 异常类型2 … { //抛出异常 throw 异常类型;}","link":"/2019/06/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"接口","text":"Java接口 接口接口声明 最开始的时候接口中只能声明常量和抽象方法，但后来随着一系列更新接口已经支持更多的方法类型； 接口可以声明如下类型： 常量； 抽象方法； 默认方法（java8引入）：可以给接口中添加非抽象的方法实现，方法前加 default 关键字，如果子类继承了的多个接口有同名默认方法，则需要子类重写该方法； 静态方法（java8引入）：可以使用 static 修饰方法并提供方法实现，静态方法通过接口调用； 123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface TestInterface { // 定义常量，默认是public static final的 String constVar = &quot;常量&quot;; // 抽象方法，默认是public abstract的 void abstractMethod(); // java8新特性：默认方法 default void defaultMethod() { System.out.println(&quot;默认方法&quot;); } // java8新特性：静态方法 static void staticMethod() { System.out.println(&quot;静态方法&quot;); } } class TestClass implements TestInterface { // 实现抽象方法（必须实现） @Override public void abstractMethod() { } // 重写默认方法（可选） @Override public void defaultMethod() { TestInterface.super.defaultMethod(); } public static void main(String[] args) { // 调用默认方法 TestClass testClass = new TestClass(); testClass.defaultMethod(); // 调用静态方法 TestInterface.staticMethod(); // 调用常量 System.out.println(TestInterface.constVar); } } 函数式接口 java8新特性 函数式接口有且只有一个抽象方法，但可以有多个非抽象方法，可以使用@FunctionalInterface注解（可选，只W起到规范作用） 声明函数式接口定义如下： 1234@FunctionalInterface public interface TestFunctionalInterface { int abstractMethod(int a, int b); } 用途函数式接口主要用于简化匿名对象的编写，主要通过以下两种方式： 配合Lambda使用 配合方法引用使用12345678910111213141516171819202122232425@FunctionalInterface public interface TestFunctionalInterface { int abstractMethod(int a, int b); } class Test{ public static void main(String[] args) { // 匿名对象 TestFunctionalInterface a = new TestFunctionalInterface() { @Override public int abstractMethod(int a, int b) { return 0; } }; // 函数式接口配合Lambda表达式，得到的也是一个该接口的匿名对象 TestFunctionalInterface b = (a1, b1) -&gt; 0; b.abstractMethod(1,2); // 函数式接口配合方法引用 // 这里只要Integer::sum和TestFunctionalInterface内abstractMethod方法的 // 参数类型和返回值类型对应上就可以，相当于直接使用了Integer::sum的方法体 TestFunctionalInterface c = Integer::sum; b.abstractMethod(1,2); } }","link":"/2019/07/02/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%8E%A5%E5%8F%A3/"},{"title":"断言","text":"断言 声明断言启用断言且条件为时true，程序将正常执行，如果在启用断言时条件计算为false, JVM会抛出AssertionError，程序会立即停止。 12assert 布尔表达式;assert 布尔表达式 : expression; 举例 12assert 1&gt;2assert 1&gt;2 : &quot;出错了&quot;; 启用断言 默认情况下断言是禁用的 1234567891011121314java -enableassertions:参数# 简写java -ea:参数# 不提供参数则启动系统类外的所有断言java -ea# 启动系统类断言java -enablesystemassertions:参数# 简写java -esa:参数# 在当前工作目录中的未命名包中启用断言（当我们不使用package语句时）。java -ea:... 举例 12// 只启用AnimalClass类的断言java -ea:AnimalClass Main 禁用断言1234567# 禁用断言java -disableassertions:参数java -da:参数# 禁用系统类断言java -disablesystemassertions:参数java -dsa:参数","link":"/2019/07/05/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%96%AD%E8%A8%80/"},{"title":"模块系统","text":"Java中使用包来对代码进行模块化 包声明 使用package关键字声明包 12345package 包名;// 举例package com;package com.a; 引入包 使用import关键字引入包，允许使用通配符 123456import 包名;// 举例import java.util.Arrays;// 使用通配符import java.util.*;","link":"/2019/06/04/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"},{"title":"枚举类","text":"枚举类用来创建一系列不能被修改的对象，默认会继承Enum，可以使用Enum提供的方法 枚举类定义12345678910111213141516171819202122232425262728293031// 使用enum定义枚举类 enum Season {//类 SPRING(&quot;春天&quot;), WINTER(&quot;冬天&quot;), AUTUMN(&quot;秋天&quot;), SUMMER(&quot;夏天&quot;), // 如果使用无参构造可以省略() UNKNOWN; // 等同于定义了四个静态常量 // public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;); // public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;); // public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;); // public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;); private String name; //无参构造器 private Season() { } private Season(String name) { this.name = name; } public String getName() { return name; } } 枚举类方法12345678// 1. 获取对象名 System.out.println(Season.AUTUMN.name());//AUTUMN // 2. 获取对象的编号，从0开始 System.out.println(Season.AUTUMN.ordinal());//2 // 3. 获取对象列表 System.out.println(Arrays.toString(Season.values()));//[SPRING, WINTER, AUTUMN, SUMMER, UNKNOWN] // 4. 传入已有对象名，返回对应的枚举对象 System.out.println(Season.valueOf(&quot;AUTUMN&quot;));//AUTUMN","link":"/2019/07/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"},{"title":"泛型","text":"泛型 泛型声明泛型类泛型类声明： 123456789101112131415161718192021222324252627282930313233class 类名称 &lt;泛型标识&gt; { private 泛型标识 /*（成员变量类型）*/ 变量名; ..... }}// 举例class Generic&lt;T&gt; { // T作为成员变量的类型 private T key; // T作为方法参数类型 public Generic(T key) { this.key = key; } // T作为返回值类型 public T getKey(){ return key; } // 静态方法和变量不能使用泛型类声明的泛型类型 // 下面两个会报错 public static T s; // 编译错误 public static T sf(T one){ // 编译错误 return null; } // 只能在方法上声明泛型 public static &lt;E&gt; E f(E one){ return null; } } 泛型类的使用： 1234// 一般声明Generic&lt;String&gt; generic = new Generic&lt;&gt;();// 不指定泛型时，默认为Object类型Generic generic = new Generic(); 泛型接口泛型接口声明： 12345678public interface 接口名&lt;类型参数&gt; { //...}// 举例interface Inter&lt;T&gt; { void show(T t); } 子类实现泛型接口时必须确定类型： 123456class A implements Inter&lt;String&gt; { @Override public void show(String s) { } } 也可以使用类上的泛型： 123456class A&lt;E&gt; implements Inter&lt;E&gt; { @Override public void show(E e) { } } 泛型方法1234567891011public &lt;类型参数&gt; 返回类型 方法名（类型参数 变量名） { ...}// 举例// 声明泛型为E，方法的返回值类型和参数类型都可以设置为Epublic &lt;E&gt; E f(E v){ return v; }// 使用时编译器会根据参数类型和返回值类型自动识别泛型String f = Generic.f(&quot;123&quot;); 如果泛型类和泛型方法中泛型的标识有冲突，比如都为T，则以泛型方法自己声明的为准； 静态方法无法使用类的泛型； 类型擦除Java中泛型使用类型擦除的方式实现，编译器会在编译期间擦除代码中的所有泛型语法并进行类型转换。也就是说泛型只存在于代码编译阶段，编译后的class文件不会包含泛型信息。举例如下： 12345ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;(); ArrayList&lt;Integer&gt; arrayInteger = new ArrayList&lt;Integer&gt;(); // trueSystem.out.println(arrayString.getClass() == arrayInteger.getClass()); 这是因为ArrayList&lt;Integer&gt;和ArrayList&lt;String&gt;在编译后都会变成ArrayList&lt;Object&gt;。这里被替换成的类型（Object）被称为原始数据类型，大部分情况下泛型都会使用Object替换，也可以使用泛型通配符控制替换的类型。 泛型通配符上界通配符（&lt;? extends String&gt;）&lt;? extends T&gt;表示类型必须是T或T的子类，举例如下： 12// 编译通过，因为Integer是Number的子类ArrayList&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); 这里只能向list中传递Number类型的数据，不能传递其子类，因为只限定了类型的上限，右侧泛型的类型可以是Number的任意子类，无法确定是否符合右侧类型的要求，假设右侧泛型类型实际是Integer，那如果向list中传递Float就是错误的： 123ArrayList&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;();list.add(new Integer(1));// 编译错误 list.add(new Float(1.0));// 编译错误 也可以用于定义类 12class Generic&lt;T extends Number&gt; { Generic&lt;Integer&gt; generic = new Generic&lt;&gt;(); 下界通配符&lt;? super T&gt;表示类型必须是T或T的超类，直到Object。 12// 编译通过，因为Number是Integer的超类ArrayList&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;(); 这里可以向list中传递子类，因为限定了泛型的下界，右侧泛型类型最低就是Number类型，传入Number子类一定符合条件 123ArrayList&lt;? super Number&gt; list = new ArrayList&lt;&gt;();list.add(new Integer(1));// 编译通过list.add(new Float(1.0));// 编译通过 无限定通配符&lt;?&gt;表示可以是任何类型，没有上界也没有下界，可以想象成所有类型的父类 作用泛型识别时不支持继承关系： 12// 这里虽然Integer是Number的子类，但编译报错ArrayList&lt;Number&gt; list1 = new ArrayList&lt;Integer&gt;(); 泛型通配符的作用在于拓展方法形参中类型参数的范围： 123456789101112// 一般方法，只能传递Pair&lt;Number&gt;类型的参数int addPair(Pair&lt;Number&gt; p) { Number first = p.getFirst(); Number last = p.getLast(); return first.intValue() + last.intValue();}// 使用泛型通配符，这里传入的Pair可以为Pair&lt;Integer&gt;也可以是Pair&lt;Float&gt;static int addPair(Pair&lt;? extends Number&gt; p) { Number first = p.getFirst(); Number last = p.getLast(); return first.intValue() + last.intValue();}","link":"/2019/07/03/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%B3%9B%E5%9E%8B/"},{"title":"注解","text":"注解（Annotation），也被称为元数据(Metadata)，用于修饰注释、包、类、方法、属性、构造器、局部变量等数据信息。 注解声明注解需要使用元注解修饰，注解内部可以定义： 常量 抽象方法123456789101112131415161718// 元注解@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface MyAnnotation { // 定义常量，默认是public static final的 String constVar = &quot;常量&quot;; // 抽象方法，默认是public abstract的，返回值类型不能为void String abstractMethod(); // 通过default设置默认值 String abstractMethod2() default &quot;123&quot;;}// 使用注解// 使用注解时需要可以为每个抽象方法设置值@MyAnnotation(abstractMethod = &quot;属性&quot;)// 访问注解内的常量System.out.println(MyAnnotation.constVar); 如果 注解属性 名称是 value , 并且 注解中只有 1 11 个属性 , 那么在使用 注解 为 注解属性 赋值时 , 可以省略注解名称 , 直接传入 注解属性值 ;12345678910// 声明@Documented @Target({TYPE, FIELD})@Retention(RetentionPolicy.SOURCE)public @interface MyAnnotation { String[] value();}// 使用@MyAnnotation(&quot;all&quot;) 元注解元注解是用于修饰其他注解类的注解 Retention 指定注解的作用范围 123456@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Retention { RetentionPolicy value(); } 有三种取值： RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注解； RetentionPolicy.CLASS：默认值，编译器将把注解记录在 class 文件中，当运行 Java 程序时，JVM 不会保留注解； RetentionPolicy.RUNTIME：编译器将把注解记录在 class 文件中，当运行 Java 程序时，JVM 会保留注解，程序可以 通过反射获取该注解； Target 用于指定被修饰的注解能用于修饰哪些程序元素 123456@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Target { ElementType[] value(); } ElementType内容如下： 1234567891011121314151617181920212223242526public enum ElementType { // class、interface、@interface、enum、record TYPE, // 字段（包括enum常量） FIELD, // 方法 METHOD, // 参数 PARAMETER, // 构造器 CONSTRUCTOR, // 局部变量 LOCAL_VARIABLE, // 注解 ANNOTATION_TYPE, // 包 PACKAGE, // 类型参数（Java8引入） TYPE_PARAMETER, // 任意类型（不包括class） TYPE_USE, // 模块声明（Java9引入） MODULE, // RECORD组件（Java16引入） RECORD_COMPONENT; } Documented 用于指定被修饰的注解类将被 javadoc 工具提取成文档，即在生成文档时可以看到该注解。定义一个注解为 @Documented 时，必须先设置 @Retention 的值为 RUNTIME 12345@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Documented { } Inherited 很少使用，被它修饰的注解类将具有继承性，如果某个类使用了被 @Inherited 修饰的注解，则其子类将自动具有该注解。","link":"/2019/07/04/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%B3%A8%E8%A7%A3/"},{"title":"类","text":"类、抽象类 类声明类中可声明的元素如下： 构造函数； 成员属性； 成员方法； 代码块； 内部类：可用static修饰，其他和正常类一样； 静态成员：用static修饰，可修饰内部类、代码块、属性、方法；1234567891011121314151617181920212223242526272829303132class TesClass { // 成员变量 public String str; // 无参构造 public TesClass() { } // 有参构造 public TesClass(String s) { this.s = s; } // 静态方法 public static void staticMethod() { } // 静态变量 public static String staticStr; // 代码块 {} // 静态代码块 static {} // 内部类 class inner{} // 静态内部类 static class staticInner{}} 访问修饰符 public：所有类可见 proctected：同一包内和所有子类可见 默认：同一包内可见 private：类内可见 finalfinal可以用来修饰： 类：final类不能被继承； 方法：final方法不能被子类重写； 属性：final属性是常量，必须初始化，并且初始化后不能被重新赋值，初始化位置如下：12345678910111213141516171819202122232425262728class TestFinal { // 1. 直接赋值 final String finalStr1 = &quot;final&quot;; final String finalStr2; final String finalStr3; public TestFinal(String finalStr2) { // 2. 构造函数中赋值 this.finalStr2 = finalStr2; } { // 3. 代码块中赋值 finalStr3 = &quot;final&quot;; } // 静态final属性 // 5. 直接赋值 final static String finalStr4 = &quot;final&quot;; final static String finalStr5; static { // 6. 静态代码块中赋值 finalStr5 = &quot;final&quot;; } } 和static一起使用效率更高，编译器底层有优化； 局部类 定义在代码块或方法中 不能用访问修饰符和static修饰，可以使用final 可以访问当前作用域对象 可以访问外部类的成员，如果与局部类成员命名冲突则就近原则，如果必须使用外部类可以用外部类.静态成员和外部类.this.成员；123456789101112131415161718192021222324252627class TesClass { // 成员变量 public String str; public static String staticStr; public void method() { int i = 0; // 局部类 class inner { public void fun() { // 访问外部成员 System.out.println(str); // 使用外部类成员 System.out.println(TesClass.staticStr); System.out.println(TesClass.this.str); // 可以访问外部变量 System.out.println(i); } } // 创建局部类对象 inner inner = new inner(); } } 匿名内部类就是匿名对象，可以声明在方法和代码块中，也可以为成员属性赋值，其他方面也和创建一个普通对象一样； 123456789// 第一种：实现接口的匿名内部类接口名 接口的引用 = new 接口名() { 重写接口的抽象方法; };// 第二种：继承父类的匿名内部类（父类可以是抽象类或普通类）父类类型 父类的引用 = new 父类(形参列表) { 重写父类的抽象方法/方法;}; 抽象类 抽象方法不能使用 private、final 和 static 关键字来修饰抽象类可以声明抽象方法，也可以声明普通类成员12345678910111213141516171819abstract class Father{ void hello(){} abstract protected void run(); } class Son extends Father{ // 实现接口方法 @Override public void run() { } // 重写父类方法 @Override void hello() { super.hello(); } } 继承 使用extends继承普通类或抽象类，只能单继承； 使用implements实现接口，可以实现多个接口； 子类重写的方法优先级更高；12345678910111213141516171819202122class Father{ void hello(){} } interface People{ void run(); } class Son extends Father implements People{ // 实现接口方法 @Override public void run() { } // 重写父类方法 @Override void hello() { super.hello(); } } instanceofinstanceof用于判断对象的继承关系 12345Integer n = new Integer(123);// true，因为 n是 Integer 类型boolean b1 = n instanceof Integer; // true，因为 n 是 Number 类型的子类boolean b2 = n instanceof Number;","link":"/2019/05/07/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E7%B1%BB/"},{"title":"流程控制","text":"条件语句、循环语句、跳转操作 条件语句if基本语法12345678if(布尔表达式){ //...}else if(布尔表达式){ //...}else{ //...} switch基本语法1234567891011switch(表达式){ case 值1 : //... break; //可选，如果没有break会继续执行下面的每个case中的代码 case 值2 : //... break; //其他case default: //语句} 表达式类型 byte short int char String（case标签必须为字符串常量或字面量） break代码举例如下： 1234567891011String e = &quot;我&quot;;switch (e){ case &quot;我&quot;: System.out.print(&quot;我&quot;); break;//(1) case &quot;你&quot;: System.out.print(&quot;你&quot;); break;//(2) default: System.out.print(&quot;他&quot;);} 存 break 的位置 结果 (1)、(2) 我 (2) 我你 无 我你他 循环语句while基本语法123while(布尔表达式) { //...} do…while基本语法123do { //...}while(布尔表达式); for基本语法123for(初始化; 布尔表达式; 更新) { //...} 增强循环1234for(类型 变量名:数组){ //...} 跳转操作 break：用于跳出/结束循环语句或switch语句； continue：用于循环语句，让程序立刻跳转到下一次循环的迭代；","link":"/2019/06/03/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"类型系统","text":"整数类型、浮点类型、字符类型、布尔类型、缓冲池、类型转换、字符串、数组、包装类 变量变量声明1类型 变量名 [ = 值][, 变量名 [= 值] ...]; Java可以同时声明多个同类型变量并赋值； 如果不赋初始值则为默认值； 局部变量局部变量是在方法或代码块中声明的变量，有如下特点： 局部变量在栈上分配； 只在声明局部变量所在的作用域内可见； 常量使用final关键字定义常量 1final 类型 变量名 [ = 值][, 变量名 [= 值] ...]; 常量名一般推荐使用全大写； 常量只能初始化一次； 被final修饰的对象的引用不可变，但所指向的对象内部的值可以改变； 整数类型 类型 占用空间(byte) 取值范围 默认值 byte 1 -128~127 0 short 2 -32768~32767 0 int 4 -2^31~2^31^-1 0 long 8 -2^63^~2^63^-1 0L 进制表示byte、int、long、和short都可以用十进制、十六进制以及八进制的方式来表示 进制 前缀 二进制 0b、0B 八进制 0 十六进制 0x、0X 字面量格式 进制 格式 二进制 0b开头 八进制 0、0o开头 十六进制 0x开头 浮点类型 类型 占用空间(byte) 取值范围 默认值 字面量 float 32 -3.403E38~3.403E38 0.0f 1.1 double 64 -1.798E3.8~1.798E3.8 0.0d 1.1f 浮点类型可以使用科学计数法表示； 字符类型 类型 占用空间(byte) 取值范围 默认值 char 8 ‘\\u0000’（空字符） 每个char类型是一个Unicode字符 布尔类型 类型 占用空间(bit) 取值范围 默认值 boolean 1 true/false false 类型转换Java中基本类型的类型转化分为： 隐式类型转换：精度低的类型可以直接赋值给精度高的类型； 显式类型转换：精度高的类型赋值给精度低的类型需要声明类型转换 12long a = 10;int b = (int) a; 数组123456//方式1类型[] 变量名 = {值1, 值2, 值3, 值4};//方式2类型 变量名[] = {值1, 值2, 值3, 值4};//方式3类型[] 变量名 = new 类型[数组长度];","link":"/2019/06/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"运算符","text":"算术运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、运算符优先级 算术运算符 操作符 描述 + 加法 - 减法 * 乘法 / 除法 ％ 取模 ++ 自增 – 自减 关系运算符 运算符 描述 == 相等 != 不相等 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 位运算符 操作符 描述 ＆ 按位与 | 按位或 ^ 按位异或（不同为1，相同为0） 〜 按位补（翻转操作数的每一位） &lt;&lt; 按位左移 &gt;&gt; 按位右移 &gt;&gt;&gt; 按位右移空位补零 逻辑运算符 操作符 描述 &amp;&amp; 逻辑与 | | 逻辑或 ！ 逻辑非 赋值运算符 操作符 描述 = 赋值运算符 += 把左操作数和右操作数相加赋值给左操作数 -= 把左操作数和右操作数相减赋值给左操作数 * = 把左操作数和右操作数相乘赋值给左操作数 / = 把左操作数和右操作数相除赋值给左操作数 ％= 把左操作数和右操作数取模后赋值给左操作数 &lt;&lt;= 左移位赋值运算符 &gt;&gt;= 右移位赋值运算符 ＆= 按位与赋值运算符 ^= 按位异或赋值操作符 |= 按位或赋值操作符 运算符优先级优先级从高到低排列如下表所示： 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt;&gt; = &lt;&lt; = 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 | 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 | | 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | = 从右到左 逗号 ， 左到右","link":"/2019/06/05/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"Quarkus Bean 介绍","text":"Quarkus中关于Bean的声明、注入、作用域、声明周期等 Bean 声明一般来说，bean种类包括： Class beans Producer methods Producer fields Synthetic beans 123456789101112131415161718192021222324252627@ApplicationScopedpublic class Producers { @Produces double pi = Math.PI; @Produces List&lt;String&gt; names() { List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;Andy&quot;); names.add(&quot;Adalbert&quot;); names.add(&quot;Joachim&quot;); return names; }}@ApplicationScopedpublic class Consumer { @Inject double pi; @Inject List&lt;String&gt; names; // ...} Bean 发现使用Jandex索引可以自动扫描bean，导入方法如下： 123plugins { id &quot;org.kordamp.gradle.jandex&quot; version &quot;1.1.0&quot;} 引入依赖项有时导入的第三方依赖没有被扫描到，那么可以在application.properties中手动导入 1234567quarkus.index-dependency.&lt;name&gt;.group-id=quarkus.index-dependency.&lt;name&gt;.artifact-id=#可选quarkus.index-dependency.&lt;name&gt;.classifier=#举例quarkus.index-dependency.acme.group-id=org.acme quarkus.index-dependency.acme.artifact-id=acme-api 排除依赖项123456#排除依赖项quarkus.arc.exclude-dependency.&lt;name&gt;.group-id=quarkus.arc.exclude-dependency.&lt;name&gt;.artifact-id=#举例quarkus.arc.exclude-dependency.acme.group-id=org.acme quarkus.arc.exclude-dependency.acme.artifact-id=acme-services 排除自定义包 值 描述 org.acme.Foo 匹配类的完全限定名称 org.acme.* 将类与包匹配org.acme org.acme.** 匹配包开头的类org.acme Bar 匹配类的简单名称 举例如下： 123456#排除指定类quarkus.arc.exclude-types=org.acme.Foo#排包org.acme包中的类quarkus.arc.exclude-types=org.acme.*#排除类名为Bar的beanquarkus.arc.exclude-types=Bar 私有成员因为Quarkus基于GraalVM 构建本地可执行文件。而GraalVM不支持反射，但想要获取私有成员就必须用反射，所以Quarkus并不建议使用私有成员，避免方法如下： 将私有成员改为包修饰符 12345class Dog{ private String name; //改为 String name;} 构造函数注入 12345678910@ApplicationScopedpublic class Dog { private String name; @Inject//@Inject是可选的 CounterBean(String name) { this.name = name; }} 懒加载bean默认是需要时延迟创建的，“需要”的确切含义取决于 bean 的范围： 普通范围的bean：在调用注入实例的方法时创建 @ApplicationScoped @RequestScoped 伪作用域：注入时创建 @Dependent @Singleton 举例如下： 12345678910111213141516171819202122232425262728@Singleton // =&gt; pseudo-scopeclass AmazingService { String ping() { return &quot;amazing&quot;; }}@ApplicationScoped // =&gt; normal scopeclass CoolService { String ping() { return &quot;cool&quot;; }}@Path(&quot;/ping&quot;)public class PingResource { @Inject AmazingService s1; @Inject CoolService s2; @GET public String ping() { return s1.ping() + s2.ping(); }} Bean 注入每个bean会声明一组bean类型，比如 12345@ApplicationScopedClass Dog{ @Inject String name;} 上面代码中Dog有两种类型：Dog和Object，如果bean的类型域所需类型相匹配并且具有必须的限定符，则该bean可以被分配给注入点。如果有且仅有一个bean和注入条件匹配，那么构建成功，如果有多个bean或没有bean和注入条件匹配，那么会构建失败，抛出错误 字段注入 @Inject：声明依赖注入 @ConfigProperty：限定符，如果声明了限定符那么@Inject可以省略 123@Inject@ConfigProperty(name = &quot;cool&quot;)String coolProperty; 构造函数注入（推荐）构造函数可以接受多个参数，并且不必遵循JavaBean命名约定。域CDI不同，在Quarkus中，如果检测到无参构造的确实，则直接在字节码中添加它。如果只有一个构造函数，那@Inject可以省略 1234567891011121314@ApplicationScopedClass Dog{ @Inject private String name; Dog(){//无参构造如果不声明，则会自动生成 } @Inject Dog(String name){ this.name=name; }} Bean 作用域 注解 描述 @javax.enterprise.context.ApplicationScoped bean 实例用于应用程序并在所有注入点之间共享。该实例是延迟创建的，使用客户端代理，在第一次调用实例方法时创建。 @javax.inject.Singleton bean 实例用于应用程序并在所有注入点之间共享。不使用客户端代理，在注入时直接创建。性能要更好一点。不能与QuarkusMock一起使用 @javax.enterprise.context.RequestScoped bean 实例与当前请求（通常是 HTTP 请求）相关联。 @javax.enterprise.context.Dependent 这是一个伪作用域。这些实例不是共享的，每个注入点都会生成一个新的依赖 bean 实例。依赖 bean 的生命周期与注入它的 bean 绑定——它将与注入它的 bean 一起创建和销毁。 @javax.enterprise.context.SessionScoped 这个范围由一个javax.servlet.http.HttpSession对象支持。它仅在使用quarkus-undertow扩展时可用。 生命周期回调bean 类可以声明生命周期如下回调： @PostConstruct：在将 bean 实例投入服务之前调用此回调。在这里执行一些初始化； @PreDestroy：在销毁 bean 实例之前调用此回调。在这里执行一些清理任务； 12345678910111213141516import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@ApplicationScopedpublic class Translator { @PostConstruct void init() { // ... } @PreDestroy void destroy() { // ... }} 拦截器类似于Spring的AOP 定义拦截器 123456789101112131415161718192021222324252627282930313233//这是一个拦截器绑定注解@InterceptorBinding @Retention(RetentionPolicy.RUNTIME)//拦截器绑定注解总是放在拦截器类型上，也可以放在目标类型或方法上。@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR}) //拦截器绑定通常是@Inherited，假设用本注解修饰A类，B是A的子类，那B也相当于有本注解@Inherited public @interface Logged {}//拦截器绑定注释用于将我们的拦截器绑定到一个 bean@Logged //Priority启用拦截器并影响拦截器排序。具有较小优先级值的拦截器首先被调用。@Priority(2020) //标记拦截器组件。@Interceptor public class LoggingInterceptor { //拦截器可能会注入依赖项。 @Inject Logger logger; //表示插入业务方法的方法。 @AroundInvoke Object logInvocation(InvocationContext context) { // ...log before //继续执行拦截器链中的下一个拦截器或调用被拦截的业务方法。 Object ret = context.proceed(); // ...log after return ret; }} 使用拦截器 12345678910import javax.enterprise.context.ApplicationScoped;//拦截器绑定注解放在一个bean类上，这样就可以拦截所有的业务方法。注释也可以放在单独的方法上，在这种情况下，只会拦截注释的方法。@Logged @ApplicationScopedpublic class MyService { void doSomething() { ... }} 装饰器装饰器有点像简化版的java动态代理，类似于拦截器，但是他们实现了具有业务语义的接口，所以它们能够实现业务逻辑。 12345678910111213141516171819202122232425262728293031//定义一个接口public interface Account { void withdraw(BigDecimal amount);}//定义接口实现//具有较小优先级值的装饰器首先被调用。@Priority(10) //标记装饰器组件@Decorator public class LargeTxAccount implements Account { //可以修饰所有实现接口的bean类型，java.io.Serializable.接口除外 @Inject @Any @Delegate //注入目标对象，这里实现的接口为Account，所以这里是Account实例 Account delegate; @Inject //装饰器可以注入其他 bean。 LogService logService; void withdraw(BigDecimal amount) { //装饰器可以调用委托对象的任何方法。并且容器调用链中的下一个装饰器或被拦截实例的业务方法。 delegate.withdraw(amount); if (amount.compareTo(1000) &gt; 0) { logService.logWithdrawal(delegate, amount); } }} 事件和观察者bean可以使用生产者消费者模式，以完全分离的方式进行交互， 123456789101112131415161718192021222324252627class TaskCompleted { // ...}@ApplicationScopedclass ComplicatedService { @Inject //用于触发事件 Event&lt;TaskCompleted&gt; event; void doSomething() { // ... //触发事件 event.fire(new TaskCompleted()); }}@ApplicationScopedclass Logger { void onTaskCompleted(@Observes TaskCompleted task) { //触发事件时，会通知此方法。 // ...log the task }}","link":"/2023/01/06/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/Quarkus/Quarkus%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"title":"Quarkus 配置","text":"Quarkus是使用MicroProfie Config规范实现的 配置源Quarkus读取顺序如下： 系统属性 环境变量 .env文件 应用配置文件 MicroProfile Config 系统属性启动时通过-D传递给应用程序，举例如下： 123456#开发模式：$ ./mvnw quarkus:dev -Dquarkus.datasource.password=youshallnotpass#运行jar包$ java -Dquarkus.datasource.password=youshallnotpass -jar target/quarkus-app/quarkus-run.jar#对于本机可执行文件$ ./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass 环境变量配置环境变量后应用程序会读取环境变量 123456#运行jar包$ export QUARKUS_DATASOURCE_PASSWORD=youshallnotpassjava -jar target/quarkus-app/quarkus-run.jar#对于本机可执行文件export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass./target/myapp-runner .env在当前工作目录下的*.env*文件，在dev阶段，这个文件放在项目根目录下，官方建议不要放到版本控制之中 1QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 应用配置文件Quarkus的配置文件和Spring Boot的配置文件一样，处于： src/main/resources/application.properties src/test/resources/application.properties jar包中的application.properties $PWD/config/application.properties 加载顺序是从配置文件夹开始，然后是类路径顺序（应用程序中的application.properties文件将优先于类加载器加载顺序），后面的会覆盖前面的配置。 MicroProfile ConfigMicroProfile Config配置文件是处于类路径下的所有src/main/resources/META-INF/microprofile-config.properties位置 其他配置源Quarkus提供了其他的配置格式： YAML HashiCorp Vault Consul Spring Cloud 也可以自定义配置源 配置注入和Spring一样，Quarkus也可以通过MicroProfile注释在应用程序中注入配置属性，可以使用如下注释： @Inject和@ConfigProperty @ConfigProperty 123456789//没有提供属性值则启动失败@ConfigProperty(name = &quot;greeting.message&quot;) String message;//没有提供属性值则使用默认值@ConfigProperty(name = &quot;greeting.suffix&quot;, defaultValue=&quot;!&quot;) String suffix;//Optional表示属性是可选的，如果没有提供属性值，则会注入空值@ConfigProperty(name = &quot;greeting.name&quot;)Optional&lt;String&gt; name; defaultValue有很多的转换器，这些转换器是org.eclipse.microprofile.config.spi.Converter实现，因此，这些转换器符合 Microprofile 或自定义实现提供程序表达式规则 配置目标环境配置应用启动有多种模式，例如dev环境和test环境，每种模式启动的配置可能不同，可以在一个或多个配置文件中指定不同模式的配置，其格式如下： application.properties：%{profile-name}.config.name 123#下面定义了两个同名配置，在dev环境/激活状态下端口号是8181，否则为9090quarkus.http.port=9090%dev.quarkus.http.port=8181 .env：_{PROFILE}_CONFIG_KEY=value 123#下面定义了两个同名配置，在dev环境/激活状态下端口号是8181，否则为9090QUARKUS_HTTP_PORT=9090_DEV_QUARKUS_HTTP_PORT=8181 模式配置文件Quarkus提供了三个配置文件，在特定模式下自动激活 dev - 在开发模式下激活（即quarkus:dev） test - 运行测试时激活 prod - 未在开发或测试模式下运行时的默认配置文件 激活配置文件可以使用自定义的配置文件模式，可以指定激活配置文件和符配置文件： quarkus.profile quarkus.config.profile.parent 如果父配置文件处于活跃状态时，如果在当前配置文件中找不到属性，查找父配置文件 12345678quarkus.profile=devquarkus.config.profile.parent=commonquarkus.http.port=8080%common.quarkus.http.port=9090quarkus.http.ssl-port=8443%dev.quarkus.http.ssl-port=9443 可以使用quarkus.profile自定义配置文件 123quarkus.profile=stagingquarkus.http.port=9090%staging.quarkus.http.test-port=9091 配置默认运行是配置文件可以在打包时指定应用程序的配置文件 123./mvnw package -Pnative -Dquarkus.profile=prod-aws#该命令将与prod-aws配置文件一起运行。这可以使用quarkus.profile配置覆盖./target/my-app-1.0-runner 属性表达式使用${ … }格式声明属性表达式，属性值会在构建是解析和替换，如果未提供属性值则会抛出NoSuchElementException异常 12remote.host=quarkus.iocallable.url=https://${remote.host}/ 属性表达式也适用于环境变量 12remote.host=quarkus.ioapplication.host=${HOST:${remote.host}} 生成UUID每次启动时都生成随机UUID 1mp.messaging.incoming.prices.group.id=${quarkus.uuid} 清除属性通过remote.host来清除属性 1remote.host=quarkus.io 索引属性12345my.collection=dog,cat,turtlemy.indexed.collection[0]=dogmy.indexed.collection[1]=catmy.indexed.collection[2]=turtle","link":"/2023/01/01/%E6%8A%80%E6%9C%AF%E6%A0%88/Java/Quarkus/Quarkus%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"tags":[{"name":"Arch","slug":"Arch","link":"/tags/Arch/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"fedora","slug":"fedora","link":"/tags/fedora/"},{"name":"Fedora","slug":"Fedora","link":"/tags/Fedora/"},{"name":"包管理器","slug":"包管理器","link":"/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"WebRTC","slug":"WebRTC","link":"/tags/WebRTC/"},{"name":"Docker 命令","slug":"Docker-命令","link":"/tags/Docker-%E5%91%BD%E4%BB%A4/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"非关系型数据库","slug":"非关系型数据库","link":"/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"LiveKit","slug":"LiveKit","link":"/tags/LiveKit/"},{"name":"Minio","slug":"Minio","link":"/tags/Minio/"},{"name":"S3","slug":"S3","link":"/tags/S3/"},{"name":"分布式文件系统","slug":"分布式文件系统","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Java标准库","slug":"Java标准库","link":"/tags/Java%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"Java8新特性","slug":"Java8新特性","link":"/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"},{"name":"SpringBootWeb框架集成","slug":"SpringBootWeb框架集成","link":"/tags/SpringBootWeb%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90/"},{"name":"SpringBoot数据库集成","slug":"SpringBoot数据库集成","link":"/tags/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90/"},{"name":"SpringBoot核心功能","slug":"SpringBoot核心功能","link":"/tags/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"},{"name":"SpringBoot源码解析","slug":"SpringBoot源码解析","link":"/tags/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Spring数据访问","slug":"Spring数据访问","link":"/tags/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"},{"name":"Spring核心功能","slug":"Spring核心功能","link":"/tags/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"},{"name":"Spring注解","slug":"Spring注解","link":"/tags/Spring%E6%B3%A8%E8%A7%A3/"},{"name":"Java语法","slug":"Java语法","link":"/tags/Java%E8%AF%AD%E6%B3%95/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Java框架","slug":"Java框架","link":"/tags/Java%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Transformers","slug":"深度学习/Transformers","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Transformers/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Arch","slug":"Linux/Arch","link":"/categories/Linux/Arch/"},{"name":"Fedora","slug":"Linux/Fedora","link":"/categories/Linux/Fedora/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/categories/Elasticsearch/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","link":"/categories/Linux/Ubuntu/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"LiveKit","slug":"LiveKit","link":"/categories/LiveKit/"},{"name":"Minio","slug":"Minio","link":"/categories/Minio/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"pytorch","slug":"深度学习/pytorch","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"Elixir","slug":"Elixir","link":"/categories/Elixir/"},{"name":"Dart","slug":"Dart","link":"/categories/Dart/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"Phoenix","slug":"Elixir/Phoenix","link":"/categories/Elixir/Phoenix/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Scrapy","slug":"Python/Scrapy","link":"/categories/Python/Scrapy/"},{"name":"Hadoop","slug":"Java/Hadoop","link":"/categories/Java/Hadoop/"},{"name":"Spring Boot","slug":"Java/Spring-Boot","link":"/categories/Java/Spring-Boot/"},{"name":"Spring","slug":"Java/Spring","link":"/categories/Java/Spring/"},{"name":"Spring MVC","slug":"Java/Spring-MVC","link":"/categories/Java/Spring-MVC/"},{"name":"Quarkus","slug":"Quarkus","link":"/categories/Quarkus/"}]}