{"pages":[],"posts":[{"title":"Fedora 初始化配置","text":"fedora 操作系统安装后相关环境配置 国内镜像北外镜像按照北外 fedora | 镜像站使用帮助 | 北京外国语大学开源软件镜像站 | BFSU Open Source Mirror 中的内容创建文件然后使用如下命令使用创建的文件覆盖 /etc/yum.repos.d/ 目录下的文件 12345678910# 首先进行备份[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora.repo ./backup/[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora-modular.repo ./backup/[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora-updates.repo ./backup/[zcy@fedora temp]$ cp /etc/yum.repos.d/fedora-updates-modular.repo ./backup/# 覆盖软件源[zcy@fedora temp]$ sudo cp -f ./fedora.repo /etc/yum.repos.d/fedora.repo [zcy@fedora temp]$ sudo cp -f ./fedora-modular.repo /etc/yum.repos.d/fedora-modular.repo [zcy@fedora temp]$ sudo cp -f ./fedora-updates.repo /etc/yum.repos.d/fedora-updates.repo[zcy@fedora temp]$ sudo cp -f ./fedora-updates-modular.repo /etc/yum.repos.d/fedora-updates-modular.repo 语言环境Java安装过程fedora默认自带新版的java，但是headless版本（最小java运行时），下面安装openjdk： 123456# 安装$ sudo dnf install java$ sudo dnf install java-17-openjdk-devel# 验证$ java --version$ jps Pythonfedora默认自带新版的Python Golang通过 dnf 命令安装 golang 1234$ sudo dnf install golang# 配置国内代理，否则使用go get会卡住$ go env -w GOPROXY=https://goproxy.cn,direct 不需要配置 GOROOT 和 GOPATH 环境变量，默认 GOPATH 为 *～/go/*，GOROOT 自动被设置为 /usr/lib/golang Rust安装过程1234# 获取管理工具并执行$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh# 验证是否安装成功$ rustc --version 更新过程1$ rustup update Dotnet安装过程fedora软件库中自带dotnet，直接安装即可 1$ sudo dnf install dotnet Nodejs12345678# 安装nodejs$ sudo dnf install nodejs# 查看版本node -v# 配置淘宝镜像源$ npm config set registry https://registry.npm.taobao.org$ npm config set disturl https://npm.taobao.org/dist 如果想要删除淘宝镜像执行如下语句： 123#删除镜像npm config delete registrynpm config delete disturl 软件安装Docker安装过程1234567891011121314151617181920212223$ sudo dnf update# 配置依赖库$ sudo dnf config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/fedora/docker-ce.repo# 安装最新版 docker 引擎$ sudo dnf install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 启动 docker$ sudo systemctl start docker# 查看 docker 版本$ docker -v# 配置阿里云镜像加速$ sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://nnjl45n3.mirror.aliyuncs.com&quot;]}EOF$ sudo systemctl daemon-reload$ sudo systemctl restart docker PostgreSQL安装过程在 fedora 中的 OS AppStream 存储库默认的存储库中就包含了 postgresql14，建议使用该方式安装 postgresq，另外也可以自己引入存储库下载 123456# 重置并启动module流$ sudo dnf module reset postgresql -y# 安装postgresql$ sudo dnf install vim postgresql-server postgresql# 初始化，数据和日志文件夹默认在 /var/lib/pgsql/ 目录下$ sudo postgresql-setup --initdb 远程访问首先配置防火墙 1234$ sudo firewall-cmd --add-service=postgresql --permanentsuccess$ sudo firewall-cmd --reloadsuccess 需要修改两个配置文件 12345678910111213141516171819202122# 第一个配置文件$ sudo vim /var/lib/pgsql/data/postgresql.conf# 修改内容如下#listen_addresses = 'localhost' # what IP address(es) to listen on;# 将监听地址设置为您的服务器 IP 地址或所有接口或特定 IP 地址/子网的“ * ”。listen_addresses = '*'# 第二个配置文件$ sudo vim /var/lib/pgsql/data/pg_hba.conf# # local DATABASE USER METHOD [OPTIONS]# host DATABASE USER ADDRESS METHOD [OPTIONS]# hostssl DATABASE USER ADDRESS METHOD [OPTIONS]# hostnossl DATABASE USER ADDRESS METHOD [OPTIONS]# hostgssenc DATABASE USER ADDRESS METHOD [OPTIONS]# hostnogssenc DATABASE USER ADDRESS METHOD [OPTIONS]# 0.0.0.0/0代表任何地点的连接，也可以设置为信任的子网，如：10.10.10.0/24host all all 0.0.0.0/0 md5# 更改完毕后重启`postgresql`$ sudo systemctl restart postgresql 配置密码postgresql 默认用户名为Postgres，没有密码。通过以下命令修改密码： 1234[xxx@fedora ~]$ sudo su - postgres# 将123456设置为postgresql的密码[postgres@fedora ~]$ psql -c &quot;alter user postgres with password '123456'&quot;ALTER ROLE MySQL安装过程1234567#fedora存储库中自带mysql社区版$ sudo dnf install community-mysql-server#启动服务$ sudo systemctl start mysqld.service$ sudo systemctl status mysqld.service#开机启动$ sudo systemctl enable mysqld.service 远程访问123#配置防火墙sudo firewall-cmd --add-service=mysql --permanentsudo firewall-cmd --reload 配置密码其他方式可能在安装mysql时会生成一个随机密码，但通不过本方式默认密码为空 12345mysql -u root -p&gt; use mysql;&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; &gt; flush privileges;&gt; quit; Redis安装过程12345678# 安装$ sudo dnf install redis# 启动$ systemctl statrt redis# 设置开机启动，redis默认开机不会启动$ systemctl enable redis# 查看状态$ systemctl status redis 远程访问123456#注释bind，或改成自己的ip地址#bind 127.0.0.1 -::1# yes -&gt; noprotected-mode no# 去掉注释，设置自己的密码requirepass 123456 Mongodb安装过程fedora 默认不包含 mongodb 软件包，所以需要主动引入，建立 /etc/yum.repos.d/mongodb.repo 文件并填充如下内容： 1234567# 这里使用阿里云镜像[mongodb-org]name = MongoDB Repositorybaseurl = https://mirrors.aliyun.com/mongodb/yum/redhat/8Server/mongodb-org/5.0/x86_64/gpgcheck = 1 enabled = 1 gpgkey = https://www.mongodb.org/static/pgp/server-5.0.asc 添加完软件源后下载 mongodb，由于 fedora 移除了platform-python 所以此时使用 sudo dnf install mongodb-org 命令下载 5.0 以上版本的 mongodb 时会报错，正确的方式是单个组件下载： 1$ sudo dnf install mongodb-org-server mongodb-org-shell mongodb-database-tools mongodb-org-mongos 下载完成后需要重启电脑才会生效 远程访问进入 /etc/mongod.conf 文件修改如下内容： 12345net: bindIp: 127.0.0.1# 改为net: bindIp: 0.0.0.0 设置用户名和密码mongodb 默认没有安全认证，不需要用户名密码即可连接和操作 mongodb。用户名密码创建过程如下： 进入 mongodb 执行以下语句 12345678910use admindb.createUser({ user: 'username', // 用户名（自定义） pwd: 'password', // 密码（自定义） roles:[{ role: 'root', // 使用超级用户角色 db: 'admin' // 指定数据库 }]}) 进入 /etc/mongod.conf 添加如下内容： 12security: authorization: enabled 重启 mongodb 1$ sudo service mongod restart 设置用户组默认情况下使用docker命令必须通过sudo，如果想直接使用命令执行如下操作 123sudo groupadd dockersudo usermod -aG docker 用户名newgrp docker Neo4j安装过程docker单节点fedora包中没有neo4j，所以使用docker安装，便于更新版本 123456789101112131415# 拉取镜像$ docker pull neo4j# 查看镜像是否拉取成功$ docker images# 启动容器# -d表示容器后台运行，--name指定容器名字，-p端口号映射，-v挂载数据卷，-e设置环境变量（登录neo4j的用户名和密码）$ docker run -d --name neo4j \\ -p 7474:7474 -p 7687:7687 \\ -v /opt/neo4j/data:/data \\ -v /opt/neo4j/logs:/logs \\ -v /opt/neo4j/conf:/var/lib/neo4j/conf \\ -v /opt/neo4j/import:/var/lib/neo4j/import \\ --env NEO4J_AUTH=neo4j/123456 neo4j# 查看启动日志$ docker logs -f neo4j 日志提示容器启动成功后，访问如下连接进入neo4j的控制台 http://192.168.2.113:7474/ http://localhost:7474/ Elasticsearch安装过程123456789101112131415# 导入rpm源$ vim /etc/yum.repos.d/elasticsearch.repo#添加如下内容[elasticsearch]name=Elasticsearch repository for 8.x packagesbaseurl=https://artifacts.elastic.co/packages/8.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=0autorefresh=1type=rpm-md# 更新$ sudo dnf upgrade -refresh# 安装 elasticsearch$ sudo dnf install --enablerepo=elasticsearch elasticsearch MinIO安装过程单节点docker部署12345678$ docker run -d\\ -p 9000:9000 \\ -p 9001:9001 \\ --name minio \\ -v /opt/minio/data:/data \\ -e &quot;MINIO_ROOT_USER=zcy&quot; \\ -e &quot;MINIO_ROOT_PASSWORD=123456789&quot; \\ quay.io/minio/minio server /data --console-address &quot;:9001&quot; anacondaanaconda集成了很多python库，并且内置python环境 安装过程1234567891011121314151617181920# 首先去官网下载安装包，下载后是一个.sh文件# 执行该安装文件$ bash Anaconda3-2022.05-Linux-x86_64.sh# 1.点击回车# 2.按q跳过阅读# 3.目录选择默认目录，会安装到当前用户的主目录# 4.初始化选择no，后面手动配置# 配置环境变量$ vim .bash_profile# 加入如下配置#anacondaexport PATH=:$PATH:/home/zcy/anaconda3/bin$ source .bash_profile# 验证$ conda --version$ pip --version# 创建自己的环境# -n后接自定义的环境名# python=python版本号$ conda create -n 喜欢的名字 python=3.9.12 配置镜像1234567891011121314151617181920212223# 若没有.condarc文件，则运行命令生成配置文件# conda config --set show_channel_urls yes# 配置北外镜像源$ vim .condarc#输入如下内容channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.bfsu.edu.cn/anaconda/cloud simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud$ conda clean -i# 查看镜像源$ conda config --show-sources","link":"/2022/06/25/linux/fedora/feaora%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"},{"title":"Fedora 包管理器","text":"fedora 使用 yum 的升级版 dnf 作为包管理器 存储库保存存储库的文件夹路径如下： /etc/yum.repos.d 该文件夹内部包含了很多以 .repo 为后缀的文件，这里每个文件就是一个存储库，yum/dnf 会根据这些存储库来查找软件包 存储库操作添加存储库1sudo dnf config-manager -add-repo https://download.docker.com/linux/fedora/docker-ce.repo","link":"/2022/06/25/linux/fedora/fedora%20%E5%AD%98%E5%82%A8%E5%BA%93/"},{"title":"Ubuntu 初始化配置","text":"ubuntu 操作系统安装后相关环境配置 国内镜像网络包12#网络工具包：ipconfigsudo apt install net-tools 阿里云镜像1234567891011# 在打开的文本中，添加阿里源deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse 语言环境Java安装过程123sudo apt install openjdk-版本号-jdk#查看版本号java -version 软件安装Docker安装过程12345678910111213141516171819202122sudo apt update#必要依赖sudo apt install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release#获取密钥curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gp#依赖源echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt update#安装sudo apt install docker-ce docker-ce-cli containerd.io#开机启动sudo systemctl enable docker#启动dockersudo systemctl start docker MySQL安装过程12345sudo apt install mysql-server#进入mysql，如果无法进入，则进行自定义密码mysql -u root -p#查看版本号select version(); 自定义密码1234567891011121314151617sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf#在文件中[mysql]下方添加skip -grant-tables#重启服务sudo systemctl restart mysql.service#自定义密码过程mysql -u root -puse mysql;update user set authentication_string='' where user='root';update user set plugin='mysql_native_password' where user='root';flush privilegesALTER user 'root'@'localhost' IDENTIFIED BY '123456';quitsudo systemctl enable mysql.service#开机启动sudo systemctl enable mysql.service 配置远程访问123456789101112#mysql配置文件/etc/mysql/mysql.conf.d/mysqld.cnf#注释 bind-address 127.0.0.1#重启服务sudo systemctl restart mysql.service#如果还无法连接则执行以下操作mysql -u root -p#结果中 user为root host为localhostselect user,host from user;#修改访问权限update user set host = '%' where user = 'root';select host from user where user = 'root'; Redis安装过程123456sudo apt updatesudo apt install redis-server#server版本redis-server --version#clli版本redis-cli -v 配置远程访问12#配置 Redis 远程访问vim /etc/redis/redis.conf 在文件夹中执行以下步骤 bind 127.0.0.1 ::1改为bind 0.0.0.0 查找protected-mode yes 把yes改为no （可选）将requirepass foobared取消注释，将foobared替换成自己的密码 MongoDB安装过程1234567891011121314151617181920sudo apt update#获取密钥wget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add -#必要依赖apt-get install gnupgsudo apt-get install libssl1.1#添加依赖源echo &quot;deb [ arch=amd64,arm64 ] http://mirrors.tuna.tsinghua.edu.cn/mongodb/apt/ubuntu focal/mongodb-org/5.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.listecho &quot;deb http://security.ubuntu.com/ubuntu impish-security main&quot; | sudo tee /etc/apt/sources.list.d/impish-security.list#更新sudo apt update#安装sudo apt-get install -y mongodb-org#开机启动sudo systemctl enable mongodb.service#启动sudo systemctl start mongodb.service#或sudo mongod -dbpath=/data/mongodb --logpath=/data/mongodb.log 远程访问1234#mongodb配置文件sudo vim /etc/mongod.conf#修改127.0.0.1 -&gt; 0.0.0.0 ElasticSearchdocker安装es过程12345678910111213141516171819202122232425262728docker pull elasticsearch:7.10.1docker pull kibana:7.10.1mkdir -p /data/elasticsearch/configmkdir -p /data/elasticsearch/datamkdir -p /data/elasticsearch/datachmod -R 777 /data/elasticsearch/echo &quot;http.host: 0.0.0.0&quot; &gt; /data/elasticsearch/config/elasticsearch.yml#启动es#访问 ip:9200docker run --name=&quot;elasticsearch&quot; -p 9200:9200 -p 9300:9300 \\ -e &quot;discovery.type=single-node&quot; \\ -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \\ -v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /data/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /data/elasticsearch/config/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.10.1#启动kibana#访问 ip:5601docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.1.5:9200 -p 5601:5601 -d kibana:7.10.1#之后启动使用docker start es容器iddocker start kibana容器id","link":"/2022/05/29/linux/ubuntu/Ubuntu%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"},{"title":"Ubuntu 包管理器","text":"ubuntu 是基于 debian 的发行版，使用 apt 作为包管理器 依赖源Ubuntu中仓库有两个位置： /etc/apt/sources.list：该文件内部存储源数据 123deb http://security.ubuntu.com/ubuntu jammy-security multiverse# deb-src http://security.ubuntu.com/ubuntu jammy-security universedeb http://security.ubuntu.com/ubuntu jammy-security multiverse */etc/apt/sources.list.d/*：该文件夹包含多个文件，每个文件名字可以是任意的，内如包含其软件源 1deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu jammy stable 在这两个位置就可以对软件源进行管理，修改后更新 1sudo apt update 密钥查看密钥1$ apt-key 添加密钥123sudo apt-key add 密钥值#举例wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - 删除密钥123456$ sudo apt-key del 密钥后8位#举例$ sudo apt-key del &quot;3820 03C2 C8B7 B4AB 813E 915B 14E4 9429 73C6 2A1B&quot;$ sudo apt-key del &quot;73C62A1B&quot;#删除后更新$ sudo apt update","link":"/2022/05/29/linux/ubuntu/Ubuntu%20%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"Kubernetes 架构及概念","text":"kubernetes 使用主从结构管理集群，本章介绍主从节点上的相关组件及概念 Kubernetes 架构Kubernetes 的架构图如下所示 由图中可以看出，Kubernetes 主要由 一系列组件组成，其中核心组件包括etcd、apiserver、controller manager、scheduler、kubelet、Container runtime 和 kube-proxy。节点分为 Master和 Node，他们的组件各不相同，Master主要用于对集群进行管理，而 Node用来部署服务。 MasterMaster负责管理整个集群，协调集群中的所有活动，例如调度应用、维护应用所需的状态、应用扩展以及推出新的更新。 Apiserverapiserver 是 Kubernetes 中向外提供的接口，任何资源的操作都需要以 apiserver 作为入口。此外 apiserver 还提供了认证、授权、访问控制、API注册和发现的机制 Etcdetcd 是一个用来存储键值对形式数据的分布式数据库。在 Kubernetes 中 etcd 一般以集群的形式被部署，用于向 Kubernetes 提供键值对数据的存储服务。Kubernetes 会通过它保存整个集群的状态信息。 Controller Managercontroller manager 用于管理集群中的各种控制器，这些控制器的功能包括维护集群的状态，比如故障检测、自动扩展、滚动更新等。这些控制器包括 节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应。 任务控制器（Job controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成。 端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）。 服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌。 node controller（节点控制器）节点控制器（node controller）是管理节点的Master组件，用来控制Node，它有如下作用： 在注册时为Node分配CIDR格式的地址空间 使节点控制器的内部列表与可用机器列表保持最新 检测Node的健康状态，当有Node不健康时会根据当前不健康Node所占的百分比来对Node进行驱逐（转移到健康节点） schedulerscheduler 负责资源的调度，按照配置文件中设定的调度策略将 Pod 调度到相应的机器上。 NodeNode是Kubernetes中的工作节点（一台虚拟机或物理机），以前也被称为minion。Node的目的就是保证对其上运行的Pod进行管理，每个Node拥有运行Pod的必要服务并由Master进行管理。Node的组件包括 kube-proxy 和 Container runtime。 Node状态Node的状态信息包括： Addresses：取决于云提供商和主机配置 选项 说明 HostName 包含主机名，可以通过kubelet 中 --hostname-override参数覆盖 ExternalIP 可以被集群外部路由到的IP InternalIP 只能在集群内部路由的节点IP Condition：描述所有Running节点的状态 Node状态 说明 OutOfDisk True代表节点上没有足够空间来增加新的Pod，反之为False Ready True：节点是健康的并且准备号接收PodFalse：节点不健康且不接收PodUnKnown：节点控制器在过去40秒内没收到Node的状态报告 MemoryPressure True代表节点内存过低，反之为False DiskPressure True代表节点磁盘容量低，反之为False Capacity：描述Node上的可用资源：CPU、内存、可容纳的最大Pod数 Info：Node的基础信息，如内核版本、Kubernetes版本、Docker版本等 Node会定期与Master的apiserver进行通信发送状态报告，如果Node发送的状态中的condition为Unknown或长时间没有发送状态报告，那么节点控制器就会将该Node上的所有Pod标记并计划将这些被标记Pod再分配到其他Node上。在1.5版本之前的Kubernetes中会将这些Pod直接删除，如果此时Node与apiserver无法进行通信，那么会等可以通信时再删除。 Node组件kube-proxykube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 kube-proxy是一个分布式的代理服务器，部署在每个Node节点上，为集群提供负载均衡和服务发现的能力。思考一下，在Kubernetes集群中，一个微服务可能部署在多个Pod上，那么用户访问时究竟要访问哪个呢？此时 kube-proxy就充当了负载均衡器的职责，一个Service API对象会对应着一个集群内部的有效虚拟ip，集群内可以通过这个虚拟ip来访问一个服务，这个过程中kube-proxy会为 Service 提供内部的服务发现和负载均衡。 Container runtimeContainer runtime 是负责运行容器的软件。 kubeletkubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理。 Node容量节点的容量（CPU数量和内存数量）是节点对象的一部分。通常，节点在创建节点对象时注册并通知其容量。 Master-Node通信Node-&gt;Master集群中的Node想要访问Master节点只有一个接口，就是apiserver。在进行通信时保证安全的连接到apiserver，所以一需要为Node配置证书。 Master-&gt;NodeMaster连接Node有两种方式： 从apiserver到kubelet：默认不需要证书 从apiserver到Node、Pod、Service：默认使用HTTP连接，不需要证书，如果需要安全证书可以使用HTTPS连接。 Kubernetes 概念Kubernetes 是一个分布式系统拥有一套自己的设计理念，下面将分别对 Kubernetes 的设计原则和核心概念进行介绍 API设计原则 Kubernetes 中 API 的设计都是声明式的，即通过配置文件的方式而不是命令式，这样尽可能的隐藏了实现细节，更便于用户的使用。 在Kubernetes中API可以分为高层API和底层API，高层API以业务角度出发，针对系统调度管理容器的操作意图为基础而设计，底层API根据高层API的需要而设计，目的是更好的被高层API所使用，提高复用性。在设计API的过程中Kubernetes尽量避免没有提供新功能的简单封装，因为这回增加系统的依赖。 由于网络因素是不可控制的，所以Kubernetes中的API是不依赖网络的。由于Kubernetes维护的是一个居群，所以保证集群的全局状态同步时非常困难的，所以Kubernetes的API也不能依赖全局状态。","link":"/2022/05/10/tools/Kubernetes/Kubernetes%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%A6%82%E5%BF%B5/"},{"title":"Kubernetes 配置及命令","text":"使用 kubernetes 时主要通过命令和配置文件的方式描述核心组件操作 API 对象的目标状态，本篇介绍核心技术中各个组件的不同配置方式 kubectl工具支持三种对象管理方式： 命令式对象管理：使用一条条指令操作对象 命令式对象配置：通过命令配置和配置文件操作对象 声明式对象配置：通过apply命令和配置文件操作对象 命令式对象管理使用kubectl命令行工具提供的指令对对象进行管理，语法格式如下： 1kubectl [command] [type] [name] [flags] command：执行的操作 type：对象的类型 name：指定对象的名称，大小写敏感 flags：额外的参数 说明： 为节省位置，后文列出的命令都省略了kubectl。 常用对象 对象分类 对象名称 缩写 对象作用 集群级别对象 nodes no 集群组成部分 namespaces ns 隔离Pod pod对象 pods po 装载容器 pod对象控制器 replicationcontrollers rc 控制pod对象 replicasets rs 控制pod对象 deployments deploy 控制pod对象 daemonsets ds 控制pod对象 jobs 控制pod对象 cronjobs cj 控制pod对象 horizontalpodautoscalers hpa 控制pod对象 statefulsets sts 控制pod对象 服务发现对象 services svc 统一pod对外接口 ingress ing 统一pod对外接口 存储对象 volumeattachments 存储 persistentvolumes pv 存储 persistentvolumeclaims pvc 存储 配置对象 configmaps cm 配置 secrets 配置 常用指令 命令分类 命令 命令作用 基本命令 create 创建对象 edit 编辑对象 get 获取对象 patch 更新对象 delete 删除对象 explain 展示对象文档 运行和调试 run 在集群中运行一个指定的镜像 expose 暴露对象为Service describe 显示对象内部信息 logs 输出容器在 pod 中的日志 attach 进入运行中的容器 exec 执行容器中的一个命令 cp 在Pod内外复制文件 rollout 管理对象的发布 scale 扩(缩)容Pod的数量 autoscale 自动调整Pod的数量 高级命令 apply 通过文件对对象进行配置 label 更新对象上的标签 其他命令 cluster-info 显示集群信息 version 显示当前Server和Client的版本 api-versions 查看apiVersion 命令式对象配置命令式对象配置是使用配置文件和命令想结合的方式管理对象。操作步骤如下： 首先编写配置文件，配置文件内包含对对象的声明和约束 使用命令执行配置文件进而操作对象 常用命令 命令 命令作用 create -f &lt;filename|url&gt; 创建对象 replace -f &lt;filename|url&gt; 更新对象 delete -f &lt;filename|url&gt; 删除对象 get -f &lt;filename|url&gt; -o yaml 查看对象 声明式对象配置声明式对象配置是将所有对于对象的描述都声明在配置文件中，只需要执行apply命令执行配置文件目录，Kubernetes会创建指定目录中配置文件所定义的所有对象除非对应对象已经存在： 常用命令 命令 命令作用 apply -f &lt;目录/&gt; 创建/更新对象，添加-R可以递归地处理目录 diff -f &lt;配置文件|目录/&gt; 打印出将被创建的对象 get -f &lt;配置文件&gt; 打印现时配置 delete -f &lt;文件名&gt; 删除对象 在使用apply命令后也可以手动使用命令来更新集群的配置，比如使用scale进行扩容时，当前最新的配置就叫现时配置。 配置文件Kubernetes配置文件可以为YAML或JSON，官方推荐使用YAML。配置文件中有如下基本项 12345apiVersion: v1 #使用的api版本，一般为v1，代表的稳定版本kind: Pod #对象的类型metadata: #对象的元数据，如namespace、name、label等spec: #指定对象的目标状态，对于不同类型的对象也有不同的值status: #对象的当前状态，不需要 Workload APIPod 配置123456789101112131415161718192021222324252627282930apiVersion: v1kind: Podmetadata: name: Pod—examplespec: #Pod包含的容器列表，一个Pod中至少要有一个容器 containers: #容器名称 - name: con-name #指定镜像 image: image #容器运行时执行的命令 command: [&quot;echo&quot;] #命令的参数 args: [&quot;Hello,world&quot;] #从容器公开的端口列表 ports: - containerPort: 80 #容器内部环境变量 - env: #环境变量名 - name: GRPC_PORT #环境变量值 value: &quot;8080&quot; #node从最后一次处于活动状态到标记为失败并终止持续的时间，单位：秒 activeDeadlineSeconds: 3 #Pod的主机名，不指定默认为主机系统设置的值 hostname: host-name #将Pod调度到指定的Node上，如果该Node资源符合要求的话 nodeName: node—name Deployment 配置1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: deployment-examplespec: #副本数 replicas: 3 #Pod的标签选择器，符合匹配条件的副本集的Pod才会受本次Deployment的影响 selector: matchLabels: app: nginx #模板规范，描述将要创建的Pod template: metadata: labels: app: test spec: containers: - name: test image: test-image Job 配置12345678910111213141516171819apiVersion: batch/v1kind: Jobmetadata: name: job-examplespec: #指定所需要完成任务的Pod数量 completions: 3 #任务执行时创建的Pod template: metadata: name: example-job spec: containers: - name: job-con-name image: job-image command: [&quot;perl&quot;] args: [&quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;] #指定容器结束后不会重启 restartPolicy: Never ReplicationController 配置1234567891011121314151617181920212223apiVersion: v1kind: ReplicationControllermetadata: name: RC-examplespec: #副本数 replicas: 3 #新建pod完成后要持续指定的时间该Pod才被视为可用，默认为0，单位：秒 minReadySeconds: 1 #标签选择器，符合匹配条件的Pod才会被副本集管理 selector: matchLabels: app: nginx #检测到副本不足时会创建的pod模板 template: metadata: labels: app: nginx spec: containers: # Run the nginx image - name: nginx image: nginx:1.14 ReplicaSet 配置12345678910111213141516171819202122apiVersion: apps/v1kind: ReplicaSetmetadata: name: RS-examplespec: #副本数量 replicas: 3 #新建pod完成后要持续指定的时间该Pod才被视为可用，默认为0，单位：秒 minReadySeconds: 1 #标签选择器，符合匹配条件的Pod才会被副本集管理，在RC基础上增加了equality-based匹配机制 selector: matchLabels: app: nginx #检测到副本不足时会创建的pod模板 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14 Service APIService 配置123456789101112131415161718192021222324252627282930kind: ServiceapiVersion: v1metadata: name: service-examplespec: #向外公开的端口数组 ports: #端口的名称 - name: http #容器要公开的端口 port: 80 #在Pod上要访问的端口号或名称 targetPort: 80 #此端口的IP协议，支持TCP、UDP、SCTP，默认TCP protocol: UDP #标签选择器，将服务流量转发到符合匹配条件的Pod，不适用于ExternalName方式 selector: app: nginx #服务向外暴露的方式，支持ClusterIP（默认）、ExternalName、NodePort 、LoadBalancer #ClusterIP：为Endpoint分配一个集群内部IP地址 #NodePort：在每个Node上分配一个端口，该端口路由到与clusterIP相同的Endpoint #LoadBalancer：基于NodePort构建并创建一个外部负载均衡器，它路由到与clusterIP相同的端点 #ExternalName：将此服务的别名为指定为externalName，其他几个字段不适用于ExternalName服务 type: LoadBalancer #外部服务别名 externalName: external-service-name #外部IP地址列表 externalIPs: - 192.168.2.5 - 192.168.2.6","link":"/2022/05/23/tools/Kubernetes/Kubernetes%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/"},{"title":"Kubernetes 核心技术","text":"Kubernetes 提供了一系列核心组件并通过API对象来管理集群，本章介绍开发过程中直接使用到的组件的相关概念 API对象Kubernetes中的任何管理操作都是使用API进行的。Kubernetes引入的每一个新技术都会新引入对应的API对象。配置文件和控制都与API对象密切相关，常用的API对象如下所示： API功能 API对象 作用 副本控制器 RC 保证集群中有指定数量的Pod副本 副本集 RS 新一代的RC，功能RC，支持集合匹配 部署 Deployment 用来新建或升级一个服务 服务 Service 配合kube-proxy完成服务发现和负载均衡功能 任务 Job 用来控制单Pod或多Pod的批处理任务的执行 存储卷 Volume 和Docker的Volume类似，只不过作用范围是一个Pod，用于这个Pod内的文件目录挂载 节点 Node 所有Pod运行所在的工作主机 命名空间 Namespace 提供虚拟隔离作用 API对象的三大属性每个API对象都有3大属性： 元数据（metadata）：metadata是用来标记API对象的，每个API对象都至少有3个元数据，除此之外还可以使用标签（labels）来表示和匹配不同对象： Namespace：Namespace用于将集群资源划分为多个Namespace分配指定的资源，在本Namespace中声明的Pod必须遵守和Namespace一样的资源限制。相同的Namespace中的对象将具有相同的访问控制策略。大多数Kubernetes资源（Pod、services、replication controllers等）都在某些Namespace中，但Namespace资源本身并不在Namespace中。而低级别资源（如Node和persistentVolumes）不在任何Namespace中。Events是一个例外：它们可能有也可能没有Namespace，具体取决于Events的对象。 Name：在一个Namespace内Name是唯一的。 UID：在Kubernetes集群中每个对象的UID是唯一的。 规范（spec）：spec描述了用户期望Kubernetes集群中的分布式系统达到的理想状态，例如期望每个Pod的副本数为3；Kubernetes中所有的配置都是通过API对象的spec设置的。 状态（status）：status描述了当前系统的状态，例如期望Pod副本数为3，而当前Pod副本数为2，那么之后就会启动新的Pod争取达到3个副本。 LabelsLabels是一对Key/Value形式的键值对，一般用来标记一组有共同特点的API对象，声明在对象的metadata部分。可以在创建API对象时声明，也可以在后期随时修改。每个API对象可拥有多个Label，但Label的key必须是唯一的。Labels的书写格式如下： key由前缀和名称组成，之间用/分隔。其中前缀是可选的，如果选择使用前缀，那么必须是DNS子域，通过.划分，不能超过253个字符。名称的书写格式与value一样。 value最多63个字符，以[a-z0-9A-Z]带有虚线（-）、下划线（_）、点（.）组成，并且开头和结尾必须是字母或数字。 Labels Selector通过标签选择器（Labels Selectors），客户端/用户能方便辨识出一组对象。标签选择器是kubernetes中核心的组成部分。当前支持两种标签选择器： equality-based（基于相等）：通过=，==和!=三种运算符判断相等性，=和==含义相同 12env = production #所有存在key为env，且value为production的资源env != production #所有存在key为env，且value不为production的资源 + 所有不存在key为env的资源 set-based（基于集合）：in ， notin 和 exists(仅针对于key符号)判断标签，逗号（,）代表and。 1234env in (production, test) #所有key为env，且value为production或test的资源env notin (production, test) #所有key为env，且value不为production和test的资源 + 所有不包含key为env的资源env #所有存在一个key为env的资源!env #所有不存在key为env的资源 set-based和equality-based可以结合使用，例如： 1env = pro,partition in (A,B) 配置文件中API对象的引用也是有标签选择器来指定其他资源的集合。 Volume Docker中的Volume是将磁盘中的一个目录和容器内的目录形成一个映射关系，达到挂载文件夹的效果，没有明确的声生命周期。而Kubernetes的Volume是具有生命周期的（与Pod相同），所以Volume会比Pod中的任何容器运行的都持久，当pod内的容器被重新启动时也能保留数据，当Pod被删除时Volume也会消失。 在Kubernetes使用Volume需要指定Volume的类型和内容。Volume支持很多类型，不同类型就是指将不同位置的文件夹路径挂载到Kubernetes，比如本机、云上、分布式文件系统等。下面介绍Volume中常用的Volume类型 emptyDir当Pod被分配到Node上时，emptyDir会被创建，当Pod被从Node上删除时，emptyDir也被同时删除，所以一般用于缓存。 hostPathhostPath应用于将Node的文件系统挂载到Pod上，一般当Pod需要用到本机文件时使用。 PodPod是Kubernetes用来管理和部署的最小基本单位，一个Pod代表集群上一个正在运行的进程，其内可包含一个或多个容器 Pod内运行一个容器：可以把pod当作是一个容器，但Kubernetes管理的仍是Pod而不是容器。 Pod内运行多个容器：多个容器需要一起工作，他们之间可以共享资源，网络（IP地址和端口）和存储（一组共享存储volumes），推荐只在多容器紧密耦合的情况中使用。 ServiceService通过selector和一组Pod产生关联。Kubernetes在创建Service时endpoint controller会根据Service关联到的Pod的IP信息生成一个与Service同名的Endpoint对象。如果没有指定selector，则创建Service时不会自动生成Endpoints对象，需要通过手动构造Endpoints或EndpointSlice。Endpoints的信息存储在etcd中，用来记录一个service对应的所有pod的访问地址。 DeploymentDeployment为Pod和RS提供声明式更新。只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会自动将 Pod 和ReplicaSet 的实际状态改变到您的目标状态。 JobJob是用来在Kubernetes中进行批处理任务的API对象。任务标志完成后就退出，不会用不停止的运行下去。根据指定的策略不同，完成条件也不同，比如有一个Pod执行成功就标志完成或者N个任务全部完成再退出。 StatefulSets在具有以下特点时使用StatefulSets： 稳定性，唯一的网络标识符。 稳定性，持久化存储。 有序的部署和扩展。 有序的删除和终止。 有序的自动滚动更新。 Replication Controller，RCRC跨多个Node节点监视多个Pod，其作用如下： RC用来确保集群中Pod的副本数，如果Pod过多，则RC会终止额外的Pod，如果Pod过少，则RC会创建新的Pod，使Pod副本数一直处在指定的范围内。 RC会替换由于某些原因而被删除或终止的Pod。 Replica Set，RSRS时RC的升级版，它们之间的唯一区别是RS强化了对选择器的支持，RS可以使用equality-based和set-based两种方式，而RC只能使用set-based方式。RS可以独立使用，但主要与Deployment配合使用。Deployment会对ReplicaSet对象进行管理。","link":"/2022/05/15/tools/Kubernetes/Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"title":"Redis（一）库","text":"Redis 中默认有16个库 redis的db对于单体的redis默认提供了0-15共计16个库，刚进入redis时默认使用的是0号db，可通过select命令进行切换 12127.0.0.1:6379&gt; select 1OK 可以通过调整Redis的配置文件redis/redis.conf中的databases来修改这一个值，设置完毕后重启Redis便完成配置。另外在集群的情况下不支持使用select命令来切换db，因为redis集群模式下只有一个db0。 在spring boot项目中也可以指定db 12# redis db索引，默认为0app.redis_database = 0 为什么要设计16个db由于Redis不支持自定义db的名字，所以每个db都以编号命名。另外Redis也不支持为每个db设置不同的访问密码，所以一个客户端要么可以访问全部db，要么全部db都没有权限访问。可通过flushall命令清空一个redis实例所有的db 12127.0.0.1:6379[1]&gt; flushallOK 我们常用的关系型数据库，如mysql中，各个db是相互隔离的，不同db用来存储不同应用程序的数据，而redis的db更适合作为命名空间来使用，不同的数据库可用于存储不同环境的数据。比如可以使用0号db存储某个应用生产环境中的数据，使用1号db存储测试环境中的数据，多个应用程序不应使用同一个redis不同库，而是应一个应用程序对应一个redis实例。由于redis是轻量级的，一个空的redis只占用1mb左右的内存，所以不用在意空间不足的问题。","link":"/2021/05/22/database/Redis/Redis(%E4%B8%80)%20%E5%BA%93/"},{"title":"Spring Boot Web 框架集成：SpringMVC","text":"Spring Boot 集成 mvc 框架流程 Servlet Web核心配置构建基于servlet的Web应用程序，可以利用spring boot对spring mvc或jersey的自动配置 Spring MVC 自动配置spring mvc 是一个丰富的“模型视图控制器”Web框架，它允许创建@controller或@restController的bean来处理传入的HTTP请求。控制器中的方法通过使用@requestMapping注释与http请求进行映射。 spring mvc自动配置提供以下功能 包括ContentNegotiatingViewResolver和BeanNameViewResolver豆。 支持提供静态资源，包括对 WebJars 的支持。 自动注册Converter，GenericConverter和Formatter豆类。 支持HttpMessageConverters。 的自动注册MessageCodesResolver。 静态index.html支持。 ConfigurableWebBindingInitializerbean 的自动使用。 Spring MVC 自动配置原理根据spring.factories文件可以找到spring mvc的自动配置类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//配置类@Configuration( proxyBeanMethods = false)//web环境@ConditionalOnWebApplication( type = Type.SERVLET)//当前类路径下存在Servlet, DispatcherServlet,WebMvcConfigurerAdapter@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})//beanFactory中不存在WebMvcConfigurationSupport类型的bean@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})//加载的优先级@AutoConfigureOrder(-2147483638)//在DispatcherServletAutoConfiguration, ValidationAutoConfiguration 加载后进行装配@AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})public class WebMvcAutoConfiguration { //... @Bean @ConditionalOnMissingBean({HiddenHttpMethodFilter.class}) @ConditionalOnProperty( prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = false ) public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter(){} @Bean @ConditionalOnMissingBean({FormContentFilter.class}) @ConditionalOnProperty( prefix = &quot;spring.mvc.formcontent.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = true ) public OrderedFormContentFilter formContentFilter(){} //配置类 @Configuration(proxyBeanMethods = false) //交由OnEnabledResourceChainCondition进行判断 //内部是通过OnEnabledResourceChainCondition类进行判断 //主要就是获取各种xxx.enabled的配置，然后进行判断 @ConditionalOnEnabledResourceChain static class ResourceChainCustomizerConfiguration{} //配置类 @Configuration(proxyBeanMethods = false) public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware{} //配置类 @Configuration( proxyBeanMethods = false) //加载该配置类时会先加载上面的EnableWebMvcConfiguration类 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) @EnableConfigurationProperties({WebMvcProperties.class, ResourceProperties.class}) @Order(0) public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer{} //...} 接下来对上面列出的部分进行分析： 生效条件该配置类中包含三个条件注解，前两个分别限制了当前项目的环境（Type.SERVLET）和存在必要的类（Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class）。最重要的是第三个条件注解，也就是@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})，它说明如果此时的ioc容器中含有WebMvcConfigurationSupport接口的实现类，那么当前的自动配置类就会失效，这就是@EnableWebMvc注解生效的原理。 内部配置类WebMvcAutoConfiguration有三个内部配置类，接下来对其分别进行分析： 1、ResourceChainCustomizerConfiguration 其内部只有一个@bean方法，它主要是用来处理静态资源的 1234567@BeanWebMvcAutoConfiguration.ResourceChainResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer() { @Bean WebMvcAutoConfiguration.ResourceChainResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer() {...}} 2、EnableWebMvcConfiguration 该类继承了DelegatingWebMvcConfiguration类（@EnableWebMvc注解导入的那个类），所以他的功能其实与@EnableWebMvc注解一样 1234567891011121314151617181920public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware { @Bean public RequestMappingHandlerAdapter requestMappingHandlerAdapter(...){...} @Bean @Primary public RequestMappingHandlerMapping requestMappingHandlerMapping(...){...} @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(...){...} @Bean public FormattingConversionService mvcConversionService() {...} @Bean public Validator mvcValidator(){...} @Bean public ContentNegotiationManager mvcContentNegotiationManager(){...}} 3、WebMvcAutoConfigurationAdapter 该类实现了WebMvcConfigurer接口 12345678910111213141516171819202122232425262728293031323334public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer { @Bean @ConditionalOnMissingBean public InternalResourceViewResolver defaultViewResolver(){...} @Bean @ConditionalOnBean({View.class}) @ConditionalOnMissingBean public BeanNameViewResolver beanNameViewResolver(){...} @Bean @ConditionalOnBean({ViewResolver.class}) @ConditionalOnMissingBean( name = {&quot;viewResolver&quot;}, value = {ContentNegotiatingViewResolver.class} ) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory){...} @Bean @ConditionalOnMissingBean @ConditionalOnProperty( prefix = &quot;spring.mvc&quot;, name = {&quot;locale&quot;} ) public LocaleResolver localeResolver(){...} //... @Bean @ConditionalOnMissingBean({RequestContextListener.class, RequestContextFilter.class}) @ConditionalOnMissingFilterBean({RequestContextFilter.class}) public static RequestContextFilter requestContextFilter(){...}} Bean注入在上面的内部配置类处理结束后会处理WebMvcAutoConfiguration自动配置类自身的@Bean方法，主要有两个，如下： 123456789101112131415161718192021@Bean@ConditionalOnMissingBean({HiddenHttpMethodFilter.class})@ConditionalOnProperty( prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = false)public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() { return new OrderedHiddenHttpMethodFilter();}@Bean@ConditionalOnMissingBean({FormContentFilter.class})@ConditionalOnProperty( prefix = &quot;spring.mvc.formcontent.filter&quot;, name = {&quot;enabled&quot;}, matchIfMissing = true)public OrderedFormContentFilter formContentFilter() { return new OrderedFormContentFilter();} 自定义配置自定义spring mvc配置方式如下： 在已提供的spring mvc配置基础上进行配置：编写@Configuration配置类并实现WebMvcConfigurer接口，但不要添加 @EnableWebMvc注解。如果想自己提供 RequestMappingHandlerMapping, RequestMappingHandlerAdapter或者ExceptionHandlerExceptionResolver实例的话，可以声明一个WebMvcRegistrations类型的bean，使用它提供那些组件的自定义实例； 完全自定义配置，有两种方式： 编写@Configuration配置类并实现WebMvcConfigurer接口，然后加入@EnableWebMvc注解； 编写@Configuration配置类并实现WebMvcConfigurationSupport接口以代替@EnableWebMvc导入的DelegatingWebMvcConfiguration实现类； 补充： WebMvcConfigurerAdapter抽象类实现了WebMvcConfigurer接口，继承它也可以自定义配置spring mvc但spring5已经将其标记过时，所以这里不再说明； @EnableWebMvc 注解上面提到的@EnableWebMvc注解作用是让spring mvc自动配置失效，@EnableWebMvc注解引入了一个DelegatingWebMvcConfiguration类 123@Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 进入DelegatingWebMvcConfiguration类中 123456789101112131415161718@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //添加自定义的配置 @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } //...} 分析上面的DelegatingWebMvcConfiguration类： 1、这个类的@Configuration注解的proxyBeanMethods属性为false，但这个类中并没有@bean注解，进入其父类WebMvcConfigurationSupport，这里面注册了19个@bean，注册了与&lt;mvc:annotation-driven/&gt;一样的组件 123public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware { //...} WebMvcConfigurationSupport提供用 Java 配置 SpringMVC 所需要的所有方法。在纯SSM注解开发中也是使用这个类来对springmvc进行自定义配置的 2、configurers是一个WebMvcConfigurerComposite类型的对象，保存着spring mvc相关配置的信息，其中delegates属性就保存了自定义的配置信息 1234class WebMvcConfigurerComposite implements WebMvcConfigurer { private final List&lt;WebMvcConfigurer&gt; delegates = new ArrayList(); //...} 如果自定义了@Configuration配置类实现了WebMvcConfigurer接口，那么就会通过DelegatingWebMvcConfiguration类的setConfigurers方法把自定义的配置加入到configurers中 WebMvcConfigurer 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface WebMvcConfigurer { default void configurePathMatch(PathMatchConfigurer configurer) { } default void configureContentNegotiation(ContentNegotiationConfigurer configurer) { } default void configureAsyncSupport(AsyncSupportConfigurer configurer) { } default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { } default void addFormatters(FormatterRegistry registry) { } //自定义拦截器 @Resource private MyInterceptor myInterceptor; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor) //添加拦截器 .excludePathPatterns(&quot;/aaa/**&quot;); //添加忽略路径 } //静态资源处理器，使用配置文件方式也可以 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/aaa/**&quot;) //设置访问路径 .addResourceLocations(&quot;classpath:/aaa/&quot;); //设置资源路径 } default void addCorsMappings(CorsRegistry registry) { } default void addViewControllers(ViewControllerRegistry registry) { } default void configureViewResolvers(ViewResolverRegistry registry) { } default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) { } default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) { } default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { } default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { } default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { } default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { } @Nullable default Validator getValidator() { return null; } @Nullable default MessageCodesResolver getMessageCodesResolver() { return null; }} 自定义拦截器自定义Interceptor需要实现HandlerInterceptor接口或继承其实现类，然后重写其中方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class MyInterceptor implements HandlerInterceptor { /** * 预处理逻辑，可以在这里做校验，比如登陆校验 * @param request 请求 * @param response 响应 * @param handler 处理器，自定义的controller * @return 如果是true则继续下一个拦截器，否则流程中断返回response * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //在这里可以做校验，根据结果判断是否进行映射 System.out.println(&quot;preHandle&quot;); return true; } /** * 后置处理逻辑，渲染视图之前执行，对模型数据进行处理或对视图进行处理 * @param request 请求 * @param response 响应 * @param handler 处理器 * @param modelAndView 模型视图对象，可能为null * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;postHandle&quot;); } /** * 视图渲染完毕后触发，可用于监控程序执行时间和一些资源的清理工作 * @param request 请求 * @param response 响应 * @param handler 处理器 * @param ex 异常 * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;afterCompletion&quot;); }} Spring MVC 相关配置HttpMessageConvertersSpring MVC使用HttpMessageConverter接口来转换 HTTP 请求和响应。例如，对象可以自动转换为 JSON（使用 Jackson 库）或 XML（优先使用Jackson XML 否则使用 JAXB），字符串编码格式为UTF-8。 如果需要添加或者自定义转换器，可以使用HttpMessageConverters类 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class MyHttpMessageConvertersConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter&lt;?&gt; additional = new AdditionalHttpMessageConverter(); HttpMessageConverter&lt;?&gt; another = new AnotherHttpMessageConverter(); return new HttpMessageConverters(additional, another); }}//这样会覆盖默认的HttpMessageConverters//默认的如下@Bean@ConditionalOnMissingBeanpublic HttpMessageConverters messageConverters(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { return new HttpMessageConverters((Collection)converters.orderedStream().collect(Collectors.toList()));} 自定义json序列化和反序列化如果使用Jackson 来序列化和反序列化json数据，可能需要自定义JsonSerializer和JsonDeserializer类，然后注册给Jackson。spring boot提供了@JsonComponent注解，可以更轻松的进行注册，可以将@JsonComponent注解加到自定义的JsonSerializer和JsonDeserializer类上，也可以加到他们的外部类上 12345678910111213141516171819202122232425262728@JsonComponentpublic class MyJsonComponent { public static class Serializer extends JsonSerializer&lt;MyObject&gt; { @Override public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException { jgen.writeStringField(&quot;name&quot;, value.getName()); jgen.writeNumberField(&quot;age&quot;, value.getAge()); } } public static class Deserializer extends JsonDeserializer&lt;MyObject&gt; { @Override public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException, JsonProcessingException { ObjectCodec codec = jsonParser.getCodec(); JsonNode tree = codec.readTree(jsonParser); String name = tree.get(&quot;name&quot;).textValue(); int age = tree.get(&quot;age&quot;).intValue(); return new MyObject(name, age); } }} 因为@JsonComponent的元注释包括@Component所以可以被扫描，同时spring boot也提供了JsonObjectSerializer和JsonObjectDeserializer基础类，上面的例子也可以改成继承这两个。 静态资源默认情况下，spring boot提供了以下静态目录（在classpath或ServletContext上下文的根目录下）优先级一次递减： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ 源码如下： 1234private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;}; 如果想要访问静态资源时放行需要如下配置： 12345678# 静态资源访问路径# 默认为 /**spring.mvc.static-path-pattern=/test/**# 静态资源位置# 默认为 /spring.resources.static-locations=classpath:/templates,classpath:/# 注意：上面的配置其实是访问路径到资源路径的映射，访问路径设置为/test/**代表如果访问路径匹配那么就会映射到下面设置的静态资源的一或多个路径上，可以多层路径访问，如:http://localhost:8080/test/staticsss.png 如果使用@EnableWebMvc注解会导致以上两个配置失效，这时就需要使用[配置类](#（2）WebMvcConfigurer 配置)的方式进行配置，上面配置等效于： 12345678@Configurationpublic class MyWebMvcConfigurer implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/test/**&quot;) //设置访问路径 .addResourceLocations(&quot;classpath:/templates&quot;,&quot;classpath:/&quot;); //设置资源路径 }} 静态资源版本管理当我们的资源内容发生改变时，由于浏览器缓存，用户本地的资源还是旧资源，可以通过添加随机数、时间戳等方式解决，但这样每次都要访问服务器，增大了服务器资源压力为了防止这种情况发生导致的问题spring boot 默认提供了静态资源版本映射的支持 content 策略（MD5）： 1234# 配置是否开启缓存破坏spring.resources.chain.strategy.content.enabled=true# 配置生效的目录spring.resources.chain.strategy.content.paths=/static/** 如果使用了Thymeleaf 和 FreeMarker模板引擎，可以直接在页面中添加 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;${@mvcResourceUrlProvider.getForLookupPath('/static/css/test.css')}&quot;&gt; 上面的配置在页面中会解析成如下内容 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/css/test-16372d2e887158a751e8ccb481723b20.css&quot;&gt; 可以看到在文件名下面添加了哈希值，并且刷新不会改变，只有文件被更改或重启服务时该哈希值才会变化。 如果使用的模板引擎无法直接访问Spring bean，则可以将ResourceUrlProvider 添加到Spring中 1234567891011@ControllerAdvicepublic class ControllerConfig { @Autowired ResourceUrlProvider resourceUrlProvider; @ModelAttribute(&quot;urls&quot;) public ResourceUrlProvider urls() { return this.resourceUrlProvider; }} fix策略（版本号） 配置内容如下： 123spring.resources.chain.strategy.fixed.enabled=truespring.resources.chain.strategy.fixed.paths=/static/css/**spring.resources.chain.strategy.fixed.version=version-1 例子与content一致，最终页面上解析的结果为： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/version-1/static/css/test.css&quot;&gt; 可以看到，文件名字没有改变，但在路径前面添加了version-1作为标识，静态文件每次进行更改后需要修改版本号。 两种策略可以一起使用 12345spring.web.resources.chain.strategy.content.enabled=truespring.web.resources.chain.strategy.content.paths=/**spring.web.resources.chain.strategy.fixed.enabled=truespring.web.resources.chain.strategy.fixed.paths=/js/lib/spring.web.resources.chain.strategy.fixed.version=v12 如果这样配置，位于 /js/lib/ 下的 js 模块会使用 fix 版本策略，其他路径使用content版本策略 欢迎页面Spring Boot 支持静态和模板化欢迎页面，页面查找顺序如下： 配置文件中的静态目录下的index.html index模板 程序的欢迎页面 自定义类型转换Spring MVC使用一个 WebBindingInitializer来初始化WebDataBinder，用来处理特定的请求。如果需要自定义，可以使用以下方式 自定义 ConfigurableWebBindingInitializer创建一个自定义的的bean，spring mvc会直接使用它 todo（示例代码待补充） 使用 @initBinder 注解todo（示例代码待补充） 模板引擎spring boot 默认支持以下模板引擎： FreeMarker Groovy Thymeleaf Mustache 应该尽可能的避免使用 jsp，如果使用了spring boot默认配置的模板引擎，那么模板位置默认在src/main/ resources/templates 路径下。 错误处理spring boot 默认提供了一个/error映射作为全局戳五处理页面，也可以通过server.error的配置项来自定义错误处理行为 名称 描述 默认值 server.error.path 错误页面 /error server.error.whitelabel.enabled 服务器出错时默认显示错误页面 true server.error.include-binding-errors never server.error.include-exception false server.error.include-message never server.error.include-stacktrace never 自定义错误页面如果想要为给定的状态码自定义错误页面，可以在将页面 /error 目录下。这个页面可以是静态的，也可以是模板 123456789101112131415# 如果是静态src/ +- main/ +- resources/ +- public/ +- error/ | +- 404.html# 如果是 FreeMarker 模板src/ +- main/ +- resources/ +- templates/ +- error/ | +- 5xx.ftlh 对于更复杂的映射可以定义实现ErrorViewResolver接口的bean 12345678910111213public class MyErrorViewResolver implements ErrorViewResolver { @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { // 根据请求或者状态返回ModelAndView if (status == HttpStatus.INSUFFICIENT_STORAGE) { // 可以添加自定义视图 new ModelAndView(&quot;myview&quot;); } return null; }} ErrorController如果要完全替换错误默认行为，可以定义一个ErrorController的实现类的bean，可以通过继承BasicErrorController类实现 1234567891011121314151617181920212223242526272829public class MyErrorController extends BasicErrorController { public MyErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties) { super(errorAttributes, errorProperties); } /** * 覆盖默认的Json响应 * ResponseEntity 是spring mvc定义的返回实体， * 里面包括状态码、、请求头、请求体等信息 */ @Override public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { //处理异常 //指定返回的数据 return ; } /** * 覆盖默认的HTML响应 * 返回的是ModelAndView */ @Override public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { //处理异常 //指定自定义的视图 return ; }} @ControllerAdvice + @ExceptionHandler@ControllerAdvice + @ExceptionHandler是spring mvc常规异常处理方式，使用@ControllerAdvice注解自定义针对json数据的异常处理 12345678910111213141516171819202122//这里可以不继承ResponseEntityExceptionHandler@ControllerAdvicepublic class MyControllerAdvice extends ResponseEntityExceptionHandler { @ExceptionHandler({Exception.class}) public CommonReponse fix(Exception ex){ //处理异常 return new CommonReponse(); } //需要时可以重写该类的方法 @Override protected ResponseEntity&lt;Object&gt; handleHttpRequestMethodNotSupported( HttpRequestMethodNotSupportedException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { //处理异常，设置属性 return super.handleHttpRequestMethodNotSupported(ex, headers, status, request); }} ResponseEntityExceptionHandler类中包装了各种SpringMVC在处理请求时可能抛出的异常的处理，处理结果都是封装成一个ResponseEntity对象，进入该方法 12345678910111213141516171819202122232425public abstract class ResponseEntityExceptionHandler { /** 以下声明异常是springmvc处理请求的所有可能抛出的异常，如果出现异常就会进入该方法 * 这个方法内部就是一堆if语句，根据异常的的类型转发到其他的异常处理方法 */ @ExceptionHandler({HttpRequestMethodNotSupportedException.class, HttpMediaTypeNotSupportedException.class, HttpMediaTypeNotAcceptableException.class, MissingPathVariableException.class, MissingServletRequestParameterException.class, ServletRequestBindingException.class, ConversionNotSupportedException.class, TypeMismatchException.class, HttpMessageNotReadableException.class, HttpMessageNotWritableException.class, MethodArgumentNotValidException.class, MissingServletRequestPartException.class, BindException.class, NoHandlerFoundException.class, AsyncRequestTimeoutException.class}) @Nullable public final ResponseEntity&lt;Object&gt; handleException(){} //其他异常处理方法} 另外，也可以将@ExceptionHandler注解加到可能出现异常的控制器上，这样就不会进入全局异常处理 123456789101112131415161718@Controller@RequestMapping(&quot;/test&quot;)public class TestController { //可能抛出异常的方法 @RequestMapping(&quot;/test&quot;) @ResponseBody public String testError(){ int i = 1 / 0; return &quot;&quot;; } @ExceptionHandler({RuntimeException.class}) public ModelAndView handleException(Exception ex){ //处理异常 return new ModelAndView(&quot;error&quot;,new ModelMap(&quot;ex&quot;,ex.getMessage())); }} Spring MVC 之外的错误页面对于不使用 Spring MVC 的应用，可以使用ErrorPageRegistrar接口直接注册ErrorPages. 这种抽象直接与底层嵌入式 servlet 容器一起工作，即使您没有 Spring MVC 也能工作DispatcherServlet。 12345678910111213@Configuration(proxyBeanMethods = false)public class MyErrorPagesConfiguration { @Bean public ErrorPageRegistrar errorPageRegistrar() { return this::registerErrorPages; } private void registerErrorPages(ErrorPageRegistry registry) { registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, &quot;/400&quot;)); }} CORS 支持从 version 4.2 开始，Spring MVC开始支持 CORS 。在 Spring Boot 应用程序中可以通过自定义bean实现跨域 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class MyCorsConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override public void addCorsMappings(CorsRegistry registry) { //放行的路径 registry.addMapping(&quot;/api/**&quot;); } }; }} 也可以直接在 controller 上直接添加 @CrossOrigin 注解。","link":"/2022/01/05/language/Java/Spring%20Boot/SpringBootWeb%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%EF%BC%9ASpringMVC/"},{"title":"Spring Boot 数据库集成：Redis 数据库","text":"Redis 通常用于数据量比较小、性能较高的场景，一般用作缓存。spring boot提供了spring-boot-starter-data-redis启动器，为Lettuce和Jedis客户端以及Spring Data Redis提供的抽象做了基本的自动配置吗默认情况下使用Lettuce。可以用于传统的和响应式的应用程序。 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 相关配置在配置文件中添加redis相关配置 123456789101112131415161718# Redis数据库索引（默认0）spring.redis.database=0# redis服务器地址（默认localhost）spring.redis.host=127.0.0.1#Redis服务器连接端口（默认6379）spring.redis.port=6379 #Redis服务器连接密码（默认为空）spring.redis.password=#连接池最大连接数（使用负值表示没有限制，默认8）spring.redis.[客户端].pool.max-active=8#连接池最大阻塞等待时间（使用负值表示没有限制，默认-1ms）spring.redis.[客户端].pool.max-wait=-1#连接池中的最大空闲连接（默认8）spring.redis.[客户端].pool.max-idle=8#连接池中的最小空闲连接（默认0）spring.redis.[客户端].pool.min-idle=0#连接超时时间（毫秒）spring.redis.timeout=30000 自动配置我们来看redis自动配置类 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass({RedisOperations.class})@EnableConfigurationProperties({RedisProperties.class})@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {&quot;redisTemplate&quot;} ) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; }} 可以看到该类中创建了RedisTemplate和StringRedisTemplate实例，同时通过@import注解引入了两个类（LettuceConnectionConfiguration和JedisConnectionConfiguration），下面只列出这两个类中的@bean方法 12345678910111213141516171819202122232425262728//LettuceConnectionConfigurationclass LettuceConnectionConfiguration extends RedisConnectionConfiguration { @Bean( destroyMethod = &quot;shutdown&quot; ) @ConditionalOnMissingBean({ClientResources.class}) DefaultClientResources lettuceClientResources() { return DefaultClientResources.create(); } @Bean @ConditionalOnMissingBean({RedisConnectionFactory.class}) LettuceConnectionFactory redisConnectionFactory(...); //... return this.createLettuceConnectionFactory(clientConfig); } //...}//JedisConnectionConfigurationclass JedisConnectionConfiguration extends RedisConnectionConfiguration { @Bean @ConditionalOnMissingBean({RedisConnectionFactory.class}) JedisConnectionFactory redisConnectionFactory(...) throws UnknownHostException { return this.createJedisConnectionFactory(builderCustomizers); }} LettuceConnectionConfiguration和JedisConnectionConfiguration中都存在创建他们所对应的 RedisConnectionFactory 实例的方法，并且根据其上声明的条件注解可知最终 ioc 容器中只存在一个。除此之外，LettuceConnectionConfiguration还多创建了一个名为DefaultClientResources的实例。 使用方法根据上述介绍可以得出：在自动配置过程中创建的bean实例主要有以下三个： RedisTemplate StringRedisTemplate RedisConnectionFactory 可以在项目中直接引入 123456@Autowiredprivate RedisTemplate redisTemplate;@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Autowiredprivate RedisConnectionFactory redisConnectionFactory; todo","link":"/2021/12/16/language/Java/Spring%20Boot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90%EF%BC%9ARedis/"},{"title":"Spring Boot 数据库集成：SQL 数据库","text":"Spring 框架提供了利用JdbcTemplate 直接访问JDBC从而操作数据库的技术。另外可以利用Hibernate或Spring Data提供的Repository生成查询 嵌入式数据库Spring Boot 提供了嵌入式的H2、HSQL和Dery数据库。无需提供连接URL，只需要包含对应的嵌入式数据库的依赖项。例如： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 如果类路径上有多个嵌入式数据库，可以配置spring.datasource.embedded-database-connection属性设置使用哪一个。将其设置为none禁用嵌入式数据库的自动配置。 1spring.datasource.embedded-database-connection=none 在测试环境下，多个应用程序商家问会重用一个数据库，如果要确保每个上下文都有单独的嵌入式数据库，需要配置 1spring.datasource.generate-unique-name=true 如果为嵌入式数据库配置了URL，应确保禁用数据库的自动关闭，这样可以让spring boot控制何时关闭数据库，从而确保只使用一次数据库之后就不再须要的情况。 配置数据源Java 的javax.sql.DataSource提供了处理数据库连接的标准方法。数据库会通过URL和一些认证信息来建立数据库连接。通过spring.datasource.*进行配置 123spring.datasource.url=jdbc:mysql://localhost/testspring.datasource.username=dbuserspring.datasource.password=dbpass 其中至少应该指定URL，否则spring boot会尝试自动配置嵌入式数据库。Spring Boot 可以通过 URL 中推断出大多数的数据库JDBC驱动类，如果想要指定特定的类，可以使用 1spring.datasource.driver-class-name=xxx 为了创建DataSource，我们需要验证配置的Driver是可用的，所以在做任何事之前都会检查它，换句话说，上面配置的驱动类必须是课加载的。 对于其他的连接池可以通过它们对应的前缀配置 spring.datasource.hikari.*； spring.datasource.tomcat.*； spring.datasource.dbcp2.*； spring.datasource.oracleucp.* 例如： 123spring.datasource.tomcat.max-wait=10000spring.datasource.tomcat.max-active=50spring.datasource.tomcat.test-on-borrow=true 自定义数据源如果需要配置自己的数据源，直接定义对应类型的的@bean即可 123456789@Configuration(proxyBeanMethods = false)public class MyDataSourceConfiguration { @Bean //使用ConfigurationProperties自动绑定配置信息 @ConfigurationProperties(prefix = &quot;app.datasource&quot;) public SomeDataSource dataSource() { return new SomeDataSource(); }} 配置自定义数据源属性，这些属性会在SomeDataSource被装配到其他组件前注入 1234app.datasource.jdbc-url=jdbc:mysql://localhost/testapp.datasource.username=dbuserapp.datasource.password=dbpassapp.datasource.pool-size=30 spring boot也提供了一个公共的builder类（DataSourceBuilder），用于创建指定类型的标准数据源，这个builder能够根据classpath上的内容检测哪个是可用的，也会自动检测JDEB URL 1234567891011121314@Configuration(proxyBeanMethods = false)public class MyDataSourceConfiguration { @Bean @ConfigurationProperties(&quot;app.datasource&quot;) //这时可以指定具体类型的数据源 public HikariDataSource dataSource() { return DataSourceBuilder .create() .type(HikariDataSource.class) .build(); } } 可以提供自定义的DataSourceProperties，对自定义属性做进一步处理 1234567891011121314151617@Configuration(proxyBeanMethods = false)public class MyDataSourceConfiguration { @Bean @Primary @ConfigurationProperties(&quot;app.datasource&quot;) public DataSourceProperties dataSourceProperties() { return new DataSourceProperties(); } @Bean @ConfigurationProperties(&quot;app.datasource.configuration&quot;) public HikariDataSource dataSource(DataSourceProperties properties) { return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); }} 对应配置如下 1234app.datasource.url=jdbc:mysql://localhost/testapp.datasource.username=dbuserapp.datasource.password=dbpassapp.datasource.configuration.maximum-pool-size=30 配置多数据源配置多数据源可以参照配置单数据源的方式，只不过需要指定一个DataSource作为@Primary，在之后的自动配置过程中获取到的都是这个DataSource，如果有其对应的 @ConfigurationProperties 也与要加@Primary 1234567891011121314151617181920212223242526@Configuration(proxyBeanMethods = false)public class MyCompleteDataSourcesConfiguration { //配置方式1 @Bean @Primary @ConfigurationProperties(&quot;app.datasource.first&quot;) public DataSourceProperties firstDataSourceProperties() { return new DataSourceProperties(); } @Bean @Primary @ConfigurationProperties(&quot;app.datasource.first.configuration&quot;) public HikariDataSource firstDataSource(DataSourceProperties firstDataSourceProperties) { return firstDataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); } //配置方式2 @Bean @ConfigurationProperties(&quot;app.datasource.second&quot;) public BasicDataSource secondDataSource() { return DataSourceBuilder.create().type(BasicDataSource.class).build(); }} 两个数据源对应自定义配置如下： 123456789app.datasource.first.url=jdbc:mysql://localhost/firstapp.datasource.first.username=dbuserapp.datasource.first.password=dbpassapp.datasource.first.configuration.maximum-pool-size=30app.datasource.second.url=jdbc:mysql://localhost/secondapp.datasource.second.username=dbuserapp.datasource.second.password=dbpassapp.datasource.second.max-total=30 连接池spring boot选择连接池的规则： 如果HikariCP 可用，则选择； 否则，如果 Tomcat 池DataSource可用，则使用； 否则，如果Commons DBCP2可用，则使用； 如果上面都不可用，并且Oracle UCP可用，则使用； 如果加入了spring-boot-starter-jdbc或spring-boot-starter-data-jpa的依赖会自动选择HikariCP。如果不希望使用上述规则可以如下设置： 1spring.datasource.type=要使用的连接池 使用DataSourceBuilder可以通过手动配置额外的连接池.如果自定义 DataSource ，那么自动配置不会剩下。DataSourceBuilder支持以下连接池 HikariCP Tomcat pooling Datasource Commons DBCP2 Oracle UCP &amp; OracleDataSource Spring Framework’s SimpleDriverDataSource H2 JdbcDataSource PostgreSQL PGSimpleDataSource 其他的连接池，比如C3P0可以直接引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.3&lt;/version&gt;&lt;/dependency&gt; 然后再自定义DataSource 1234567891011121314151617@Configuration@ConditionalOnClass(DataSource.class)public class C3p0AutoConfiguration { @Bean @ConditionalOnMissingBean public DataSource dataSource() throws Exception{ // 创建一个 c3p0 的连接池 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; }} JdbcTemplateJdbcTemplate和NamedParameterJdbcTemplate类都是自动配置的，可以直接在项目中注入，可以使用spring.jdbc.template.*属性自定义其参数 12spring.jdbc.template.max-rows=500更多属性 todo 如果JdbcTemplate定义了多个，并且没有指定@primary 那么NamedParameterJdbcTemplate不会自动配置 todo 使用方法","link":"/2021/12/05/language/Java/Spring%20Boot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90%EF%BC%9ASQL/"},{"title":"Spring Boot 核心功能：启动执行代码","text":"添加 Spring Boot 程序启动后执行的逻辑 程序启动后执行特定代码如果需要在程序启动后执行特定代码，可以实现 ApplicationRunner 或 CommandLineRunner接口，这两个接口提供了run()方法会在SpringApplication.run(…)调用完成之前执行 1234567@Componentpublic class MyCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;我执行啦&quot;); }}","link":"/2021/06/13/language/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81/"},{"title":"Spring Boot 核心功能：自定义banner","text":"自定义 banner 配置文件设置可以通过将banner.txt文件添加到类路径或将spring.banner.location属性设置为此类文件的位置来更改启动时打印的banner。如果文件的编码不是 UTF-8，需要设置spring.banner.charset。 除了一个文本文件，还可以添加一个banner.gif，banner.jpg或banner.png图像文件到类路径或设置spring.banner.image.location属性。图像被转换为 ASCII 艺术表现形式并打印在任何文本横幅上方。 在您的banner.txt文件中，您可以使用以下任何占位符： 变量 描述 ${application.version} 应用程序的版本号 ${application.formatted-version} 应用程序的版本号，格式化输出 ${spring-boot.version} Spring Boot 版本 ${spring-boot.formatted-version} Spring Boot 版本，格式化输出 ${Ansi.NAME}(或${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME}) NAMEANSI 转义码 ${application.title} 应用程序的标题 代码设置使用SpringApplication.setBanner(…)方法可以设置banner 也可以自定义类继承org.springframework.boot.Banner接口并实现您自己的printBanner()方法。","link":"/2021/06/10/language/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89banner/"},{"title":"Spring Boot 核心功能：获取应用程序参数","text":"获取应用启动时传递的参数 获取应用程序参数使用可以通过注入一个org.springframework.boot.ApplicationArguments类型的bean获取应用程序传递的参数 123456789101112@Componentpublic class MyBean { public MyBean(ApplicationArguments args) { boolean debug = args.containsOption(&quot;debug&quot;); List&lt;String&gt; files = args.getNonOptionArgs(); if (debug) { System.out.println(files); } }}","link":"/2021/06/12/language/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0/"},{"title":"Spring Boot 核心功能：懒加载","text":"设置 bean 的懒加载 懒加载spring boot允许懒加载。启用懒加载后，bean 将在需要时创建，而不是在应用程序启动期间创建，但这可能会产生很多问题。开启的配置如下: properties： 1spring.main.lazy-initialization=true yaml： 123spring: main: lazy-initialization: true","link":"/2021/06/11/language/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"title":"Spring Boot 核心功能：配置相关","text":"本篇介绍 Spring Boot 中对配置的相关问题，包括配置导入、配置分隔等 自动配置spring boot会根据引入的自动配置器来引入配置，只需要在启动类上标记@EnableAutoConfiguration 或者 @SpringBootApplication注解，原理参照源码解析 自动配置替换spring boot的自动配置是可以替换。启动spring boot时会将相关的bean封装为beanDefination保存到benfactory（ioc容器）中，自定义的配置会率先加载到ioc容器中，之后在加载自动配置类的时，一般都会在创建bean的方法上标记@ConditionalOnMissingBean注解，意为当前bean不存在时才加载，这就是自定义配置替换原有配置的原理 禁用自动配置可以使用@EnableAutoConfiguration注解的的 exclude 属性和excludeName属性禁用不想要的特定自动配置类。由于@SpringBootApplication和@SpringCloudApplication都是组合了@EnableAutoConfiguration注解，所以也可以直接将排除配置卸载@SpringBootApplication和@SpringCloudApplication注解上 exclude 属性需要指定排除项类的数组 1234@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })public class MyApplication {} excludeName 属性需要指定排除项的全类名 1234@SpringBootApplication(excludeName = {&quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;})public class MyApplication {} 配置文件中排除properties： 123spring.autoconfigure.exclude=\\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration yaml： 12345spring: autoconfigure: exclude: - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration - org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration 外部配置spring boot可以使用各种外部配置源： Java文件 properties文件 YAML文件 环境变量 命令行参数 配置源读取顺序（后面的会覆盖更早的,null值不会覆盖）： 默认属性（由设置指定SpringApplication.setDefaultProperties）； @Configuration注释的类； 配置数据（如application.properties文件）； RandomValuePropertySource，只有在拥有性能random.*； 操作系统环境变量； Java 系统属性 ( System.getProperties())； 来自java:comp/env的NDI 属性； ServletContext 初始化参数； ServletConfig 初始化参数 来自SPRING_APPLICATION_JSON（嵌入在环境变量或系统属性中的内联 JSON）的属性。 命令行参数； 测试中的@SpringBootTest； 测试中的@TestPropertySource； 当 devtools 处于活动状态时的 $HOME/.config/spring-boot ； 配置文件优先级： 打包在 jar 中的应用程序属性（application.properties和 YAML 变体）； 打包在 jar 中的特定于配置文件的应用程序属性（application-{profile}.properties和 YAML 变体）； 打包的 jar 之外的应用程序属性（application.properties和 YAML 变体）； 打包的 jar之外的特定于配置文件的应用程序属性（application-{profile}.properties和 YAML 变体）； 加载application.properties和application.yaml的默认位置： classpath classpath目录 classpath目录下的 /config 子目录 project（如果有多个子模块，这里指的是父他们父工程的根目录） project根目录 project根目录的 /config 子目录 /config 子目录的直接子目录 补充： 该列表按优先级排序，后加载的覆盖先加载的。 同一位置同时具有.properties和.yml格式，.properties则优先； 命令行属性命令行属性始终优先于基于文件的属性源； 禁用命令行参数使命令行属性不会添加到Environment中 1SpringApplication.setAddCommandLineProperties(false) json应用程序属性环境变量和系统属性通常有限制，不能随意使用。为解决这个问题，spring boot允许使用以单个json的结构定义一组属性； 在程序启动时，任何spring.application.json或SPRING_APPLICATION_JSON属性将被解析并添加到Environment，例如： 1234# 命令行参数中配置$ SPRING_APPLICATION_JSON='{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}' java -jar myapp.jar$ java -Dspring.application.json='{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}' -jar myapp.jar$ java -jar myapp.jar --spring.application.json='{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}' 自定义配置文件spring.config.name, spring.config.location, 和spring.config.additional-location等用来指定配置文件，它们必须定义为环境属性（通常是操作系统环境变量、系统属性或命令行参数） spring.config.name配置spring.config.name环境属性定替换默认文件名 1$ java -jar myproject.jar --spring.config.name=myproject spring.config.location配置spring.config.location环境属性替换默认位置 12345678# 多个位置用逗号分隔# 如果希望位置时可选的，可以使用optional前缀$ java -jar myproject.jar --spring.config.location=\\ optional:classpath:/custom-config/,\\ optional:file:./custom-config/# 上面的配置扫描路径如下optional:classpath:custom-config/optional:file:./custom-config/ 补充： 如果spring.config.location指定的是目录（而不是文件），则会以spring.config.name的指定的值作为文件名。如果指定的是文件名则直接导入； 配置多个位置会按照定义的顺序进行处理，后面的位置可以覆盖前面位置的值。 spring.config.additional-location配置spring.config.additional-location环境属性，添加默认位置 12345678910$ spring.config.additional-location=\\ optional:classpath:/custom-config/, optional:file:./custom-config/# 上面的配置扫描路径如下# 默认的配置文件位置optional:classpath:/;optional:classpath:/config/optional:file:./;optional:file:./config/;optional:file:./config/*/# 添加的配置文件位置optional:classpath:custom-config/optional:file:./custom-config/ 可以在默认位置设置默认值，然后在自定义位置设置新的值来覆盖默认值； 补充： 对于指定的配置文件也同样起效，例如spring.config.location设置为classpath:myconfig.properties，也能找到相应的classpath:myconfig-&lt;profile&gt;.properties文件被加载； spring.config.location您添加的每个项目都将引用单个文件或目录。位置按照定义的顺序进行处理，后面的位置可以覆盖前面位置的值。 可选位置： 默认情况下，指定的配置如果不存在会报错。如果不希望报错，可以通过optional:前缀指定可选配置，如果想要来忽略所有的ConfigDataLocationNotFoundExceptions，如果想忽略所有的ConfigDataLocationNotFoundExceptions并始终继续启动您的应用程序，可以设置spring.config.on-not-found属性； 通配符位置： 如果文件位置的配置路径最后一个路径段的包含*，则将其视为通配符（匹配一个或多个字符）。例如，我们将redis和mysql配置分开存放，又想让他们都被读取，可以设置位置分别为*/config/redis/application.properties和/config/mysql/application.properties*。 补充： 通配符位置仅适用于外部目录。不能在classpath:位置中使用通配符。 通配符位置必须仅包含一个*并以*/目录结尾或*/&lt;filename&gt;文件搜索位置结尾。带有通配符的位置根据文件名的绝对路径按字母顺序排序。 spring.profiles.active默认spring boot会加载application配置文件，通过配置spring.profiles.active属性来指定特定配置文件： 1spring.profiles.active=prod,live 补充： application.properties文件仍会被加载，可以作为默认配置； 被指定的特定文件中的值会覆盖非特定文件； 如果配置了多个特定文件那么后面的会覆盖前面的，例如配置prod,live，那么application-prod.properties中的值会被application-live.properties中的值覆盖； Environment具有一组默认的配置文件（默认[default]），如果没有指定spring.profiles.active属性，则加载application-default的文件； 配置分组（;分隔符）： 使用分隔符（;）会对自定义的配置文件进行分组，例如： 123456789101112131415161718192021222324252627# 当前文件目录/cfg application-live.properties /ext application-live.properties application-prod.properties # 配置spring.profiles.active=prod,live# 以,逗号分隔spring.config.location=classpath:/cfg/,classpath:/ext/# 会加载的文件顺序# 可以看到此时不会按照spring.profiles.active中的配置顺序加载/cfg/application-live.properties/ext/application-prod.properties/ext/application-live.properties# 用;分隔符替换,逗号spring.config.location=classpath:/cfg/;classpath:/ext/# 会加载的文件顺序# 此时ext和cfg目录被分为不同组，处理时在同意水平# 满足spring.profiles.active中的配置顺序加载/ext/application-prod.properties/cfg/application-live.properties/ext/application-live.properties spring.config.import使用spring.config.import属性可以从其他位置导入更多配置数据，会在读取到该配置时引入，视为附加文件 1spring.config.import=optional:file:./dev.properties 这条配置会将触发dev.properties文件导入，导入文件的值优先级更高，配置定义的顺序无关紧要 12345spring.config.import=my.propertiesmy.property=value# 等同于my.property=valuespring.config.import=my.properties 上面两个示例中my.properties文件中的值优先于触发其导入的文件 补充： 一个导入无论声明多少次都只会被导入一次； spring.config.import键下指定多个位置，导入顺序和定义顺序一致，后面导入文件的值优先； 导入无扩展名文件： 某些云平台无法为卷挂载文件添加文件扩展名，如果需要这些无扩展名的文件，需要将扩展提示放在方括号中 1spring.config.import=file:/etc/config/myconfig[.yaml] 导入配置树： 使用optional:前缀导入配置树 配置树： 12345etc/ config/ myapp/ username password 导入： 1spring.config.import=optional:configtree:/etc/config/ 导入之后可以以通常的方式访问或注入myapp.username和myapp.password属性。入股有多个配置树要从同一个父文件夹导入 12345678910etc/ config/ dbconfig/ db/ username password mqconfig/ mq/ username password 可以将configtree:/etc/config/*/用作导入位置 1spring.config.import=optional:configtree:/etc/config/*/ 属性占位符application.properties和application.yml中的值在Environment使用时会通过现有值进行过滤，因此可以参考以前定义的值。使用${name}属性占位符语法可用于值内的任何地方。 12app.name=MyAppapp.description=${app.name} is a Spring Boot application 配置随机值： RandomValuePropertySource可以用来注入随机值，它可以生成整数、长整数、uuid 或字符串，如以下示例所示： 123456my.secret=${random.value}my.number=${random.int}my.bignumber=${random.long}my.uuid=${random.uuid}my.number-less-than-ten=${random.int(10)}my.number-in-range=${random.int[1024,65536]} 多文档文件Spring Boot 允许您将单个物理文件拆分为多个独立添加的逻辑文档。文档按顺序处理，从上到下。后面的文档可以覆盖在前面的文档中定义的属性。 12345678910spring: application: name: &quot;MyApp&quot;---spring: application: name: &quot;MyCloudApp&quot; config: activate: on-cloud-platform: &quot;kubernetes&quot; 对于application.properties文件，使用特殊#---注释来标记文档拆分： 1234spring.application.name=MyApp#---spring.application.name=MyCloudAppspring.config.activate.on-cloud-platform=kubernetes 补充： 属性文件分隔符不能有任何前导空格，并且必须正好有三个连字符。分隔符前后的行不能是注释。 不能使用@PropertySource或@TestPropertySource注释加载多文档属性文件。 激活属性： 有时仅在满足某些条件时激活一组给定的属性很有用。可以通过spring.config.activate.*有条件的激活配置 配置 说明 on-profile 必须匹配才能使文档处于活动状态的配置文件表达式。 on-cloud-platform 在CloudPlatform必须对文件进行检测活跃。 下面例子表示仅在 Kubernetes 上运行并且prod或staging配置文件处于活动状态时才生效 12345myprop=always-set#---spring.config.activate.on-cloud-platform=kubernetesspring.config.activate.on-profile=prod | stagingmyotherprop=sometimes-set 配置导入加载spring配置文件 @ImportResource注解用于导入spring的xml文件 引入额外配置类 @ImportResource 注解用于可用于导入额外的配置类。 @ComponentScan自动选取所有 Spring 组件，包括@Configuration类。 外部配置导入获取外部配置的方式： 通过@Value注解 访问Environment 通过@ConfigurationProperties注解绑定到结构化对象 @Valuetodo Environment在springboot项目启动阶段会执行如下代码，用于创建environment对象，之后会将配置都加入到该对象中，包括环境变量、java环境变量、命令行参数，自定义配置文件等 1ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); todo @ConfigurationProperties使用@ConfigurationProperties可以获取指定前缀的结构化配置，比如下面配置文件的风格： 12345678my: service: remote-address: 192.168.1.1 security: username: &quot;admin&quot; roles: - &quot;USER&quot; - &quot;ADMIN&quot; 在属性绑定时属性名和配置名 不一定要完全匹配，spring boot会进行宽松绑定： 驼峰命名法（aaaBbb） 大写格式（AAABBB） 下划线表示法（aaa_bbb） 烤肉盒（aaa-bbb） 属性绑定1234567891011121314151617181920212223@ConfigurationProperties(&quot;my.service&quot;)public class MyProperties { private boolean enabled; private InetAddress remoteAddress; private final Security security = new Security(); // getters / setters... public static class Security { private String username; private String password; private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;)); // getters / setters... }} @ConfigurationProperties标记的类中的属性会注入Spring Boot中可用类的属性。上面javaBean定义了以下属性 my.service.enabled，默认值为false； my.service.remote-address, 一个被可以被解析的String； my.service.security.username，带有一个嵌套的“安全”对象，其名称由属性的名称决定； my.service.security.password； my.service.security.roles,默认为USER的集合String； 可以在其他bean使用，与@ConfigurationProperties标记的类属性注入方式类似 123456789101112131415161718@Servicepublic class MyService { private final SomeProperties properties; public MyService(SomeProperties properties) { this.properties = properties; } public void openConnection() { Server server = new Server(this.properties.getRemoteAddress()); server.start(); // ... } // ...} 补充： 通过属性文件、YAML 文件、环境变量和其他机制配置； getter无论何时都是必须的，setter不一定，因为可以通过绑定器也可以赋值； 初始化嵌套的pojo不setter不是必要的； 不支持静态属性绑定 构造函数绑定12345678910111213141516171819202122232425262728293031@ConstructorBinding@ConfigurationProperties(&quot;my.service&quot;)public class MyProperties { // fields... public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) { this.enabled = enabled; this.remoteAddress = remoteAddress; // 如果没有匹配到，security为null // 如果希望非空可以在参数列表使用@DefaultValue注释 this.security = security; } // getters... public static class Security { // fields... public Security(String username, String password, @DefaultValue(&quot;USER&quot;) List&lt;String&gt; roles) { this.username = username; this.password = password; this.roles = roles; } // getters... } } 补充： @ConstructorBinding注释用于指示应使用构造函数绑定，绑定器会尝试找到对应的构造函数； 如果有多个构造函数，可以将@ConstructorBinding放在应该绑定的构造函数上； 类的嵌套成员也将通过它们的构造函数绑定； 可以通过@DefaultValue注解指定默认值； 不能对由常规 Spring 机制创建的 bean 使用构造函数绑定（@Component、@Bean、@Import） 启用@ConfigurationProperties注释@ConfigurationProperties注解需要配合@EnableConfigurationProperties或组件扫描器使用。但有些情况下，必须使用@EnableConfigurationProperties注释，比如想要有条件的启用。 123456@Configuration(proxyBeanMethods = false)//指定对应的class@EnableConfigurationProperties(SomeProperties.class)public class MyConfiguration {} 如果想要使用配置属性扫描，请将@ConfigurationPropertiesScan注释添加到应用程序中，一般是声明在启动类或@Configuration类。 123456@SpringBootApplication//指定扫描路径@ConfigurationPropertiesScan({ &quot;com.example.app&quot;, &quot;com.example.another&quot; })public class MyApplication {} @ConfigurationProperties配置类的名称格式为：&lt;prefix&gt;-&lt;fqn &lt;prefix&gt;是@ConfigurationProperties注解中指定的环境前缀 &lt;fqn&gt;是 bean 的完全限定名称 如果注释不提供任何前缀，则仅使用 bean 的完全限定名称。 上面示例中的 bean 名称是com.example.app-com.example.app.SomeProperties。 建议@ConfigurationProperties只处理环境，不要冲上下文中注入其他bean。如果必须要用，可以使用 setter 注入或*Aware框架提供的接口。如果必须要用构造函数注入其他bean，则必须使用由@Component注释的JavaBean的属性绑定bean。 第三方配置对于一些第三方组件可以通过以下形式从Environment中向bean注入属性 12345678910@Configuration(proxyBeanMethods = false)public class ThirdPartyConfiguration { @Bean @ConfigurationProperties(prefix = &quot;another&quot;) public AnotherComponent anotherComponent() { return new AnotherComponent(); }} @ConfigurationProperties 与 @Value区别 特征 @ConfigurationProperties @Value 宽松绑定 是 有限 元数据支持 是 否 SpEL表达式 否 是 @Value仅使用小写字母来引用属性名称时支持宽松绑定 Profilesspring profiles提供了一种分离应用程序配置部分，并使其在默写环境下生效，可以为@Component，@Configuration或者@ConfigurationProperties标记加载限制 1234567@Configuration(proxyBeanMethods = false)@Profile(&quot;production&quot;)public class ProductionConfiguration { // ...} 补充： 如果@ConfigurationProperties是通过@EnableConfigurationProperties引入，那么@Profile需要加在具有@EnableConfigurationProperties注解的@Configuration类上； 如果ConfigurationProperties是通过自动扫描的，@Profile可以在@ConfigurationProperties类本身上指定； 指定环境可以使用spring.profiles.active 指定Environment来限制哪些配置文件处于活动状态。 在配置文件中指定： 1spring.profiles.active=dev,hsqldb 在命令行上指定： 1--spring.profiles.active=dev,hsqldb 如果没有配置文件处于活动状态，则启用默认配置文件：default，可以使用spring.profiles.default 对Environment属性进行调整 1spring.profiles.default=none 可以通过SpringApplication.setAdditionalProfiles(…)在应用程序运行之前调用来以编程方式设置活动配置文件。也可以使用 Spring 的ConfigurableEnvironment接口激活配置文件。 配置组有时，应用程序的配置文件定义太过精细，不同的配置放在一起也不好管理。为了解决这个问题，spring boot允许配置Profile Groups 123# 格式 spring.profiles.group.自定义逻辑名称[索引]=配置文件名spring.profiles.group.production[0]=proddbspring.profiles.group.production[1]=prodmq 在启动应用程序时需要激活production、proddb和prodmq配置文件，添加启动参数 1--spring.profiles.active=production","link":"/2021/05/22/language/Java/Spring%20Boot/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"},{"title":"Spring Boot 源码解析（一）依赖管理","text":"Spring Boot 中通过官方或第三方提供的启动类来集成各种组件的依赖管理方式 父工程pom文件解析首先建立一个springboot工程，只添加web依赖 工程创建成功后进入pom.xml文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zcy&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-mytest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-mytest&lt;/name&gt; &lt;description&gt;spring-boot-mytest&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 其中父项目部分为： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 不断进入父项目，得到的层级结构为： spring-boot-starter-parent文件spring-boot-starter-parent文件中定义的内容包括少量的properties属性、项目资源路径、插件以及插件版本的管理 properties属性： 123456789&lt;properties&gt; &lt;main.basedir&gt;${basedir}/../../..&lt;/main.basedir&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;&lt;/properties&gt; 资源路径： 12345678910111213141516171819&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/application*.yml&lt;/include&gt; &lt;include&gt;**/application*.yaml&lt;/include&gt; &lt;include&gt;**/application*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/application*.yml&lt;/exclude&gt; &lt;exclude&gt;**/application*.yaml&lt;/exclude&gt; &lt;exclude&gt;**/application*.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 插件以及插件版本的管理： 12345678&lt;pluginManagement&gt; &lt;plugins&gt; ... &lt;/plugins&gt;&lt;/pluginManagement&gt;&lt;plugins&gt; ...&lt;/plugins&gt; spring-boot-dependencies文件spring-boot-dependencies中主要定义了大量的properties属性，包括了当前选择的springboot版本所依赖的各种jar包的版本号 123456789101112131415161718192021222324252627282930&lt;properties&gt; &lt;main.basedir&gt;${basedir}/../..&lt;/main.basedir&gt; &lt;!-- Dependency versions --&gt; &lt;activemq.version&gt;5.15.13&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.81&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.10.1&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.13.2&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;awaitility.version&gt;4.0.3&lt;/awaitility.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;byte-buddy.version&gt;1.10.13&lt;/byte-buddy.version&gt; &lt;caffeine.version&gt;2.8.5&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;3.7.2&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.5.1&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.13&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.7.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.9&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-pool2.version&gt;2.7.0&lt;/commons-pool2.version&gt; &lt;couchbase-client.version&gt;2.7.16&lt;/couchbase-client.version&gt; &lt;couchbase-cache-client.version&gt;2.1.0&lt;/couchbase-cache-client.version&gt; &lt;db2-jdbc.version&gt;11.5.4.0&lt;/db2-jdbc.version&gt; &lt;derby.version&gt;10.14.2.0&lt;/derby.version&gt; &lt;dropwizard-metrics.version&gt;4.1.11&lt;/dropwizard-metrics.version&gt; &lt;ehcache.version&gt;2.10.6&lt;/ehcache.version&gt; &lt;ehcache3.version&gt;3.8.1&lt;/ehcache3.version&gt; ......&lt;/properties&gt; 除此之外还定义了插件以及插件版本 spring-boot-build文件spring-boot-build文件，主要声明了依赖（repositories）和插件（pluginRepositories）的远程仓库列表以及不同环境下的配置（profiles），另外还有插件管理的版本，内容大致如下： 总结通过上面三个父工程中的内容可以发现，各个父工程分别定义了插件、依赖版本、环境配置等信息进行了统一的声明和管理，但并未导入任何jar包，那工程中引入的那些jar包是从哪里引入的呢？ 启动器spring boot工程的jar包主要通过dependencies标签中的dependency标签声明需要的依赖和启动器，如下所示： 123456789101112&lt;!--启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--依赖注入 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.66&lt;/version&gt;&lt;/dependency&gt; 我们都知道SpringBoot可以快速的开发基于Spring框架的项目。由于围绕SpringBoot存在很多开箱即用的Starter依赖，遇到某个应用场景只需要引入对应的启动器然后进行相应的配置即可。 启动类的格式包括两种，分别由不同的命名格式： 官方提供的依赖启动器（spring-boot-starter-xxx） 技术框架的开发团队主动与spring boot进行整合提供的启动器（xxx-spring-boot-starter） 官方启动器内容进入spring-boot-starter-web启动器，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;${revision}&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;name&gt;Spring Boot Web Starter&lt;/name&gt; &lt;description&gt;Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container&lt;/description&gt; &lt;properties&gt; &lt;main.basedir&gt;${basedir}/../../..&lt;/main.basedir&gt; &lt;/properties&gt; &lt;scm&gt; &lt;url&gt;${git.url}&lt;/url&gt; &lt;connection&gt;${git.connection}&lt;/connection&gt; &lt;developerConnection&gt;${git.developerConnection}&lt;/developerConnection&gt; &lt;/scm&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以发现，spring-boot-starter-web启动器中包含了json、tomcat等启动器，另外也引入了spring-webmvc等相关依赖，spring boot内置了tomcat服务器，以tomcat为例，再进入spring-boot-starter-tomcat中，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--2.3.0版本以上没有parent部分--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;${revision}&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;name&gt;Spring Boot Tomcat Starter&lt;/name&gt; &lt;description&gt;Starter for using Tomcat as the embedded servlet container. Default servlet container starter used by spring-boot-starter-web&lt;/description&gt; &lt;properties&gt; &lt;main.basedir&gt;${basedir}/../../..&lt;/main.basedir&gt; &lt;/properties&gt; &lt;scm&gt; &lt;url&gt;${git.url}&lt;/url&gt; &lt;connection&gt;${git.connection}&lt;/connection&gt; &lt;developerConnection&gt;${git.developerConnection}&lt;/developerConnection&gt; &lt;/scm&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看到spring-boot-starter-tomcat启动器中引入了tomcat相关依赖，所以说spring boot内置了tomcat 替换tomcatSpring Boot默认支持Tomcat，Jetty，和Undertow作为底层容器。，并且默认使用tomcat作为服务器容器。如果需要切换servlet容器需要先排除tomcat启动器，然后再引入其他容器 pom.xml文件引入修改依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!--移除spring-boot-starter-web中的tomcat--&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!--引入jetty--&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 启动器父工程结构 此部分只针对于2.3.0以下的版本，2.3.0以上版本的启动类已经将parent标签去除，另外非官方提供的启动类一般也是没有parent的。 通过上面两个启动器可以发现他们的父工程都为spring-boot-starters，逐层进入父工程得到层次结构如下： 后三个父工程上面已经提到过，我们主要来看spring-boot-starters中的内容 可以发现该spring-boot-starters的pom文件中包含了大量的子模块，这些子模块就是spring boot官方提供的启动器，一共44个。另外文件中还有一些插件配置。 第三方启动类第三方启动类包括非官方提供的启动类以及自定义启动类，下面介绍自定义starter的过程 pom.xml文件中需要加入依赖自定义的start命名应遵循xxx-spring-boot-starter的命名规则，并且在启动器中应加入自动配置核心依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;spring boot版本&lt;/version&gt;&lt;/dependency&gt; 编写映射配置信息类@ConfigurationProperties注解可以将配置文件中的信息封装到当前类中，但需要使用@EnableConfigurationProperties注解或者@ConfigurationPropertiesScan注解进行注册，否则无法生效 123456789@ConfigurationProperties(prefix = &quot;ufo&quot;)public class MyProperties { private int id; private String name; //getter()/setter()} 编写enable注解只有在@enableUFO注解会引入ufoMarker类 12345678910//标记类public class ufoMarker {}@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import({ufoMarker.class})public @interface enableUFO {} 编写配置类这里通过构造函数注入MyProperties类 12345678910111213141516171819202122232425262728@Configuration//ioc容器中存在ufoMarker的bean时才加载该配置类@ConditionalOnBean(ufoMarker.class)@EnableConfigurationProperties({MyProperties.class})public class MyAutoConfiguration { private MyProperties myProperties; //通过构造方法引入myProperties //也可以通过@autowire注解引入 public MyAutoConfiguration(MyProperties myProperties) { this.myProperties = myProperties; } @Bean public UFO getUFO(){ return new UFO(); }}//实体类，用于测试public class UFO { public void hello(){ System.out.println(&quot;hello I am UFO&quot;); }} 编写spring.factories文件上面的过程结束后spring boot并不会进行扫描，需要在META-INFO目录下编写spring.factories文件，spring boot启动过程中会通过读取该文件，然后根据文件中的配置对类进行解析 123# 自动配置org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.zcy.myAotoconfigration.MyAutoConfiguration 测试在测试项目的pom.xml文件中引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.zcy&lt;/groupId&gt; &lt;artifactId&gt;ufo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-RELEASE&lt;/version&gt;&lt;/dependency&gt; 测试代码： 1234567891011121314151617181920@RestControllerpublic class TestController { @Autowired private UFO ufo; @RequestMapping(method = RequestMethod.GET,path = &quot;/ufo&quot;) public void hello(){ ufo.hello(); }}//启动类@SpringBootApplication//自定义starter生效@EnableUFOpublic class SpringBootMytestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMytestApplication.class, args); }} 配置文件： 12ufo.id=1ufo.name=ufo 测试结果：","link":"/2020/08/26/language/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Spring Boot 源码解析（三）SpringApplication 初始化","text":"Spring Boot 项目在开始导入依赖前会首先进行初始化操作 项目启动类如下： 123456@SpringBootApplicationpublic class SpringBootMytestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMytestApplication.class, args); }} 进入run()方法中： 123456789public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) { //调用重载方法 return run(new Class&lt;?&gt;[] { primarySource }, args);}//最终执行方法public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args);} 可见，spring boot的run()方法分为两部分 初始化SpringApplication配置 执行run方法 本篇主要讨论初始化SpringApplication部分，进入new SpringApplication(primarySources)中 12345678910111213141516171819202122232425262728public SpringApplication(Class&lt;?&gt;... primarySources) { this(null, primarySources);}private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;//进入重载方法public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { //此时resourceLoader为null this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); //此时primarySources为启动类SpringBootMytestApplication的class对象，将其转化为Set进行保存 this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //以下四个方法重要 //1、判断当前应用环境，一共有三种，一般为servlet this.webApplicationType = WebApplicationType.deduceFromClasspath(); //2、初始化classpath下 META-INF/spring.factories文件中 //配置的key为ApplicationContextInitializer的实例，并保存至实例变量中 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //3、和2中操作类似，只不过这里key为ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //4、推测 main 方法的类名 this.mainApplicationClass = deduceMainApplicationClass();}private ResourceLoader resourceLoader;private Set&lt;Class&lt;?&gt;&gt; primarySources;private WebApplicationType webApplicationType;private Class&lt;?&gt; mainApplicationClass; 下面分别介绍上述代码中的四个方法 获取应用环境进入WebApplicationType.deduceFromClasspath() 123456789101112131415161718192021222324252627282930313233343536//第一部分private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.web.servlet.DispatcherServlet&quot;;private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.springframework.web.reactive.DispatcherHandler&quot;;private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;;//第二部分private static final String[] SERVLET_INDICATOR_CLASSES = { &quot;javax.servlet.Servlet&quot;, &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; };static WebApplicationType deduceFromClasspath() { //ClassUtils.isPresent方法用于判断当前class loader中是否存在对应的类型 //如果存在上面第一部分三个常量中的DispatcherServlet，并且另外两个不存在， //这样证明这个项目是一个反应式 Web 应用程序，应该返回REACTIVE //一般情况下此时应该只存在WEBMVC_INDICATOR_CLASS if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } //SERVLET_INDICATOR_CLASSES中的两个类有一个不存在时返回NONE. //这两个类有一个不存在证明不是web应用程序. for (String className : SERVLET_INDICATOR_CLASSES) { if (!ClassUtils.isPresent(className, null)) { return WebApplicationType.NONE; } } //上述条件都不成立返回SERVLET return WebApplicationType.SERVLET;} 上面返回值的注解类如下 1234567891011121314151617public enum WebApplicationType { /** * 该应用程序不应作为 Web 应用程序运行，也不应启动嵌入式 Web 服务器。 */ NONE, /** * 该应用程序应作为基于 servlet 的 Web 应用程序运行，并应启动嵌入式 servlet Web 服务器。 */ SERVLET, /** * 该应用程序应作为反应式 Web 应用程序运行，并应启动嵌入式反应式 Web 服务器。 */ REACTIVE;} 上下文初始化器首先进入setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));中的getSpringFactoriesInstances(ApplicationContextInitializer.class)方法 12345678910111213141516private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) { return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {});}//进入getSpringFactoriesInstances()方法private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { //获取当前类加载器 ClassLoader classLoader = getClassLoader(); //通过上面获得的classLoader从META-INF/spring.factories 的资源文件中读取key为type.getName()的value //因为要确保唯一，所以转化为set集合 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //根据names创建springFactory实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //如果标注了Order注解，则按照注解进行排序 AnnotationAwareOrderComparator.sort(instances); return instances;} loadFactoryNames() 方法loadFactoryNames()方法是spring-core中提供的从META-INF/spring.factories中获取指定的类 （key）的同一入口方法。进入SpringFactoriesLoader.loadFactoryNames(type, classLoader)方法 123456public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { //factoryType为上面传入的ApplicationContextInitializer.class String factoryTypeName = factoryType.getName(); //根据factoryTypeName获取META-INF/spring.factories文件中对应的全类名 return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());} loadSpringFactories(classLoader)方法作用为获取META-INF/spring.factories文件中的全部配置信息，并封装成Map&lt;String, List&lt;String&gt;&gt;进行返回，此处不再展开。 所以此处最终返回的就是spring.factories文件中key为ApplicationContextInitializer的全类名集合，结果如下： createSpringFactoriesInstances() 方法进入createSpringFactoriesInstances方法中 12345678910111213141516171819202122private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) { //创建bean实例 List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size()); for (String name : names) { try { //获取class对象 Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader); Assert.isAssignable(type, instanceClass); //获取构造方法 Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes); //创建实例对象 T instance = (T) BeanUtils.instantiateClass(constructor, args); //添加到集合 instances.add(instance); } catch (Throwable ex) { throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex); } } return instances;} 该方法利用反射依次遍历names，然后创建对应的实例对象并加入到数组，最终返回，返回的结果如下： 监听器获取监听器实例集合与第2步类似，只不过这里key为ApplicationListener，此处直接展示结果 获取main方法类名进入deduceMainApplicationClass()方法 123456789101112131415161718private Class&lt;?&gt; deduceMainApplicationClass() { try { //获取堆栈信息 StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); //对获取的堆栈信息进行遍历 for (StackTraceElement stackTraceElement : stackTrace) { //判断对应堆栈的方法名是否为main if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) { //若是，即为启动类，使用forName创建对象实例并返回 return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { // Swallow and continue } return null;}","link":"/2020/10/15/language/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"Spring Boot 源码解析（二）@SpringBootApplication注解","text":"Spring Boot 项目入口所标记的 @SpringBootApplication 注解的作用和意义 创建Spring Boot工程后会自动生成一个启动类，用于启动spring boot项目： 123456@SpringBootApplicationpublic class SpringBootMytestApplication { public static void main(String[] args) { SpringApplication.run(SpringBootMytestApplication.class, args); }} 这个类中标注了@SpringBootApplication注解，进入到这个注解中： 123456789101112@Target(ElementType.TYPE) //注解标注的适用范围@Retention(RetentionPolicy.RUNTIME) //注解的生命周期@Documented //记录在doc文档中@Inherited //可被继承//------------------------------------------------------------------@SpringBootConfiguration //配置类@EnableAutoConfiguration //启动自动配置@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { ...} 可以看到这个注解是个组合注解，上面四个是元注解，下面三个是spring注解，接下来对其单独介绍 @SpringBootConfiguration进入到@SpringBootConfiguration注解中： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration { @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true;} 从上述源码可以看出，@SpringBootConfiguration注解内部有一个核心注解@Configuration，该注解是Spring框架提供的，表示当前类为一个配置类，并可以被组件扫描器扫描。由此可见，@SpringBootConfiguration注解的作用与@Configuration注解相同，都是标识一个可以被组件扫描器扫描的配置类，只不过@SpringBootConfiguration是被Spring Boot进行了重新封装命名而已 。 @EnableAutoConfiguration进入到@EnableAutoConfiguration注解中： 123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default {}; String[] excludeName() default {};} 除了元注解之外还有两个注解，为@AutoConfigurationPackage注解和@Import注解。 @AutoConfigurationPackage进入到@AutoConfigurationPackage注解中： 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage {} 可以发现，@AutoConfigurationPackage注解中也使用了@Import注解，引入了AutoConfigurationPackages.Registrar.class类，这个类的registerBeanDefinitions方法会在spring boot刷新上下文时被创建，进入这个内部类中 12345678910111213static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { //这个方法是向ioc中注册组件 register(registry, new PackageImport(metadata).getPackageName()); } @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImport(metadata)); }} 使用Debug模式启动项目可以看到 new PackageImport(metadata).getPackageName()的值为 进入register方法内部： 1234567891011121314151617181920private static final String BEAN = AutoConfigurationPackages.class.getName();public static void register(BeanDefinitionRegistry registry, String... packageNames) { //检查AutoConfigurationPackages.class是否已经被加载 if (registry.containsBeanDefinition(BEAN)) {//已注册 //获取beanDefinition BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); //获取构造参数值 ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues(); //更改参数中的packageNames constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); } else {//未注册则创建beanDefinition并将其注册到的ioc容器中 GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN, beanDefinition); }} 该方法参数有两个： packageNames：packageNames为项目的包名集合，在本项目中为com.zcy.springboottest。 registry：registry的类型为BeanDefinitionRegistry，我们常说的ioc容器其实就是 Beanfactory 中的一个 Map，key 是 Bean 的名称，value 是 Bean 对应的 BeanDefinition。BeanDefinitionRegistry 是一个接口，它定义了关于 BeanDefinition 的注册、移除、查询等一系列的操作，注册 Bean 的方法是 registerBeanDefinition。 此处@AutoConfigurationPackage注解的主要作用就是向ioc容器中注入了一个name为常量BEAN的beanDefinition，这个beanDefinition中存储着启动类的beanClass、packageNames等相关信息 @Import这个注解是自动配置的核心，上面通过@Import注解将AutoConfigurationImportSelector类引入， 1234public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { ... } 类关系图如下： AutoConfigurationImportSelector实现了很多接口： Aware接口：用于获取bean的相关信息 Ordered接口：用于处理相同接口实现类的优先级问题。 DeferredImportSelector接口：它是ImportSelector的子接口，ImportSelector接口是spring中导入外部配置的核心接口 自动配置执行流程在启动spring boot时自动配置的方法调用流程为： 如上图所示，spring boot启动时会调用ConfigurationClassParser类的process()方法，在这个方法中会调用handler.processGroupImports()，在其中调用grouping.getImports()方法。在getImports()方法中会分别调用两个DeferredImportSelector的内部类Group的方法（process和selectImports） 12345678910public Iterable&lt;Entry&gt; getImports() {Iterator var1 = this.deferredImports.iterator(); while(var1.hasNext()) { ConfigurationClassParser.DeferredImportSelectorHolder deferredImport = (ConfigurationClassParser.DeferredImportSelectorHolder)var1.next(); this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); } return this.group.selectImports();} process()方法1234567891011121314151617private final Map&lt;String, AnnotationMetadata&gt; entries = new LinkedHashMap&lt;&gt;();@Overridepublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) { Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); //获取自动配置实体 AutoConfigurationEntry autoConfigurationEntry =((AutoConfigurationImportSelector)deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry); //加入到entries集合 for (String importClassName : autoConfigurationEntry.getConfigurations()) { this.entries.putIfAbsent(importClassName, annotationMetadata); }} process()方法中首先通过getAutoConfigurationEntry方法获取自动配置类，然后又将自动配置类都加入到了entries中。 进入getAutoConfigurationEntry()方法，其中方法的调用和作用如下所示： 123456789101112131415161718192021protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); //获取spring.factories中每一个xxxAutoConfiguration List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //移除名字相同的配置类 configurations = removeDuplicates(configurations); //获取将要排除的自动配置类 //@SpringBootApplication可以指定exclude属性和excludeName属性用于排除特定的自动配置类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); //根据自动配置类上的注解进行过滤 configurations = filter(configurations, autoConfigurationMetadata); //触发事件 fireAutoConfigurationImportEvents(configurations, exclusions); //封装复合条件的自动配置类和排除的自动配置类 return new AutoConfigurationEntry(configurations, exclusions);} getCandidateConfigurations()方法在AutoConfigurationImportSelector中存在一个getCandidateConfigurations方法，它负责把 spring-boot-autoconfigure.jar/META-INF/spring.factories中每一个xxxAutoConfiguration文件都加载到容器中 12345678protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { //spring.factories中每一个xxxAutoConfiguration文件都加载到容器中 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;+ &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations;} SpringFactoriesLoader是一个抽象类，其主要功能就是从指定的配置文件META-INF/spring-factories加载配置，类中定义的静态属性定义了其加载资源的路径： public static final String FACTORIES_RESOURCE_LOCATION = “META-INF/spring.factories” 此外还有三个静态方法： loadFactories：加载指定的factoryClass并进行实例化。 loadFactoryNames：加载指定的factoryClass的名称集合。 instantiateFactory：对指定的factoryClass进行实例化。 以debug的方式启动项目观察到返回的值为： 可以发现AutoConfiguration类都被引入了。 getExclusions()方法1234567protected Set&lt;String&gt; getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) { Set&lt;String&gt; excluded = new LinkedHashSet&lt;&gt;(); excluded.addAll(asList(attributes, &quot;exclude&quot;)); excluded.addAll(Arrays.asList(attributes.getStringArray(&quot;excludeName&quot;))); excluded.addAll(getExcludeAutoConfigurationsProperty()); return excluded;} 在启动类上的@SpringBootApplication注解中可以指定exclude属性和excludeName属性用于排除特定的自动配置类，该方法就是将这些排除项取出 filter()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private List&lt;String&gt; filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata) { long startTime = System.nanoTime(); //将spring.factories中获取的自动配置类转出字符串数组 String[] candidates = StringUtils.toStringArray(configurations); //定义skip数组，用于判定是否需要跳过 boolean[] skip = new boolean[candidates.length]; //getAutoConfigurationImportFilters方法：拿到OnBeanCondition，OnClassCondition和OnWebApplicationCondition //然后遍历这三个条件类去过滤从spring.factories加载的大量配置类 boolean skipped = false; for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) { // 调用各种aware方法，将beanClassLoader,beanFactory等注入到filter对象中， // 这里的filter对象即OnBeanCondition，OnClassCondition或OnWebApplicationCondition invokeAwareMethods(filter); // 判断各种filter来判断每个candidate（这里实质要通过candidate(自动配置类)拿到其标注的 // @ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication里面的注解值）是否匹配， // 注意candidates数组与match数组一一对应 boolean[] match = filter.match(candidates, autoConfigurationMetadata); // 遍历match数组，注意match顺序跟candidates的自动配置类一一对应 for (int i = 0; i &lt; match.length; i++) { //如果不匹配 if (!match[i]) { skip[i] = true; candidates[i] = null; skipped = true; } } } // 这里表示若所有自动配置类经过OnBeanCondition，OnClassCondition和OnWebApplicationCondition过滤后， // 全部都匹配的话，则全部原样返回 if (!skipped) { return configurations; } // 建立result集合来装匹配的自动配置类 List&lt;String&gt; result = new ArrayList&lt;&gt;(candidates.length); for (int i = 0; i &lt; candidates.length; i++) { // 若skip[i]为false，则说明是符合条件的自动配置类，此时添加到result集合中 if (!skip[i]) { result.add(candidates[i]); } } //打印日志 if (logger.isTraceEnabled()) { int numberFiltered = configurations.size() - result.size(); logger.trace(&quot;Filtered &quot; + numberFiltered + &quot; auto configuration class in &quot; + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + &quot; ms&quot;); } // 最后返回符合条件的自动配置类 return new ArrayList&lt;&gt;(result);} 该方法会根据每个xxxAutoConfiguration配置类上的条件注解判断该类是否应该被加载，最后再将自动配置类集合返回 条件注解spring.factories文件里每一个xxxAutoConfiguration文件上的条件注解包括： @ConditionalOnClass ： classpath中存在该类时起效 @ConditionalOnMissingClass ： classpath中不存在该类时起效 @ConditionalOnBean ： DI容器中存在该类型Bean时起效 @ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效 @ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效 @ConditionalOnExpression ： SpEL表达式结果为true时 @ConditionalOnProperty ： 参数设置或者值一致时起效 @ConditionalOnResource ： 指定的文件存在时起效 @ConditionalOnJndi ： 指定的JNDI存在时起效 @ConditionalOnJava ： 指定的Java版本存在时起效 @ConditionalOnWebApplication ： Web应用环境下起效 @ConditionalOnNotWebApplication ： 非Web应用环境下起效 selectImports()方法12345678910111213141516171819@Overridepublic Iterable&lt;Entry&gt; selectImports() { if (this.autoConfigurationEntries.isEmpty()) { return Collections.emptyList(); } //得到所有要清除的自动配置类 Set&lt;String&gt; allExclusions = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getExclusions).flatMap(Collection::stream).collect(Collectors.toSet()); //得到所有符合条件的自动配置类 Set&lt;String&gt; processedConfigurations = this.autoConfigurationEntries.stream() .map(AutoConfigurationEntry::getConfigurations).flatMap(Collection::stream) .collect(Collectors.toCollection(LinkedHashSet::new)); //再次过滤 processedConfigurations.removeAll(allExclusions); //对标注了@Ordered注解的配置类进行排序 return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream() .map((importClassName) -&gt; new Entry(this.entries.get(importClassName), importClassName)) .collect(Collectors.toList());} selectImports 方法主要是针对经过排除掉 exclude 的和被AutoConfigurationImportFilter 接口过滤后的满足条件的自动配置类再进一步排除 exclude 的自动配置类，然后再排序。 @ComponentScan@ComponentScan用于类或接口上用于指定扫描路径，spring会把指定路径下带有指定注解的类自动装配到bean容器里。其作用等同于&lt;context:component-scan base-package=”xxx” /&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan { @AliasFor(&quot;basePackages&quot;) String[] value() default {}; // 指定扫描路径，如果为空则以@ComponentScan注解的类所在的包为基本的扫描路径 @AliasFor(&quot;value&quot;) String[] basePackages() default {}; // 指定具体扫描的类 Class&lt;?&gt;[] basePackageClasses() default {}; Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class; ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; String resourcePattern() default &quot;**/*.class&quot;; boolean useDefaultFilters() default true; // 指定满足Filter条件的类 ComponentScan.Filter[] includeFilters() default {}; // 指定排除Filter条件的类 ComponentScan.Filter[] excludeFilters() default {}; boolean lazyInit() default false; @Retention(RetentionPolicy.RUNTIME) @Target({}) public @interface Filter { FilterType type() default FilterType.ANNOTATION; @AliasFor(&quot;classes&quot;) Class&lt;?&gt;[] value() default {}; @AliasFor(&quot;value&quot;) Class&lt;?&gt;[] classes() default {}; String[] pattern() default {}; }} @SpringBootApplication注解中@ComponentScan注解的为： 123456@ComponentScan( excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) 表示排除TypeExcludeFilter和AutoConfigurationExcludeFilter两个类，其中FilterType： 123456789101112131415public enum FilterType { // 注解类型 ANNOTATION, // 指定的类型 ASSIGNABLE_TYPE, // 按照Aspectj的表达式，基本上不会用到 ASPECTJ, // 按照正则表达式 REGEX, // 自定义规则 CUSTOM; private FilterType() { }}","link":"/2020/09/10/language/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Spring Boot 源码解析（五）bean注册顺序","text":"Spring Boot 在启动时将 bean 注册进 ioc 容器中，包括 Spring Boot 内置的 bean 、启动类引入的 bean 及自定义的 bean 本文讨论的是所有 bean 注入到 ioc 容器中的流程 bean注册顺序spring会将 bean 封装为beanDefination然后通过方法注入到ioc容器中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); //检查传入的beanDefinition是否是AbstractBeanDefinition类型 if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition)beanDefinition).validate(); } catch (BeanDefinitionValidationException var8) { throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, var8); } } //看当前ioc容器中是否存在名为beanName的bean，不存在则返回null BeanDefinition existingDefinition = (BeanDefinition)this.beanDefinitionMap.get(beanName); //如果已存在 if (existingDefinition != null) { //如果不允许bean覆盖，则报错 if (!this.isAllowBeanDefinitionOverriding()) { throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); } /** 关于AbstractBeanDefinition的role属性 * ROLE_APPLICATION = 0 :用户 * ROLE_SUPPORT = 1：某些复杂配置一部分 * ROLE_INFRASTRUCTURE = 2：完全内部使用，与用户无关 * 定义这个bean的应用 */ // 如果已存在的bean的role更小，输出框架的bean覆盖用户定义的bean if (existingDefinition.getRole() &lt; beanDefinition.getRole()) { if (this.logger.isInfoEnabled()) { this.logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName + &quot;' with a framework-generated bean definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } //如果是一个bean } else if (!beanDefinition.equals(existingDefinition)) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with a different definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } } else if (this.logger.isTraceEnabled()) { this.logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName + &quot;' with an equivalent definition: replacing [&quot; + existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;); } //当前bean覆盖原有bean this.beanDefinitionMap.put(beanName, beanDefinition); } else { //这里底层逻辑是return !this.alreadyCreated.isEmpty(); //alreadyCreated是AbstractBeanFactory类的一个类型为Set&lt;String&gt;的属性 //这里的意思是alreadyCreated集合不为空，表示开始自动配置bean和自定义bean的注册 //springboot创建时会先将一些内置的Processor和Reader注册到ioc中， //加入完成后才会加载其他的bean，这个if就是判断是否开始加载其他bean if (this.hasBeanCreationStarted()) { synchronized(this.beanDefinitionMap) { //加入ioc容器 this.beanDefinitionMap.put(beanName, beanDefinition); //这里不直接添加beanName是因为异步，并且beanDefinitionNames线程不安全 //创建一个新的beanDefinitionNames集合 List&lt;String&gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); //将原有的beanDefinitionNames集合和当前beanName添加进去 updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); //替换原有的 this.beanDefinitionNames = updatedDefinitions; this.removeManualSingletonName(beanName); } } else { //加入ioc容器 this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.removeManualSingletonName(beanName); } this.frozenBeanDefinitionNames = null; } if (existingDefinition == null &amp;&amp; !this.containsSingleton(beanName)) { if (this.isConfigurationFrozen()) { this.clearByTypeCache(); } } else { this.resetBeanDefinition(beanName); }} 使用debug进行调试 在进入当前if语句内时已经经过了七次else，此时的beanDefinitionMap数据为： 结论根据上述分析可知bean注册的顺序分别为： 内置（处理器）Processor和（读取器）Reader，用于读取和处理配置 启动类 启动类包下的标记@Configuration、@controller、@component等注解的bean 自动配置类的bean","link":"/2021/01/18/language/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"},{"title":"Spring MVC 参数绑定","text":"SpringMVC 中前台发送的请求会被转发到对应的controller中相匹配的方法上，SpringMVC提供了多种参数绑定机制使得可以将参数直接绑定到方法参数 默认参数类型有些类型的参数只需要在controller中方法的形参列表中声明，SpringMVC 就会自动绑定，不需要其他额外操作，如： HttpServletRequest HttpServletResponse HttpSession Model/ModelMap 测试代码如下： 123456789101112131415@RequestMapping(path = &quot;/default&quot;,method = RequestMethod.GET)public String bindParam(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model, ModelMap modelMap){ System.out.println(request); System.out.println(response); System.out.println(session); System.out.println(model); System.out.println(modelMap); return &quot;&quot;;} 使用get发送请求，根据debug得到结果可以看到参数均被获取到 基本数据类型基本数据类型包括 byte、short、int、long、float、double、char、boolean。在参数是基本数据类型并且请求参数名称和方法参数名称相同时 SpringMVC 也会自动绑定，如果不同可以使用 @RequestParam注解和@PathVariable注解。 @RequestParam 注解 作用： 相当于request.getParameter(请求参数中的key) 将获取的值绑定到该注解修饰中的参数中 无论是请求体里的参数还是url上的参数@RequestParam 注解都能匹配 url请求格式：请求路径?param1=1&amp;param2=2 无法解析json类型，只能用String类型接收 属性： value：请求参数中的key required：true/false，表示该URL是否必须要带有该参数，默认是true default：如果required设置为true，但是URL中没有指定的key，则默认取该值进行参数绑定 测试代码如下： 12345678@RequestMapping(path = &quot;/basic&quot;,method = RequestMethod.POST)public String basic(int intValue,long longValue,char charValue,boolean boolValue){ System.out.println(intValue); System.out.println(longValue); System.out.println(charValue); System.out.println(boolValue); return &quot;&quot;;} 使用post请求发送请求，从结果中可以看出，参数被自动绑定了，值得注意的是boolean类型的参数如果缺少会自动置为false，其他类型则会报错，这是因为如果没有传值的话会默认赋值为null，但基本数据类型不能为null。 当请求参数与方法参数名不同时 12345@RequestMapping(path = &quot;/basic&quot;,method = RequestMethod.POST)public String basic(int intValue1){ System.out.println(intValue1); return &quot;&quot;;} 此时程序报错 加入 @RequestParam 注解后参数绑定成功，此时如果缺少请求参数也会抛出异常 @PathVariable注解 作用： 解析url上携带的参数，请求格式：请求路径/{param} 属性： name：参数的key value：同name required：是否必须，同@RequestParam 测试代码如下： 12345678@GetMapping(path = &quot;/PathVariable/{id}&quot;)public String testPath(@PathVariable(name = &quot;id&quot;) int a){ System.out.println(a); return &quot;&quot;;}//请求http://localhost:8080/PathVariable/3 结果： 包装类型包装类型包括Integer、Long、Byte、Double、Float、Short，（String 类型在这也是适用），与基本数据类型的绑定基本一致，唯一不同的是包装类的数据如果缺少请求参数不会抛出异常，而会置为默认值null。 实体类SpringMVC会将参数自动注入到实体类中，对于嵌套实体类可以通过”属性名.内部对象属性名”的方式绑定。 测试代码如下： 1234567//实体类@Datapublic class User { private String name; private int age; private boolean sex;} 123456//controller方法@RequestMapping(path = &quot;/pojo&quot;,method = RequestMethod.POST)public String pojo(User user){ System.out.println(user); return &quot;&quot;;} 发送请求，可以看到只要请求参数和而实体类的属性名称相同就可以绑定成功，而缺少请求参数的属性会为默认值，如果请求参数与实体类的属性类型不符则会报错 如果方法参数有多个实体类并且存在属性名相同的情况，则所有的实体类对应的属性都会被绑定 1234567//其中dog和user有共同属性为name@RequestMapping(path = &quot;/pojo&quot;,method = RequestMethod.POST)public String pojo(User user, Dog dog){ System.out.println(user); System.out.println(dog); return &quot;&quot;;} 结果中user和dog的name属性都被赋值为”张三” 如果存在复合实体类，例如： 1234567@Datapublic class User { private String name; private int age; private boolean sex; private Dog dog;} 此时，如果想为user的dog绑定参数则请求参数需要以dog.name形式传递 日期类型问题： 对于字符串类型的日期参数，转换成Data的参数，会有转换类型问题。 解决方法： 如果使用的是spring boot，有三种方式解决： 使用@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)注解在实体类的字段上，这种方式比较简单，但每个字段都要添加注解比较麻烦。 写一个BaseController，每一个需要处理的controller继承这个BaseController，在BaseController里使用@InitBinder写一个全局转换日期方法： @InitBinder 注解 @InitBinder 作用于Controller中的方法上，表示为当前控制器注册一个属性编辑器，只对当前的Controller有效。 @InitBinder 标注的方法必须有一个参数WebDataBinder。webDataBinder是用于表单到方法的数据绑定的。用于帮助我们完成参数绑定。 12345678910111213141516@RequestMapping(&quot;bindParam&quot;)public class BindParam { @InitBinder public void initBinder(ServletRequestDataBinder binder) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true)); } @RequestMapping(value = &quot;/date&quot;, method = RequestMethod.GET) public String test(Date dateTime) { System.out.println(dateTime); return &quot;&quot;; }} 自定义DateConverterConfig实现一下spring提供的Converter，重写里面的convert方法即可（推荐）： 1234567891011121314151617181920212223242526272829303132333435363738394041@Componentpublic class DateConvert implements Converter&lt;String, Date&gt; { private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4); static{ formarts.add(&quot;yyyy-MM&quot;); formarts.add(&quot;yyyy-MM-dd&quot;); formarts.add(&quot;yyyy-MM-dd hh:mm&quot;); formarts.add(&quot;yyyy-MM-dd hh:mm:ss&quot;); } @Override public Date convert(String source) { String value = source.trim(); if (&quot;&quot;.equals(value)) { return null; } if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(0)); }else if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(1)); }else if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} {1}\\\\d{1,2}:\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(2)); }else if(source.matches(&quot;^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} {1}\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}$&quot;)){ return parseDate(source, formarts.get(3)); }else { throw new IllegalArgumentException(&quot;Invalid boolean value '&quot; + source + &quot;'&quot;); } } public Date parseDate(String dateStr, String format) { Date date=null; try { DateFormat dateFormat = new SimpleDateFormat(format); date = dateFormat.parse(dateStr); } catch (Exception e) { } return date; }} 如果未使用spring boot，配置和上面第三种方法类似，只不过需要到xml配置文件注册这个类： 1234567891011121314&lt;!-- 第一步: 创建自定义日期转换规则 --&gt; &lt;bean id=&quot;dateConvert&quot; class=&quot;自定义Convert的全类名&quot;/&gt;&lt;!-- 第二步： 创建convertion-Service ，并注入dateConvert--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;dateConvert&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 第三步：注册处理器映射器/处理器适配器 ，添加conversion-service属性--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 集合类型1. 数组 数组类型直接作为方法参数，可接受基本类型数据和包装类，映射不到的话数组为null。 1234567891011@RequestMapping(path = &quot;/array&quot;,method = RequestMethod.POST)public String array(@RequestParam(&quot;array&quot;) Integer[] ids){ System.out.println(ids); return &quot;&quot;;}@RequestMapping(path = &quot;/arrayBasic&quot;,method = RequestMethod.POST)public String arrayBasic(@RequestParam(&quot;array&quot;) Integer[] ids){ System.out.println(ids); return &quot;&quot;;} 以实体类作为形参，并且实体类中包含数组类型，那么数组类型可以成功接收（这种情况集合也适用，测试代码放到集合部分）2. 集合 如果集合类型直接作为方法形参，则会报错 以实体类作为形参，并且实体类中包含集合类型，那么集合类型可以成功接收 12345678910111213141516//实体类@Datapublic class Person { private String[] strings; private Integer[] integers; private int[] ints; private List&lt;String&gt; list; private List&lt;String&gt; set;}//controller中的方法，以Person作为参数@RequestMapping(path = &quot;/list&quot;,method = RequestMethod.GET)public String list(Person person){ System.out.println(person); return &quot;&quot;;} 请求参数key和实体类的属性名称要一致 结果显示数据全部绑定成功 Map Map直接作为形参无法获取到值，需要以实体类作为形参，实体类中包含map类型的属性 1234@Datapublic class Dog { private Map&lt;String,String&gt; map;} 请求参数格式如下： json类型前后端交互式常常使用json类型，SpringMVC接收json类型时有两种方式进行参数绑定 json类型的数据可以通过一个String类型的参数接收，然后使用fastjson进行解析 可以通过 @RequestBody 注解进行参数绑定 @RequestBody @RequestBody主要用来接收前端传递给后端的json字符串中的数据(请求体中的数据) 在后端的同一个接收方法里，@RequestBody 与 @RequestParam 可以同时使用，但一个请求，只有一个RequestBody和多个RequestParam所以@RequestBody只能使用一次，而@RequestParam可以使用多次。 json字符串中，如果value为””的话，后端对应属性如果是String类型的，那么接受到的就是””，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。 json字符串中，如果value为null的话，后端对应收到的就是null。 使用 @RequestBody 注解接收参数根据json格式不同主要有以下三种情况： 使用实体类进行接收1234567891011121314151617181920//实体类，并且属性包括包装类、基本数据类型、自定义类、集合类@Datapublic class Person { private String name; private int age; private Integer height; private Dog mainDog; private List&lt;Dog&gt; dogs;}@Datapublic class Dog { private String name;}@PostMapping(path = &quot;/json&quot;)public String json(@RequestBody Person person){ System.out.println(person); return &quot;&quot;;} 发送的json主要为对象的嵌套 1{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:2,&quot;height&quot;:180,&quot;mainDog&quot;:{&quot;name&quot;:&quot;白狗&quot;},&quot;dogs&quot;:[{&quot;name&quot;:&quot;黑狗&quot;},{&quot;name&quot;:&quot;黄狗&quot;}]} 得到结果，参数被成功接收 使用List进行接收12345@PostMapping(path = &quot;/json&quot;)public String json(@RequestBody List&lt;Dog&gt; dogs){ System.out.println(dogs); return &quot;&quot;;} 发送的json为数组形式 1[{&quot;name&quot;:&quot;白狗&quot;},{&quot;name&quot;:&quot;黑狗&quot;}] 结果显示参数被正确接收 使用Map进行接收12345@GetMapping(path = &quot;/json&quot;)public String json(@RequestBody Map&lt;String,Dog&gt; dogs){ System.out.println(dogs); return &quot;&quot;;} json类型主要为键值对形式 1{&quot;dog1&quot;:{&quot;name&quot;:&quot;黑狗&quot;},&quot;dog2&quot;:{&quot;name&quot;:&quot;白狗&quot;}} 结果显示参数被正确接收","link":"/2021/05/10/language/Java/Spring%20MVC/SpringMVC%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"},{"title":"Spring Boot 源码解析（四）run()方法执行流程","text":"Spring Boot 将依赖注入到 IOC 容器的过程 前一篇说到这个方法 123public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args);} SpringApplication初始化完成后执行run方法，进入run方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ConfigurableApplicationContext run(String... args) { //记录运行时间 StopWatch stopWatch = new StopWatch(); stopWatch.start(); //上下文对象 ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); //1、获取并启动监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //2、构造应用上下文环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); //3、初始化上下文 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] {ConfigurableApplicationContext.class }, context); //4、刷新应用上下文前的准备阶段 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //5、刷新应用上下文 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } listeners.started(context); callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context;} 由上面可知，run方法中重要步骤有六步 获取并启动监听器 获取并启动监听器获取并启动监听器相关代码如下： 123//1、获取并启动监听器SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting(); 进入getRunListeners方法中 1234567891011private SpringApplicationRunListeners getRunListeners(String[] args) { Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class }; //返回的是一个新建的SpringApplicationRunListeners对象 //第一个参数为logger，第二个参数为getSpringFactoriesInstances方法的返回值 return new SpringApplicationRunListeners( logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args) );} 上面调用了方法有两个，分别为getSpringFactoriesInstances()方法和new SpringApplicationRunListeners()方法，其中第一个方法是个构造方法，而第二个方法在上一篇初始化阶段就已经介绍过，就是获取Initializers和Listeners所调用的方法 12345678910111213141516171819202122232425//首先进入new SpringApplicationRunListeners()方法//可以看到这个方法只是简单的将外部传递的log和listeners集合赋值给了对象的属性SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners) { this.log = log; this.listeners = new ArrayList&lt;&gt;(listeners);}//接着看获取listeners集合的getSpringFactoriesInstances()方法//其实就是根据传入的key获取对应的spring.factories文件中的list集合private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { //获取当前类加载器 ClassLoader classLoader = getClassLoader(); //在META-INF/spring.factories 的资源文件中读取key为 //org.springframework.boot.SpringApplicationRunListener的value Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //获得springFactory实例 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //排序 AnnotationAwareOrderComparator.sort(instances); return instances;}//spring.factories文件中对应获取的数据，只有一个# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener EventPublishingRunListener监听器是用来监听spring boot在启动过程中不同阶段的事件，并且把这些事件通知给初始化阶段获取的ApplicationListener的那11个监听器 getRunListeners(args)的这部分方法执行完毕后返回的就是一个SpringApplicationRunListeners对象，内部包含了监听器集合，然后会调用listeners.starting()方法 1234567void starting() { //此方法只是将listeners对象中的监听器集合进行遍历，分别调用starting()方法 //此时集合内只有一个listener for (SpringApplicationRunListener listener : this.listeners) { listener.starting(); }} 构建应用上下文环境构建应用上下文环境部分负责加载和配置系统的环境变量以yml和propertise配置文件的相关信息，后面如果想要获取配置文件和环境变量等信息就可以直接查找到，相关代码如下： 123456//2、构造应用上下文环境ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);//处理需要忽略的beanconfigureIgnoreBeanInfo(environment);//打印spring启动时的那个图标Banner printedBanner = printBanner(environment); 下面两个方法比较简单，首先来看一下configureIgnoreBeanInfo方法 12345678910public static final String IGNORE_BEANINFO_PROPERTY_NAME = &quot;spring.beaninfo.ignore&quot;;private void configureIgnoreBeanInfo(ConfigurableEnvironment environment) { //是否配置了spring.beaninfo.ignore if (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) { //根据配置的spring.beaninfo.ignore的配置来判断是否忽略，后面会用来忽略一些bean Boolean ignore = environment.getProperty(&quot;spring.beaninfo.ignore&quot;, Boolean.class, Boolean.TRUE); System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString()); }} 进入prepareEnvironment方法 1234567891011121314151617181920212223242526private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) { //（1）创建和配置环境变量 //创建环境 ConfigurableEnvironment environment = getOrCreateEnvironment(); //配置环境信息 configureEnvironment(environment, applicationArguments.getSourceArgs()); //添加新建的一个name为configurationProperties的source ConfigurationPropertySources.attach(environment); //（2）启动响应监听器 listeners.environmentPrepared(environment); //将environment绑定到SpringApplication上 //里面只有一行代码：Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this)); bindToSpringApplication(environment); //是自定义环境 if (!this.isCustomEnvironment) { //添加环境转换器 environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary( environment, deduceEnvironmentClass() ); } //和上面调用的一个方法 ConfigurationPropertySources.attach(environment); return environment;} 创建和配置环境变量进入getOrCreateEnvironment方法 123456789101112131415private ConfigurableEnvironment getOrCreateEnvironment() { //如果不为null直接返回 if (this.environment != null) { return this.environment; } //根据当前应用类型初始化不同的环境变量 switch (this.webApplicationType) { case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); }} 一般的非响应式的web项目项目类型都是SERVLET，所以会返回StandardServletEnvironment类型对象 获取环境对象后，进入configureEnvironment(environment, applicationArguments.getSourceArgs())方法，配置环境信息 123456789101112protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) { //设置类型转换的服务接口 if (this.addConversionService) { ConversionService conversionService = ApplicationConversionService.getSharedInstance(); environment.setConversionService((ConfigurableConversionService) conversionService); } //该方法会将args封装成SimpleCommandLinePropertySource对象 //然后注入到environment的propertySources属性中(args不为空的话) configurePropertySources(environment, args); //激活配置文件，其实就是将配置添加到environment的activeProfiles属性中 configureProfiles(environment, args);} environment对象内容如下 将propertySources展开就可以看到： 上面name为环境的标识，source保存的是相关信息，此处展开的是环境信息，除此之外还有jdk信息、命令行参数信息等等。例如命令行参数的配置信息name为commandLineArgs 上面都完成之后会调用ConfigurationPropertySources.attach(environment)方法，该方法作用就是添加一个新建的name为configurationProperties的source，至此环境配置结束。 启动响应监听器启动监听器的部分包括： 12345678910111213141516//（2）启动响应监听器listeners.environmentPrepared(environment);//将environment绑定到SpringApplication上//里面只有一行代码：Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));bindToSpringApplication(environment);//是自定义环境if (!this.isCustomEnvironment) { //添加环境转换器 environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary( environment, deduceEnvironmentClass() );}//和上面调用的一个方法ConfigurationPropertySources.attach(environment);return environment; 首先进入environmentPrepared方法 123456void environmentPrepared(ConfigurableEnvironment environment) { //遍历this.listeners，里面只有一个元素，就是上面获取的EventPublishingRunListener for (SpringApplicationRunListener listener : this.listeners) { listener.environmentPrepared(environment); }} 最终会进入Spring的方法如下方法 1234567891011121314151617181920212223public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) { ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event); //获取任务执行器 Executor executor = this.getTaskExecutor(); //主要是这里 //获取了一个迭代器，里面是监听器 Iterator var5 = this.getApplicationListeners(event, type).iterator(); //下面依次进行遍历 while(var5.hasNext()) { ApplicationListener&lt;?&gt; listener = (ApplicationListener)var5.next(); //如果executor不为null if (executor != null) { //用executor进行执行 executor.execute(() -&gt; { this.invokeListener(listener, event); }); } else { //否则直接执行 this.invokeListener(listener, event); } }} 上面获取迭代器的this.getApplicationListeners(event, type)得到的值其实就是初始化时的11个监听器中的七个（这7个单独在同一个spring.factories文件中） 其中第一个监听器ConfigFileApplicationListener就是用于加载配置文件（yml和propertise）的，进入这个监听器内可以看到如下注解（这里为了方便看，我将英文全部替换成中文）： 1234567891011121314151617181920212223242526/** * 默认会加载'application.properties' and/or 'application.yml'两个文件内容来配置上下文， * 会在下面四个路径中寻找配置文件 * &lt;ul&gt; * file是工程根目录，和src同级 * classpath是resource下 * &lt;li&gt;file:./config/&lt;/li&gt; * &lt;li&gt;file:./&lt;/li&gt; * &lt;li&gt;classpath:config/&lt;/li&gt; * &lt;li&gt;classpath:&lt;/li&gt; * &lt;/ul&gt; * 该列表按优先级排序（在列表中较高位置定义的属性覆盖在较低位置定义的属性）。 * &lt;p&gt; * 可以使用特定的{@link #setSearchLocations(String)} 和 {@link #setSearchNames(String)} * 来替代搜索的位置和名称 * &lt;p&gt; * 还将根据动态配置加载其他文件。 * 例如，如果“web”配置文件处于活动状态，则将考虑加载“application-web.properties”和“application-web.yml”。 * &lt;p&gt; * “spring.config.name”属性可用于指定要加载的替代名称， * “spring.config.location”属性可用于指定替代搜索位置或特定文件。 * &lt;p&gt; */public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered { ...} 总之，使用EventPublishingRunListener监听器来触发这7个监听器中只有ConfigFileApplicationListener监听器负责加载配置文件，然后注入到environment中 配置文件加载规则根据上面ConfigFileApplicationListener类上的注释可以总结出spring boot配置文件加载方式，如下： 默认加载顺序： file:./config/ file:./ classpath:config/ classpath: file是工程根目录，和src同级 classpath是resource路径下 加载规则： 先加载的配置优先级更高 如果同级目录下存在yml和properties，则先读取properties 默认加载’application.properties’ 和 ‘application.yml’两个文件 还将根据动态配置加载其他文件，比如多环境下进行配置，使其加载application-dev或application-prop名字的文件文件 spring.config.name属性可用于指定要加载的替代名称， spring.config.location属性可用于指定替代搜索位置或特定文件。 初始化上下文该部分相关代码为： 1234567891011//上下文对象ConfigurableApplicationContext context = null;Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();...//3、初始化上下文context = createApplicationContext();//又是这个方法，根据传入的class作为key，创建spring.factories文件中对应的对象//exceptionReporters主要是用来报告spring boot启动过程中的错误exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); 上下文对象即为ConfigurableApplicationContext类型的context对象。ConfigurableApplicationContext是ApplicationContext的子类并在其之上增加了配置上下文的工具，具体类图如下： 从上图可以看到BeanFactory类，它提供了ioc容器的最基本形式，它的实现类包括 DefaultListableBeanFactory（spring boot用的是这个）、XmlBeanFactory、ApplicationContext等 进入createApplicationContext方法中 12345678910111213141516171819202122232425262728293031323334public static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = &quot;org.springframework.boot.&quot; + &quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;;public static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = &quot;org.springframework.&quot; + &quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;;public static final String DEFAULT_CONTEXT_CLASS = &quot;org.springframework.context.&quot; + &quot;annotation.AnnotationConfigApplicationContext&quot;;protected ConfigurableApplicationContext createApplicationContext() { Class&lt;?&gt; contextClass = this.applicationContextClass; //如果还没初始化上下文 if (contextClass == null) { try { //根据应用类型加载不同的contextClass类 switch (this.webApplicationType) { case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); } } catch (ClassNotFoundException ex) { throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); } } //根据加载到的contextClass进行实例化并转换类型后返回 return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);} 上面三个常量所对应的类的继承关系基本一致所以下面只列出AnnotationConfigServletWebServerApplicationContext的类关系图 其他两个类的继承关系的结构和上图基本一致，只不过某些类的实现和名称不同 上下文对象创建完成后context中的beanFactory 刷新应用上下文准备阶段刷新上下文准备阶段主要代码为： 12//4、刷新应用上下文前的准备阶段prepareContext(context, environment, listeners, applicationArguments, printedBanner); 进入refreshContext方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) { //将上一步获取的环境对象赋值给应用上下文对象 context.setEnvironment(environment); //（1）应用上下文后置方法，主要是添加转换器 postProcessApplicationContext(context); //（2）应用上面获取的那些初始化器 applyInitializers(context); //向第一步获取的监听器发送事件，这个监听器会触发其他相关监听器 listeners.contextPrepared(context); //记录启动信息 if (this.logStartupInfo) { logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); } // Add boot specific singleton beans //增加指定的单例bean //获取ioc容器 ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); //将main函数的参数封装成bean并注册 beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); //用于打印启动图标的printedBanner不为空，则注册 if (printedBanner != null) { beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); } //beanFactory真实类型是DefaultListableBeanFactory if (beanFactory instanceof DefaultListableBeanFactory) { ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } //是否懒加载 if (this.lazyInitialization) { context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); } //（3）加载启动类 //拿到启动类，set中只有一个对象，启动类 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); //注册启动类 load(context, sources.toArray(new Object[0])); //发布事件 listeners.contextLoaded(context);} 应用上下文后置方法应用上下文后置方法为postProcessApplicationContext(context)它的作用就是添加了大量的转换器，代码如下： 1234567891011121314151617181920protected void postProcessApplicationContext(ConfigurableApplicationContext context) { if (this.beanNameGenerator != null) { context.getBeanFactory().registerSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,this.beanNameGenerator); } if (this.resourceLoader != null) { if (context instanceof GenericApplicationContext) { ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader); } if (context instanceof DefaultResourceLoader) { ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader()); } } //添加转换器 if (this.addConversionService) { //ConversionService 是一个类型转换服务接口，并且还是线程安全的。 //ApplicationConversionService是他的一个实现类，里面包含了一大堆转换器 context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance()); }} 这里主要关注的是getSharedInstance方法 12345678910111213141516//getSharedInstance()这里使用了单例模式public static ConversionService getSharedInstance() { ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance; //双重锁检查 if (sharedInstance == null) { synchronized (ApplicationConversionService.class) { sharedInstance = ApplicationConversionService.sharedInstance; if (sharedInstance == null) { //新建ApplicationConversionService对象 sharedInstance = new ApplicationConversionService(); ApplicationConversionService.sharedInstance = sharedInstance; } } } return sharedInstance;} 可以看出，这里使用了单例模式，创建了ApplicationConversionService对象，进入该构造方法 123456789101112131415161718192021222324public ApplicationConversionService() { this(null);}public ApplicationConversionService(StringValueResolver embeddedValueResolver) { if (embeddedValueResolver != null) { setEmbeddedValueResolver(embeddedValueResolver); } //给this添加一堆转换器 configure(this);}//主要是configure(this)方法，它负责注入各种类型的转换器public static void configure(FormatterRegistry registry) { //添加默认转换器，也就是适用于大多数环境的转换器。 DefaultConversionService.addDefaultConverters(registry); //添加默认格式化程序，适用于大多数环境的格式化程序：包括数字格式化程序，JSR-354货币和货币格式化程序， //JSR-310日期时间格式化程序和/或Joda时间格式化程序，具体取决于类路径上相应API的存在。 DefaultFormattingConversionService.addDefaultFormatters(registry); //添加对大多数Spring Boot应用程序有用的格式化程序。 addApplicationFormatters(registry); //添加对大多数Spring Boot应用程序有用的转换器。 addApplicationConverters(registry);} 应用初始化器这里的初始化器指的是初始化阶段获取的那些，此处会调用他们进行初始化操作，每个初始化器执行的逻辑各有不同，进入applyInitializers方法中 123456789101112131415161718@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })protected void applyInitializers(ConfigurableApplicationContext context) { //遍历初始化阶段获取的初始化器 for (ApplicationContextInitializer initializer : getInitializers()) { //泛型工具类，resolveTypeArgument用来解析泛型参数 //这一步的的作用就是获取按照initializer的继承链向上找 //直到ApplicationContextInitializer类， //然后获取ApplicationContextInitializer类此时泛型的真实类型 //如果没有则返回空值 Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class); //判断context是不是上面的泛型类型的实例 Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;); //没问题了就初始化，这里每次遍历的initializer对象不同，经路的initialize方法实现也不同 //但基本都是为context执行一些初始化的操作，添加和设置一些东西包括上下文id，监听器等 initializer.initialize(context); }} 加载启动类这里主要的方法为load(context, sources.toArray(new Object[0])) 123456789101112131415161718protected void load(ApplicationContext context, Object[] sources) { if (logger.isDebugEnabled()) { logger.debug(&quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources)); } //获取loader //getBeanDefinitionRegistry(context)获取的register对象用于加载definition对象到ioc容器中 BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources); if (this.beanNameGenerator != null) { loader.setBeanNameGenerator(this.beanNameGenerator); } if (this.resourceLoader != null) { loader.setResourceLoader(this.resourceLoader); } if (this.environment != null) { loader.setEnvironment(this.environment); } loader.load();} 进入load方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int load() { int count = 0; for (Object source : this.sources) { //调用重载方法 count += load(source); } return count;}//重载方法private int load(Object source) { Assert.notNull(source, &quot;Source must not be null&quot;); //从Class加载 //source是启动类，会进入这里 if (source instanceof Class&lt;?&gt;) { return load((Class&lt;?&gt;) source); } //从Resource加载 if (source instanceof Resource) { return load((Resource) source); } //从Package加载 if (source instanceof Package) { return load((Package) source); } //从CharSequence加载 if (source instanceof CharSequence) { return load((CharSequence) source); } throw new IllegalArgumentException(&quot;Invalid source type &quot; + source.getClass());}//最终调用private int load(Class&lt;?&gt; source) { if (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) { // Any GroovyLoaders added in beans{} DSL can contribute beans here GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class); load(loader); } //是否标记了@Component，启动类上的组合注解包括该注解 if (isComponent(source)) { //注册启动类 this.annotatedReader.register(source); return 1; } return 0;} 刷新应用上下文这部分是spring boot自动配置的核心，相关代码为 1this.refreshContext(context); 由于这里主要使用spring的方法，而且嵌套过多，所以只列出相关代码其他省略，进入refreshContext方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void refreshContext(ConfigurableApplicationContext context) { if (this.registerShutdownHook) { try { context.registerShutdownHook(); } catch (AccessControlException var3) { } } //主要方法 this.refresh((ApplicationContext)context);}//进入this.refreshprotected void refresh(ApplicationContext applicationContext) { Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext); //主要方法 this.refresh((ConfigurableApplicationContext)applicationContext);}//进入this.refreshprotected void refresh(ConfigurableApplicationContext applicationContext) { applicationContext.refresh();}//进入applicationContext.refresh//这里是spring的源码，主要需要关注invokeBeanFactoryPostProcessors(beanFactory)方法的部分//它完成了ioc容器的上下文初始化过程public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. //刷新上下文环境 prepareRefresh(); //这里获取了spring boot之前创建的ioc容器 ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); //准备bean工厂，以便在此上下文中使用 prepareBeanFactory(beanFactory); obtainFreshBeanFactory(); try { //设置 beanFactory 的后置处理 postProcessBeanFactory(beanFactory); //调用 BeanFactory 的后处理器，这些处理器是在Bean 定义中向容器注册的 invokeBeanFactoryPostProcessors(beanFactory); //注册Bean的后处理器，在Bean创建过程中调用 registerBeanPostProcessors(beanFactory); //对上下文中的消息源进行初始化 initMessageSource(); //初始化上下文中的事件机制 initApplicationEventMulticaster(); //初始化其他特殊的Bean onRefresh(); //检查监听Bean并且将这些监听Bean向容器注册 registerListeners(); //实例化所有的（non-lazy-init）单件 finishBeanFactoryInitialization(beanFactory); //发布容器事件，结束Refresh过程 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 进入invokeBeanFactoryPostProcessors方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors()); //...}//进入invokeBeanFactoryPostProcessors方法public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { //... if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory; //... invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); }}//进入invokeBeanDefinitionRegistryPostProcessors方法private static void invokeBeanDefinitionRegistryPostProcessors(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) { Iterator var2 = postProcessors.iterator(); //遍历postProcessors并执行postProcessBeanDefinitionRegistry方法 while(var2.hasNext()) { BeanDefinitionRegistryPostProcessor postProcessor = (BeanDefinitionRegistryPostProcessor)var2.next(); //主要方法 postProcessor.postProcessBeanDefinitionRegistry(registry); }}//进入postProcessBeanDefinitionRegistry方法public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { //... this.processConfigBeanDefinitions(registry); //...}//进入processConfigBeanDefinitions方法public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList(); //中间过程为configCandidates添加了一个数据（启动类的BeanDefinitionHolder） if(...){ //... }else{ configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } //转换为set，应该是为了去重 Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet(configCandidates); do { //（1）这里面会解析各个注解，包括组合类中的两个@import，获取自动配置类 parser.parse(candidates); //... //获取了configClasses，后面将此作为参数传入loadBeanDefinitions开始注册过程 Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet(parser.getConfigurationClasses()); //... //（2）将获取的自动配置类加载到ioc中 this.reader.loadBeanDefinitions(configClasses); //... }while(!candidates.isEmpty());} 到了这里一共有两个重要的方法，下面分别讨论 parse方法进入到ConfigurationClassParser类的parse方法 12345678910111213141516171819202122232425262728public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { //便利configCandidates，此时只有一个启动类 Iterator var2 = configCandidates.iterator(); while(var2.hasNext()) { BeanDefinitionHolder holder = (BeanDefinitionHolder)var2.next(); BeanDefinition bd = holder.getBeanDefinition(); try { //前面将启动类封装成了AnnotatedBeanDefinition类型并注入ioc容器中 if (bd instanceof AnnotatedBeanDefinition) { //【1】、【2】步骤在这里面 //该方法主要就是解析各个注解的 this.parse(((AnnotatedBeanDefinition)bd).getMetadata(), holder.getBeanName()); } else if (...) { //... } else { //... } } catch (BeanDefinitionStoreException var6) { throw var6; } catch (Throwable var7) { throw new BeanDefinitionStoreException(&quot;...&quot;); } } //【3】加载默认的配置---》（对springboot项目来说这里就是自动装配的入口了） this.deferredImportSelectorHandler.process();} 注意这里this.parse(((AnnotatedBeanDefinition)bd).getMetadata(), holder.getBeanName());这个方法会解析类上的注解，并且该方法会递归调用，递归的情况有两种： 在这个方法执行过程中会判断当前类上是否有@Component/@Configuration注解，如果有就会递归调用parse方法 在此方法内处理@import注解时会通过调用processImports方法查找并引入相关的类，此时也会递归调用parse方法 进入parse方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException { this.processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);}//进入processConfigurationClassprotected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException { //这里会进行校验，符合条件才会执行下面方法 //... //这里sourceClass为启动类 ConfigurationClassParser.SourceClass sourceClass = this.asSourceClass(configClass, filter); do { //递归处理Bean，如果有父类，递归处理，直到顶层父类 sourceClass = this.doProcessConfigurationClass(configClass, sourceClass, filter); } while(sourceClass != null); this.configurationClasses.put(configClass, configClass);}//进入doProcessConfigurationClass方法，spring中do开头的才是真正干活的方法protected final ConfigurationClassParser.SourceClass doProcessConfigurationClass(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass, Predicate&lt;String&gt; filter) throws IOException { //处理内部类 if (configClass.getMetadata().isAnnotated(Component.class.getName())) { this.processMemberClasses(configClass, sourceClass, filter); } //处理@PropertySource注解 //并将该注解指定的properties配置文件中的值存储到Spring的 Environment中 //Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值。 Iterator var4 = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, PropertySource.class).iterator(); AnnotationAttributes importResource; while(var4.hasNext()) { importResource = (AnnotationAttributes)var4.next(); if (this.environment instanceof ConfigurableEnvironment) { this.processPropertySource(importResource); } else { this.logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); } } //【1】处理@ComponentScan注解 Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { Iterator var14 = componentScans.iterator(); while(var14.hasNext()) { AnnotationAttributes componentScan = (AnnotationAttributes)var14.next(); //执行扫描 Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); Iterator var8 = scannedBeanDefinitions.iterator(); while(var8.hasNext()) { BeanDefinitionHolder holder = (BeanDefinitionHolder)var8.next(); BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } //检查是否是配置类（有@configuration/@component注解），则递归查找关联类 //关联类包括内部的@bean注解定义的bean或者@import注解引入的类 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { this.parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } //【2】处理@Import注解 //这里的处理是递归的 //SpringBoot项目中经常用的各种@Enable*** 注解基本都是封装的@Import this.processImports(configClass, sourceClass, this.getImports(sourceClass), filter, true); //处理@ImportResource注解 importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); String[] var20 = resources; int var22 = resources.length; for(int var23 = 0; var23 &lt; var22; ++var23) { String resource = var20[var23]; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } //先把@Bean的方法存入beanMethods,后面this.reader.loadBeanDefinitions(configClasses)会继续处理@Bean,那时候才会真正实例化@Bean; Set&lt;MethodMetadata&gt; beanMethods = this.retrieveBeanMethodMetadata(sourceClass); Iterator var18 = beanMethods.iterator(); while(var18.hasNext()) { MethodMetadata methodMetadata = (MethodMetadata)var18.next(); configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces this.processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) { this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } // No superclass -&gt; processing is complete return null;} 介绍上面标记的几个和自动配置相关的注解处理方法 处理@ComponentScan注解相关代码： 123456789101112131415161718192021222324252627//【1】处理@ComponentScan注解Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);//没有@ComponentScan注解注解或条件注解不通过if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { Iterator var14 = componentScans.iterator(); while(var14.hasNext()) { AnnotationAttributes componentScan = (AnnotationAttributes)var14.next(); //执行扫描 Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); Iterator var8 = scannedBeanDefinitions.iterator(); while(var8.hasNext()) { BeanDefinitionHolder holder = (BeanDefinitionHolder)var8.next(); BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } //检查是否是配置类（有@configuration/@component注解），则递归查找关联类 //关联类包括内部的@bean注解定义的bean或者@import注解引入的类 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { this.parse(bdCand.getBeanClassName(), holder.getBeanName()); } } }} 这部分代码会根据@ComponentScan注解扫描对应路径的bean，如果没有设置basePackages属性，那么默认为标记的类的路径，进入 this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());方法 1234567891011121314//解析@ComponentScan方法中主要就是对该注解的各个属性进行处理，最后再根据basePackages进行扫描public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) { //... //如果basePackages属性为空则默认值为对应类的包路径 if (basePackages.isEmpty()) { basePackages.add(ClassUtils.getPackageName(declaringClass)); } //... //根据basePackages扫描类 return scanner.doScan(StringUtils.toStringArray(basePackages));} 因为启动spring boot项目时启动类会进入到该方法，并且启动类中的@ComponentScan注解没有给basePackages属性赋值，所以在扫描时会扫描启动类路径下的包和类，接着进入scanner.doScan(StringUtils.toStringArray(basePackages))方法 12345678910111213141516171819202122232425262728293031323334353637383940//扫描启动类路径下的包和类protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); //用来返回的beanDefinitions集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; //遍历basePackages数组中的各个路径，由于是启动类，basePackages也只有一个元素：com.zcy.springbootmytest for(int var5 = 0; var5 &lt; var4; ++var5) { String basePackage = var3[var5]; //【1.1】从指定路径扫描bean，并加载bean Set&lt;BeanDefinition&gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); //遍历加载到的bean while(var8.hasNext()) { BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); } if (this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); //将bean装载到beanDefinitions中 beanDefinitions.add(definitionHolder); //【1.2】将bean注册到ioc容器中 this.registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions;} 从指定目录扫描bean进入this.findCandidateComponents(basePackage)方法，该方法拼接了一个扫描路径，然后根据扫描路径匹配全部的类，在之后对扫描到的类进行排查，看是否有@Component注解，如果有，则将其封装成BeanDefinition，最终将封装好的BeanDefinition返回，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//这里会调用的是this.scanCandidateComponents(basePackage)方法public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) { return this.componentsIndex != null &amp;&amp; this.indexSupportsIncludeFilters() ? this.addCandidateComponentsFromIndex(this.componentsIndex, basePackage) : this.scanCandidateComponents(basePackage);}//进入this.scanCandidateComponents(basePackage)方法private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) { LinkedHashSet candidates = new LinkedHashSet(); try { //拼接路径，结果为：classpath*:com/zcy/springbootmytest/**/*.class String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern; //根据路径扫描匹配所有类 Resource[] resources = this.getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = this.logger.isTraceEnabled(); boolean debugEnabled = this.logger.isDebugEnabled(); Resource[] var7 = resources; int var8 = resources.length; //遍历扫描到的类 for(int var9 = 0; var9 &lt; var8; ++var9) { Resource resource = var7[var9]; if (traceEnabled) { this.logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = this.getMetadataReaderFactory().getMetadataReader(resource); //判断该类是不是 @Component 注解标注的类，并且不是需要排除掉的类 if (this.isCandidateComponent(metadataReader)) { //将该类封装成ScannedGenericBeanDefinition（BeanDefinition接口的实现类）类 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) { if (debugEnabled) { this.logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else if (debugEnabled) { this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } catch (Throwable var13) { throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not readable: &quot; + resource); } } //最终将封装好的BeanDefinition返回 return candidates; } catch (IOException var14) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14); }} 将bean注册到ioc容器中可以看到虽然该方法最终返回了beanDefinitions集合，但其实beanDefinition已经被注入 1234//将bean装载到beanDefinitions中beanDefinitions.add(definitionHolder);//【1.2】将bean注册到ioc容器中this.registerBeanDefinition(definitionHolder, this.registry); 处理@Import注解相关代码： 1234//【2】处理@Import注解//这里的处理是递归的//SpringBoot项目中经常用的各种@Enable*** 注解基本都是封装的@Importthis.processImports(configClass, sourceClass, this.getImports(sourceClass), filter, true); 涉及到的方法有两个 this.getImports方法：获取@import注解集合 processImports方法： 获取@import注解集合首先进入getImports方法中 12345678910111213141516171819202122232425262728private Set&lt;ConfigurationClassParser.SourceClass&gt; getImports(ConfigurationClassParser.SourceClass sourceClass) throws IOException { Set&lt;ConfigurationClassParser.SourceClass&gt; imports = new LinkedHashSet(); Set&lt;ConfigurationClassParser.SourceClass&gt; visited = new LinkedHashSet(); this.collectImports(sourceClass, imports, visited); return imports;}//进入collectImports方法//这个方法是一个递归方法，直到解析到@import注解或者没有注解为止private void collectImports(ConfigurationClassParser.SourceClass sourceClass, Set&lt;ConfigurationClassParser.SourceClass&gt; imports, Set&lt;ConfigurationClassParser.SourceClass&gt; visited) throws IOException { if (visited.add(sourceClass)) { //取出当前注解 Iterator var4 = sourceClass.getAnnotations().iterator(); //遍历当前注解 while(var4.hasNext()) { ConfigurationClassParser.SourceClass annotation = (ConfigurationClassParser.SourceClass)var4.next(); String annName = annotation.getMetadata().getClassName(); //如果当前注解不是@import继续遍历包含的注解，否则直接跳出递归将注解加入到imports中 if (!annName.equals(Import.class.getName())) { this.collectImports(annotation, imports, visited); } } //最终将@import注解返回 imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), &quot;value&quot;)); }} 引入的类加入到对应集合进入processImports方法中，上一个方法已经解析出了该类的注解并传入到了本方法中，本方法先判断解析的注解是否为空，如果为空直接退出，若不为空则对注解进行遍历，启动类上注解引入的两个类分别为AutoConfigurationImportSelector.class和AutoConfigurationPackages.Registrar.class，这两个类分别是ImportSelector和ImportBeanDefinitionRegistrar的子类，本方法会对这两个类分别进行处理，处理的过程就是将这两个类加入到对应的集合中，集合会在注解解析完之后分别进行执行，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) { if (!importCandidates.isEmpty()) { if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) { this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { Iterator var6 = importCandidates.iterator(); while(var6.hasNext()) { //遍历@import注解引入的类 ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next(); Class candidateClass; //这里判断是否引入的是ImportSelector if (candidate.isAssignable(ImportSelector.class)) { //加载引入类 candidateClass = candidate.loadClass(); //判断是否排除 ImportSelector selector = (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter(); if (selectorFilter != null) { exclusionFilter = exclusionFilter.or(selectorFilter); } //如果是DeferredImportSelector则进入 if (selector instanceof DeferredImportSelector) { //这个方法主要是将AutoConfigurationImportSelector加入到了 //deferredImportSelectors中 this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = this.asSourceClasses(importClassNames, exclusionFilter); this.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false); } //这里判断引入的是否是ImportBeanDefinitionRegistrar } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); //加入到importBeanDefinitionRegistrars中 configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { //其他类会进入这里，比如配置引入的类，后面会说明 //加入到configurationClasses中 this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); } } } catch (BeanDefinitionStoreException var17) { throw var17; } catch (Throwable var18) { throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, var18); } finally { this.importStack.pop(); } } }} 到这里注解的解析和启动类所在目录下的类都已经成功引入了，接下来进行的就是对@import引入的两个类进行执行的过程 加载默认配置上面两个步骤都是parse方法内部的parse方法里的，在执行完内部parse会执行 12//【3】加载默认的配置---》（对springboot项目来说这里就是自动装配的入口了）this.deferredImportSelectorHandler.process(); 由于上面两个方法已经将AutoConfigurationImportSelector加入到deferredImportSelectorHandler中，这里会对其进行执行，也就是引入自动配置类集合，进入该方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void process() { //拿到上一步deferredImportSelectors存储的DefererdImportSelectorHolder对象 //其内部封装了AutoConfigurationImportSelector.class类 List&lt;ConfigurationClassParser.DeferredImportSelectorHolder&gt; deferredImports = this.deferredImportSelectors; this.deferredImportSelectors = null; try { if (deferredImports != null) { ConfigurationClassParser.DeferredImportSelectorGroupingHandler handler = ConfigurationClassParser.this.new DeferredImportSelectorGroupingHandler(); deferredImports.sort(ConfigurationClassParser.DEFERRED_IMPORT_COMPARATOR); //先把DefererdImportSelectorHolder对象注册到ioc容器 deferredImports.forEach(handler::register); //自动配置的核心 handler.processGroupImports(); } } finally { this.deferredImportSelectors = new ArrayList(); }}//进入handler.processGroupImports()方法public void processGroupImports() { Iterator var1 = this.groupings.values().iterator(); while(var1.hasNext()) { ConfigurationClassParser.DeferredImportSelectorGrouping grouping = (ConfigurationClassParser.DeferredImportSelectorGrouping)var1.next(); Predicate&lt;String&gt; exclusionFilter = grouping.getCandidateFilter(); //grouping.getImports()方法就是获取自动配置类目录的方法 grouping.getImports().forEach((entry) -&gt; { //获取配置类信息后，使用forEach进行遍历 ConfigurationClass configurationClass = (ConfigurationClass)this.configurationClasses.get(entry.getMetadata()); try { //方法其实已经前面【2.2】用过了 //就是在解析import注解时引入ImportSelector和Register类的那个方法 ConfigurationClassParser.this.processImports(configurationClass, ConfigurationClassParser.this.asSourceClass(configurationClass, exclusionFilter), Collections.singleton(ConfigurationClassParser.this.asSourceClass(entry.getImportClassName(), exclusionFilter)), exclusionFilter, false); } catch (BeanDefinitionStoreException var5) { throw var5; } catch (Throwable var6) { throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configurationClass.getMetadata().getClassName() + &quot;]&quot;, var6); } }); }} grouping.getImports()方法debug结果： 进入grouping.getImports()方法 12345678910public Iterable&lt;Entry&gt; getImports() { Iterator var1 = this.deferredImports.iterator(); while(var1.hasNext()) { ConfigurationClassParser.DeferredImportSelectorHolder deferredImport = (ConfigurationClassParser.DeferredImportSelectorHolder)var1.next(); this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); } return this.group.selectImports();} 这个方法其实就是第二篇中的查看导入的AutoConfigurationImportSelector.class类的入口方法，当时的类调用图如下： 红色框出的就是当前方法所在的位置。到这里就已经和之前第二篇分析的自动配置执行连接起来了，此处不再赘述。 最后在拿到spring.factories文件中的自动配置类后会调用ConfigurationClassParser.this.processImports方法，这个方法在之前解析@import注解时就已经使用过（其实在这部分用的方法大多上面都已经介绍过） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) { if (!importCandidates.isEmpty()) { if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) { this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { Iterator var6 = importCandidates.iterator(); while(var6.hasNext()) { ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next(); Class candidateClass; if (candidate.isAssignable(ImportSelector.class)) { //处理引入的ImportSelector } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { //处理引入的1Registrar } else { //此时会进入这里 //这个方法会将类添加到一个imports集合中 //this.imports.add(importedClass, importingClass); this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); //这个方法主要用来条件评估，然后将符合条件的自动配置类加入到configurationClasses中 //加入该集合的类会在（2）统一引入 this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); } } } catch (BeanDefinitionStoreException var17) { throw var17; } catch (Throwable var18) { throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, var18); } finally { this.importStack.pop(); } } }}///进入this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter)方法protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException { //根据条件注解判断是否需要跳过 if (!this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) { ConfigurationClass existingClass = (ConfigurationClass)this.configurationClasses.get(configClass); //判断配置类是否已经引入 if (existingClass != null) { if (configClass.isImported()) { if (existingClass.isImported()) { existingClass.mergeImportedBy(configClass); } return; } this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); } //获取配置类 ConfigurationClassParser.SourceClass sourceClass = this.asSourceClass(configClass, filter); do { //又是这个方法， //这里主要是因为配置类也会有内部的bean、内部类等需要进行解析 sourceClass = this.doProcessConfigurationClass(configClass, sourceClass, filter); } while(sourceClass != null); //加入到configurationClasses中 this.configurationClasses.put(configClass, configClass); }} 结果就是，被引入的那些类都被加入到了configurationClasses中 loadBeanDefinitions方法上面的一系列过程通过递归等操作，将需要引入的那些类根据不同的类型分别加入到了不同集合中 deferredImportSelectors：ImportSelector类型，例如AutoConfigurationImportSelector类 importBeanDefinitionRegistrars：ImportBeanDefinitionRegistrar类型，例如AutoConfigurationPackages.Registrar类 configurationClasses：其他类型，例如引入的配置类、自己包中定义的类 beanMethods：类中的@bean注解引入的bean 这一部分就是将上面的这些类和相关类注册进ioc容器中，注意本方法的参数在前面通过 1Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet(parser.getConfigurationClasses()); 获取到了，所以configurationModel就是configurationClasses集合的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) { ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator = new ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator(); Iterator var3 = configurationModel.iterator(); //遍历configurationModel while(var3.hasNext()) { ConfigurationClass configClass = (ConfigurationClass)var3.next(); //将集合中的类注册到ioc容器 this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); }}//进入this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator)private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator) { //根据条件注解判断是否需要跳过 if (trackedConditionEvaluator.shouldSkip(configClass)) { //获取beanName String beanName = configClass.getBeanName(); //有beanName而且ioc中不包含 if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) { this.registry.removeBeanDefinition(beanName); } //移除bean this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); } else { //是被引入的，则先将该配置类加入到ioc容器中 if (configClass.isImported()) { //里面应该是覆盖原本的bean this.registerBeanDefinitionForImportedConfigurationClass(configClass); } Iterator var3 = configClass.getBeanMethods().iterator(); while(var3.hasNext()) { BeanMethod beanMethod = (BeanMethod)var3.next(); //【1】注册beanMethods this.loadBeanDefinitionsForBeanMethod(beanMethod); } //【2】注册 this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); //【3】注册Registrar this.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); }} 注册beanMethods1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) { ConfigurationClass configClass = beanMethod.getConfigurationClass(); //获取方法名，bean的name会根据方法名设置 MethodMetadata metadata = beanMethod.getMetadata(); String methodName = metadata.getMethodName(); //根据条件注解判断是否需要跳过 if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) { configClass.skippedBeanMethods.add(methodName); } else if (!configClass.skippedBeanMethods.contains(methodName)) { //还没有注册 //获取注解属性 AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class); Assert.state(bean != null, &quot;No @Bean annotation attributes&quot;); //获取name属性，没有设置则为空集合 List&lt;String&gt; names = new ArrayList(Arrays.asList(bean.getStringArray(&quot;name&quot;))); //如果names不为空则以name作为beanName，否则使用方法名 String beanName = !names.isEmpty() ? (String)names.remove(0) : methodName; Iterator var8 = names.iterator(); //对每个names都作为key进行注册别名 while(var8.hasNext()) { String alias = (String)var8.next(); this.registry.registerAlias(beanName, alias); } //检查名字是否存在，有就报错 if (this.isOverriddenByExistingDefinition(beanMethod, beanName)) { if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) { throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(), beanName, &quot;Bean name derived from @Bean method '&quot; + beanMethod.getMetadata().getMethodName() + &quot;' clashes with bean name for containing configuration class; please make those names unique!&quot;); } } else {//名字没重复 //包装成beanDefinition ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition(configClass, metadata); beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource())); //下面就是为beanDefinition赋一些值，不重要的直接掠过 //... //下面是对注解的解析，判断是否加了对应注解 beanDef.setAutowireMode(3); beanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE); AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata); //处理@autowire注解 Autowire autowire = (Autowire)bean.getEnum(&quot;autowire&quot;); if (autowire.isAutowire()) { beanDef.setAutowireMode(autowire.value()); } //处理@autowireCandidate注解 boolean autowireCandidate = bean.getBoolean(&quot;autowireCandidate&quot;); if (!autowireCandidate) { beanDef.setAutowireCandidate(false); } //处理@initMethod注解 String initMethodName = bean.getString(&quot;initMethod&quot;); if (StringUtils.hasText(initMethodName)) { //设置初始化方法 beanDef.setInitMethodName(initMethodName); } //处理@destroyMethod注解 String destroyMethodName = bean.getString(&quot;destroyMethod&quot;); //设置销毁方法 beanDef.setDestroyMethodName(destroyMethodName); //处理@Scope注解（代理模式） ScopedProxyMode proxyMode = ScopedProxyMode.NO; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class); if (attributes != null) { beanDef.setScope(attributes.getString(&quot;value&quot;)); proxyMode = (ScopedProxyMode)attributes.getEnum(&quot;proxyMode&quot;); if (proxyMode == ScopedProxyMode.DEFAULT) { proxyMode = ScopedProxyMode.NO; } } BeanDefinition beanDefToRegister = beanDef; //如果代理模式不是no，则进行相应处理 if (proxyMode != ScopedProxyMode.NO) { BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(new BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS); beanDefToRegister = new ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition((RootBeanDefinition)proxyDef.getBeanDefinition(), configClass, metadata); } if (logger.isTraceEnabled()) { logger.trace(String.format(&quot;Registering bean definition for @Bean method %s.%s()&quot;, configClass.getMetadata().getClassName(), beanName)); } //这个方法就是将bean注册进ioc容器中 this.registry.registerBeanDefinition(beanName, beanDefToRegister); } }} 注册ImportedResources这个方法应该是从配置文件中导入bean，由于项目中都是使用注解导入，这里重要性比较低，所以只做简单介绍，进入this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources())方法 123456789101112131415161718192021222324252627282930313233private void loadBeanDefinitionsFromImportedResources(Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources) { Map&lt;Class&lt;?&gt;, BeanDefinitionReader&gt; readerInstanceCache = new HashMap(); importedResources.forEach((resource, readerClass) -&gt; { //判断文件类型 if (BeanDefinitionReader.class == readerClass) { if (StringUtils.endsWithIgnoreCase(resource, &quot;.groovy&quot;)) { readerClass = GroovyBeanDefinitionReader.class; } else { readerClass = XmlBeanDefinitionReader.class; } } //获取读取器 BeanDefinitionReader reader = (BeanDefinitionReader)readerInstanceCache.get(readerClass); if (reader == null) { try { reader = (BeanDefinitionReader)readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(this.registry); if (reader instanceof AbstractBeanDefinitionReader) { AbstractBeanDefinitionReader abdr = (AbstractBeanDefinitionReader)reader; abdr.setResourceLoader(this.resourceLoader); abdr.setEnvironment(this.environment); } readerInstanceCache.put(readerClass, reader); } catch (Throwable var6) { throw new IllegalStateException(&quot;Could not instantiate BeanDefinitionReader class [&quot; + readerClass.getName() + &quot;]&quot;); } } //读取资源 reader.loadBeanDefinitions(resource); });} 注册Registrar被加入到ImportBeanDefinitionRegistrars集合中的类会在这里被加载，默认调用每个ImportBeanDefinitionRegistrars的registerBeanDefinitions方法，具体实现由其类自己定义，下面只拿注册类上的AutoConfigurationPackages.Registrar举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) { registrars.forEach((registrar, metadata) -&gt; { registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator); });}//这里调用每个registrar的registerBeanDefinitions方法，registerBeanDefinitions由其自己实现//进入registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator)//ImportBeanDefinitionRegistrar类public interface ImportBeanDefinitionRegistrar { //调用了registerBeanDefinitions default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) { this.registerBeanDefinitions(importingClassMetadata, registry); } //进入这里，AutoConfigurationPackages.Registrar.class是他的一个实现类 //所以真正进入的是AutoConfigurationPackages.Registrar.class default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { }}//AutoConfigurationPackages.Registrar.class//由于第二篇已经说过，这里只显示代码，不做过多解释static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { //进入到这个方法 @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { //这个方法是向ioc中注册组件 register(registry, new PackageImport(metadata).getPackageName()); } @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImport(metadata)); }}//接着进入register方法public static void register(BeanDefinitionRegistry registry, String... packageNames) { if (registry.containsBeanDefinition(BEAN)) { BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN); ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues(); constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)); } else { GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(BasePackages.class); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN, beanDefinition); }}","link":"/2020/12/04/language/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"},{"title":"Spring 数据访问：JDBC","text":"spring 中对 JDBC 进行了封装并提供了数据源和配置方式和数据库访问方法 spring提供了jdbc抽象，它完成了以下部分的工作： 打开连接 准备并运行SQL 循环遍历结果（如果需要） 处理异常 处理事务 关闭连接 开发人员需要做的任务如下： 定义连接参数 指定SQL语句 声明并提供参数 完成迭代工作 相关组件core org.springframework.jdbc.core包：包含JdbcTemplate类及其各种回调接口以及相关类 org.springframework.jdbc.core.simple包：包含SimpleJdbcInsert和 SimpleJdbcCall类 org.springframework.jdbc.core.namedparam包：包含NamedParameterJdbcTemplate 该类和相关的支持类； datasource org.springframework.jdbc.datasource包：包含一个便于 DataSource访问的实用程序类和各种简单的DataSource实现 org.springfamework.jdbc.datasource.embedded包：提供对使用 Java 数据库引擎（如 HSQL、H2 和 Derby）创建嵌入式数据库的支持 object org.springframework.jdbc.object包：包含将 RDBMS 查询、更新和存储过程表示为线程安全、可重用对象的类。依赖于org.springframework.jdbc.core包中的抽象 support org.springframework.jdbc.support包：提供SQLException翻译功能和一些实用程序类 访问数据库方式spring提供了jdbc的四种访问方式 JdbcTemplate：最常用的方式； NamedParameterJdbcTemplate：包装了一个JdbcTemplate，提供命名参数功能，取代了传统的?占位符。提高了可读性； SimpleJdbcInsert 和SimpleJdbcCall：优化数据库元数据以限制必要匹配的数量。只需要提供表或过程的名称，并提供与列名匹配的参数映射 RDBMS（MappingSqlQuery, SqlUpdate, and StoredProcedure）：要求在初始化数据访问层期间创建可重用和线程安全的对象。可以使用execute()、update()、findObject()等方法； JdbcTemplate引入依赖123456789101112&lt;!--jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--根据需求替换数据库引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt; 配置数据源123456789101112131415&lt;!--数据源，由于展示原因，这里不用占位符，实际工作中请将value中的值进行替换--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/springStudy&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;&lt;/bean&gt;&lt;!--模板类--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--引入外部配置，之后可以通古在value属性中使用${}占位符获取外部配置--&gt;&lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; 操作数据库方法使用JdbcTemplate提供的方法操作数据库需要自己写sql，并使用?作为占位符。需要注意的是JdbcTemplate的方法的结果集不会帮我们进行封装，只有在返回结果是基本类型时才会直接返回对应类型的结果，而当我梦想要获取自定义类型的结果时，无论是单个的还是一个集合的都需要自定义结果映射逻辑： 结果映射：JdbcTemplate的方法很多需要使用结果映射对象作为参数，下面会直接使用这个对象，定义形式如下 123456789//结果映射类，因为jdbc查询结束后会将数据保存在ResultSet中，//如果是单列且基本类型的数据，底层会直接赋值，也就不需要手动映射//但对于自定义的pojo，我们需要手动处理结果映射RowMapper&lt;Animal&gt; animalRowMapper = (resultSet, rowNum)-&gt;{ Animal a = new Animal(); a.setId(resultSet.getInt(&quot;id&quot;)); a.setName(resultSet.getString(&quot;name&quot;)); return a;}; queryForObject()：查询单个数据 1234567//获取单个数据(单列)String queryForCount = &quot;select count(*) from animal&quot;;Integer count = jdbcTemplate.queryForObject(queryForCount, Integer.class);//获取单条数据(多列)String queryForSingle = &quot;select id,name from animal where id=?&quot;;Animal animal = (Animal) jdbcTemplate.queryForObject(queryForSingle,animalRowMapper,124); queryForMap()：获取单个数据，Map中包含的每一列就是一个条目，key为列名，value为值 123String queryForSingle = &quot;select id,name from animal where id=?&quot;;Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(queryForSingle,125);System.out.println(map); //{id=125, name=火神} query()：获取多条数据 123//获取多条数据(query方法)String queryForMultiple = &quot;select * from animal&quot;;List&lt;Animal&gt; animals1 = jdbcTemplate.query(queryForMultiple, animalRowMapper); queryForList()：返回一个list，list中每个元素是一个Map，Map中包含的每一列就是一个条目，key为列名，value为值 1234//获取多条数据(queryForList方法)String queryForMultiple = &quot;select * from animal&quot;;List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(queryForMultiple);System.out.println(maps); //[{id=124, name=火花}, {id=125, name=火神}] update()：用于增删改 1234567891011121314151617@Testpublic void insert(){ String sql = &quot;insert into animal(name) value(?)&quot;; jdbcTemplate.update(sql,&quot;火神&quot;);}@Testpublic void delete(){ String sql = &quot;delete from animal where id=?&quot;; jdbcTemplate.update(sql,123);}@Testpublic void update(){ String sql = &quot;update animal set name=? where name=?&quot;; jdbcTemplate.update(sql,&quot;火花&quot;,&quot;火神&quot;);} execute()：执行任意sql，通常用于ddl语句 12String sql = &quot;create table test (id integer, name varchar(100))&quot;;jdbcTemplate.execute(sql); NamedParameterJdbcTemplateNamedParameterJdbcTemplate只是在JdbcTemplate基础上添加了参数解析的支持，可以使用命名参数替换?占位符。具体方法介绍查看上一小节的JdbcTemplate，这里只介绍他们的区别，也就是参数部填充分 对于sql字符串中的参数，可以使用:name的形式定义参数； 可以使用SqlParameterSource的实现对参数进行填充，它的实现有 MapSqlParameterSource：和Map类似通过K/V方式设置参数 BeanPropertySqlParameterSource：直接传递一个自定义类对象，会根据器属性进行参数设置 可以使用Map进行属性填充 123456789101112131415161718192021222324//结果映射RowMapper&lt;Animal&gt; animalRowMapper = (resultSet, rowNum)-&gt;{ Animal a = new Animal(); a.setId(resultSet.getInt(&quot;id&quot;)); a.setName(resultSet.getString(&quot;name&quot;)); return a;};String sql = &quot;select * from animal where id=:id and name=:name&quot;;//参数填充(方式一)MapSqlParameterSource ParameterSource1 = new MapSqlParameterSource();ParameterSource1.addValue(&quot;id&quot;,124);ParameterSource1.addValue(&quot;name&quot;,&quot;火花&quot;);//参数填充(方式二)BeanPropertySqlParameterSource parameterSource2 = new BeanPropertySqlParameterSource(new Animal(10, &quot;水蓝蓝&quot;));//参数填充(方式三)Map&lt;String, Object&gt; parameterSource3 = new HashMap&lt;&gt;();parameterSource3.put(&quot;id&quot;,124);parameterSource3.put(&quot;name&quot;,&quot;火花&quot;);List&lt;Animal&gt; animalList = nPJdbcTemplate.query(sql, parameterSource2, animalRowMapper); SQLExceptionTranslatorSQLExceptionTranslator是一个异常转换接口 12345@FunctionalInterfacepublic interface SQLExceptionTranslator { @Nullable DataAccessException translate(String task, @Nullable String sql, SQLException ex);} 它负责的是将SQLExceptions与spring自己定义的DataAccessException 之间进行转换。默认实现是SQLErrorCodeSQLExceptionTranslator todo(不明白这东西有什么用) 数据库连接","link":"/2021/03/06/language/Java/Spring/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%9AJDBC/"},{"title":"Spring 数据访问：事务管理","text":"事务是为了保证业务逻辑前后数据的一致性而提供的功能，可以分为全局事务和本地事务 全局事务：全局事务跨越多个资源（比如数据库和消息队列），常见的有分布式事务 本地事务：本地事务是特定于资源的（比如JDBC连接关联的事务），在编码过程中更长被使用 底层组件TransactionManager事务策略由TransactionManager定义，它是一个空实现 12public interface TransactionManager {} 他的实现如下： PlatformTransactionManager ReactiveTransactionManager 在应用程序中应该需要根据工作环境选择正确的TransactionManager实现（JDBC、JTA、Hibernate 等），然后注册到ioc容器中，例如JDBC环境下： 1234567&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&quot;&gt; &lt;!--...--&gt;&lt;/bean&gt; PlatformTransactionManagerPlatformTransactionManager接口用于命令式事务管理 1234567891011public interface PlatformTransactionManager extends TransactionManager { //如果当前调用堆栈中存在匹配的事务， //则返回的 TransactionStatus 可能表示新事务或可以表示现有事务。 TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; //提交事务 void commit(TransactionStatus status) throws TransactionException; //回滚事务 void rollback(TransactionStatus status) throws TransactionException;} ReactiveTransactionManagerReactiveTransactionManager接口用于反应式事务管理 12345678910public interface ReactiveTransactionManager extends TransactionManager { //获取响应式事务 Mono&lt;ReactiveTransaction&gt; getReactiveTransaction(@Nullable TransactionDefinition definition) throws TransactionException; //提交事务 Mono&lt;Void&gt; commit(ReactiveTransaction transaction) throws TransactionException; //回滚事务 Mono&lt;Void&gt; rollback(ReactiveTransaction transaction) throws TransactionException;} TransactionStatus12345678910111213141516171819202122232425public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable { boolean hasSavepoint(); void flush();}//public interface TransactionExecution { boolean isNewTransaction(); void setRollbackOnly(); boolean isRollbackOnly(); boolean isCompleted();}//public interface SavepointManager { Object createSavepoint() throws TransactionException; void rollbackToSavepoint(Object savepoint) throws TransactionException; void releaseSavepoint(Object savepoint) throws TransactionException;} TransactionStatus接口提供了简单的控制事务执行和状态查询方式 TransactionDefinition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface TransactionDefinition { //传播行为 int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; //隔离级别 int ISOLATION_DEFAULT = -1; int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; int TIMEOUT_DEFAULT = -1; //获取传播行为 default int getPropagationBehavior() { return 0; } //获取事务隔离级别 default int getIsolationLevel() { return -1; } //获取超时时间：此事务在超时并被回滚之前运行了多久时间 default int getTimeout() { return -1; } //是否是只读事务 //在不修改数据，只读取数据的情况下可以使用read-only事务 default boolean isReadOnly() { return false; } //获取事务名 @Nullable default String getName() { return null; } static TransactionDefinition withDefaults() { return StaticTransactionDefinition.INSTANCE; }} 工具类spring为各种提供了工具类，他们处于较低级别 JDBC：DataSourceUtils JPA：EntityManagerFactoryUtils Hibernate：SessionFactoryUtils 在获取连接时会返回现有连接，如果没有，则会创建新连接 1Connection conn = DataSourceUtils.getConnection(dataSource); TransactionInterceptorspring支持的事务是通过aop代理实现的，它的通知是通过xml或注解进行配置元数据进行驱动。底层使用TransactionInterceptor与TransactionManager结合实现环绕方法的事务调用。 TransactionAwareDataSourceProxyTransactionAwareDataSourceProxy类是最底层的类，它是包装DataSource的代理类，增加了对spring管理事务的功能 基于xml配置事务spring的声明式事务管理是通过AOP实现的，可以通过xml文件进行配置，配置流程如下 引入依赖123456789101112&lt;!--事务依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt; xml配置必须在&lt;beans&gt;根标签添加如下配置 1234xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot; 主要使用的是&lt;tx:method&gt;标签，其属性对应TransactionDefinition的方法，具体如下： name：匹配方法名，可以使用*作为占位符，表示0个或多个字符，一个方法可以被多个&lt;tx:method&gt;标签的name属性匹配时选择。name是必须配置的； read-only：代表事务是只读的，默认是false表示使用默认事务； rollback-for：spring事务回滚的推荐方式是抛出异常，spring会在调用栈中捕获未处理的异常，然后决定是否将事务标记为回滚。默认情况下如果抛出RuntimeException异常（或发生Error）就会标记回滚，也可以通过rollback-for属性指定检测到什么异常会将事务标记为回滚。也可以使用java代码方式进行回滚，不过存在耦合官方并不推荐； 1TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); no-rollback-for：不回滚规则。指定某些异常及其子类即便抛出，事务也不会标记回滚。当no-rollback-for和rollback-for同时存在时，更具体的异常更优先。测试时发现当rollback-for为Exception时，no-rollback-for配置不生效； timeout：事务超时时间，仅适用于事务传播行为为REQUIRED或REQUIRES_NEW； isolation：事务隔离级别，默认为DEFAULT，仅适用于事务传播行为为REQUIRED或REQUIRES_NEW； propagation：事务传播行为，默认为REQUIRED 全部配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation= &quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--包扫描器--&gt; &lt;context:component-scan base-package=&quot;项目包路径&quot;/&gt; &lt;!--声明事务的通知--&gt; &lt;tx:advice id=&quot;事务通知id&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;!--配置需要添加事务的方法--&gt; &lt;tx:attributes&gt; &lt;!--使用tx:method标签配置方法的匹配名称和事务类型--&gt; &lt;tx:method name=&quot;名称匹配表达式&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;!--切入点，需要添加事务的类--&gt; &lt;aop:pointcut id=&quot;切入点id&quot; expression=&quot;切入点表达式&quot;/&gt; &lt;!--将通知加入到需要添加事务的方法上--&gt; &lt;aop:advisor advice-ref=&quot;事务通知id&quot; pointcut-ref=&quot;切入点id&quot;/&gt; &lt;/aop:config&gt; &lt;!--数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;!--事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 示例代码实体类 12345678@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Animal { private int id; private String name;} Service层事务测试代码 123456789101112131415161718192021222324252627282930313233343536373839public interface IAnimalService { public int insert(String name) throws Exception; public int delete(int id); public int update(int id,String newName); public String queryNameById(int id);}@Servicepublic class AnimalService implements IAnimalService { @Autowired public JdbcTemplate jdbcTemplate; @Override public int insert(String name) throws Exception { int res = jdbcTemplate.update(&quot;insert into animal(name) value(?)&quot;, name); //一定会抛出异常 if(name.length()&gt;=0){ throw new RuntimeException(&quot;配置不会回滚&quot;);// throw new Exception(&quot;配置会回滚&quot;); } return res; } @Override public int delete(int id) { return jdbcTemplate.update(&quot;delete from animal where id=?&quot;,id); } @Override public int update(int id, String newName) { jdbcTemplate.update(&quot;update animal set name=? where id=?&quot;,newName,id); return 0; } @Override public String queryNameById(int id) { return jdbcTemplate.queryForObject(&quot;select name from animal where id=?&quot;, String.class, id); }} 配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;context:component-scan base-package=&quot;springStudy&quot;/&gt;&lt;!--事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;!--配置事务方法--&gt; &lt;tx:attributes&gt; &lt;!--query开头方法都是制度的--&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;!--除了RuntimeException及其子类，其他异常或错误都会回滚--&gt; &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Throwable&quot; no-rollback-for=&quot;RuntimeException&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置切面--&gt;&lt;aop:config&gt; &lt;!--切入点，需要添加事务的类--&gt; &lt;aop:pointcut id=&quot;animalServicePointCut&quot; expression=&quot;execution(* springStudy.service.AnimalService.*(..))&quot;/&gt; &lt;!--将通知加入到需要添加事务的方法上--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;animalServicePointCut&quot;/&gt; &lt;!--根据需要定义多个切入点和通知...--&gt; &lt;!--在这里声明其他aop切面--&gt; &lt;aop:aspect id=&quot;...&quot; ref=&quot;...&quot;&gt; &lt;aop:pointcut id=&quot;...&quot; expression=&quot;...&quot;/&gt; &lt;aop:around method=&quot;...&quot; pointcut-ref=&quot;...&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!--数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!--事务管理器--&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--jdbc模板--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; 基于注解配置事务引入依赖123456789101112&lt;!--事务依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt; 开启注解支持xml形式 12&lt;!--如果TransactionManager名称为transactionManager，可以省略transaction-manage属性--&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; 注解形式 123@Configuration@EnableTransactionManagementpublic class AppConfig {} @Transactional 使用使用范围spring官方建议用于注释类或类方法，但也可以用于注释接口和接口方法，如果采用了多种方式配置事务，派生类层次越多优先级越高，同一类中方法级别优先于类级别。想要使用接口或接口方法必须将proxyTargetClass设置为false或默认： 接口：表示为接口实现类声明默认事务。基于接口的事务代理方法必须始终是在接口中定义的public方法 接口方法： 类：表示为类及其子类的所有方法都声明事务； 类方法：声明方法使用事务。应该用于public方法上，否则会失效。可以通过注册自定义的transactionAttributeSource的方式使包可见（default）方法具有事务，代码如下： 1234@BeanTransactionAttributeSource transactionAttributeSource() { return new AnnotationTransactionAttributeSource(false);} 注解属性@Transactional属性如下： mode：其值内容如下： proxy（默认）：代表使用spring的aop处理被注解的bean，； AspectJ：将受影响的类与spring的AspectJ事务切面编织在一起，修改目标字节码以应用于任何类型的方法调用。需要用到spring-aspects.jar； proxyTargetClass：表示注释的类创建什么类型的事务代理，其值内容如下： true：创建基于类的代理； false（默认）：创建基于标准JDK接口的代理； order：定义事务应用于注释了@Transactional的bean的通知的顺序。不指定默认由aop子系统指定通知的顺序； timeout：事务超时时间，默认-1； readOnly：声明只读事务，默认false； rollbackFor：触发回滚异常，默认RuntimeException； rollbackForClassName：传递字符串，功能同上； noRollbackFor：声明不回滚异常； noRollbackForClassName：传递字符串，功能同上； isolation：事务隔离级别，默认为Isolation.ISOLATION_DEFAULT； propagation：事务传播行为，默认为Propagation.PROPAGATION_REQUIRED； value：声明多个事务管理器时可通过value值设置beanName； 事务名称当前还无法自定义事务的名称（事务监听器和日志输出的事务名称），对于声明式事务，事务名称为全类名.声明事务方法名 组合注释如果在很多地方的@Transactional配置一样，自己也不想每次都要写一遍，那么就可以自定义一个注解，将@Transactional封装一下 12345@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Transactional(transactionManager = &quot;txManager&quot;,readOnly = true,rollbackFor = Throwable.class)public @interface MyTransactional {} 示例代码实体类 12345678@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Animal { private int id; private String name;} Service层事务测试代码 12345678910111213141516171819202122232425public interface IAnimalService { public int insert(String name) throws Exception;}@Service//为类内所有方法声明默认事务@Transactionalpublic class AnimalService implements IAnimalService { @Autowired public JdbcTemplate jdbcTemplate; @Override public int insert(String name) throws Exception { int res = jdbcTemplate.update(&quot;insert into animal(name) value(?)&quot;, name); //一定会抛出异常 if(name.length()&gt;=0){ //默认会回滚 throw new RuntimeException(&quot;1&quot;); //默认不会回滚 throw new Exception(&quot;aaa&quot;); } return res; }} 事务传播行为一般来说事务范围内的所有代码都在该事务中运行，事务传播行为表示在事务上下文已存在运行时事务的情况下在开启事务时的行为。一共七种，如下表： 事务传播行为 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。","link":"/2021/03/20/language/Java/Spring/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%9A%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"title":"Spring 核心功能：Spring 表达式语言（SpEL）","text":"SpEL是Spring 表达式语言的缩写，但它不直接与 Spring 绑定，可以独立使用 相关组件表达式解析器spring提供了pelExpressionParser类作为表达式解析器，用来解析SpEL表达式，解析SpEL使用以下方法 parseExpression(String expressionString) parseExpression(String expressionString, ParserContext context) 12ExpressionParser parser = new SpelExpressionParser();Expression exp = parser.parseExpression(&quot;'Hello'.concat('!')&quot;); ParserContext上面解析方法参数中ParserContext是提供给表达式分析器的输入 123456789101112131415161718192021222324public interface ParserContext { // 是否是模版表达式 boolean isTemplate(); // 模版的前缀、后缀 String getExpressionPrefix(); String getExpressionSuffix(); // 表达式模板形式，默认为#{},自己可以改变 ParserContext TEMPLATE_EXPRESSION = new ParserContext() { @Override public boolean isTemplate() { return true; } @Override public String getExpressionPrefix() { return &quot;#{&quot;; } @Override public String getExpressionSuffix() { return &quot;}&quot;; } };} TemplateParserContext 是其默认实现 1234567891011121314151617181920public class TemplateParserContext implements ParserContext { private final String expressionPrefix; private final String expressionSuffix; // 默认就是它了~~~ public TemplateParserContext() { this(&quot;#{&quot;, &quot;}&quot;); } @Override public final boolean isTemplate() { return true; } @Override public final String getExpressionPrefix() { return this.expressionPrefix; } @Override public final String getExpressionSuffix() { return this.expressionSuffix; }} 解析器解析器的继承结果如下 ![image-20220119164942892](../../../../images/Spring核心功能：Spring 表达式语言（SpEL）/image-20220119164942892.png) TemplateAwareExpressionParser是一个支持解析模版Template（1.1.1 中的TemplateParserContext）的解析器，它的子类实现有： InternalSpelExpressionParser： SpelExpressionParser： 他们都有各自的doParseExpression()方法实现 表达式对象使用parser.parseExpression()方法解析表达式后会返回一个Expression类型对象，它是一个接口，有三个实现类，其中SpEL表达式类为SpelExpression。它提供方法如下 getValue()： setValue()： isWritable()： getValueType()： 表达式上下文对象EvaluationContext接口代表戒子表达式是使用的上下文对象。在解析解析属性、方法或字段并帮助执行类型转换时使用该接口。Spring 提供了两种实现 SimpleEvaluationContext：公开仅支持部分的SpEL的支持。它有意限制的表达式类别。旨在仅支持SpEL语言语法的一个子集，它不包括 Java类型引用，构造函数和bean引用等等。它还要求明确选择对表达式中属性和方法的支持级别。 StandardEvaluationContext：公开支持全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。 1234567891011121314151617181920//解析器SpelExpressionParser parser = new SpelExpressionParser();//表达式上下文StandardEvaluationContext context = new StandardEvaluationContext();//向上下文中添加变量context.setVariable(&quot;key&quot;,&quot;value&quot;);//从上下文中获取变量Object value = parser.parseExpression(&quot;#key&quot;).getValue(context);System.out.println(value); //valuePerson person = new Person();person.setName(&quot;张三&quot;);//表达式上下文StandardEvaluationContext context2 = new StandardEvaluationContext();//将person设置为rootcontext2.setRootObject(person);//root不需要#就能取出属性Object name = parser.parseExpression(&quot;name&quot;).getValue(context2);System.out.println(name); //张三 作用位置xml配置可以通过SpEL设置bean的属性或构造函数的Value值 123&lt;bean id=&quot;user&quot; class=&quot;cn.spy.spel.method.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&quot;ZhangSan&quot;.toLowerCase()}&quot;/&gt;&lt;/bean&gt; 注解配置可以在@Value注解中使用SpEL 1234public class Person { @Value(&quot;#{(test.name).toLowerCase()}&quot;) private String name;} SpEL用法获取解析器与表达式上下文，接下来代码省略这部分。 1234//解析器SpelExpressionParser parser = new SpelExpressionParser();//表达式上下文StandardEvaluationContext context = new StandardEvaluationContext(); 另外省略对结果的强制转换 123Object name = (String)parser.parseExpression(&quot;#list[0]&quot;).getValue(context);//写为parser.parseExpression(&quot;[0]&quot;).getValue(context); 文本表达可以直接在声明数值、boolean、字符串和null，字符串需要放在单引号中，数字支持使用负号，指数表示，小数点和多种进制的方式表示 12int v = (Integer) parser.parseExpression(&quot;0x7FFFFFFF&quot;).getValue();int v = (String) parser.parseExpression(&quot;'0x7FFFFFFF'&quot;).getValue(); 变量和函数变量引用变量可以通过#引用表达式上下文中的变量，对于root对象属性不需要写#，具体示例查看属性和方法 #this 和 #root 变量#this变量引用当前的评估对象 1234int[] arr = {1,3,5,7,9};context.setVariable(&quot;arr&quot;,arr);//下面表达式得到的是[7,9]parser.parseExpression(&quot;#arr.?[#this&gt;5]&quot;).getValue(context); #root变量引用根上下文对象，如果没有设置root上下文对象，则为null； 123context.setRootObject(person);//得到的是person对象Object name = parser.parseExpression(&quot;#root&quot;).getValue(context); 函数可以在表达式上下文对象中注册自定义的函数来扩展SpEl，使用时通过#方法名调用即可 123Method method = ...;EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();context.setVariable(&quot;myFunction&quot;, method); 属性和方法如果在root下获取属性或方法直接调用属性或方法名即可，不需要加#，如果获取表达式上下文中变量的属性需要使用#和. 1234567891011121314151617//创建对象，设置属性Person person = new Person();person.setName(&quot;张三&quot;);//设置上下文变量context.setVariable(&quot;person&quot;,person);//获取变量属性parser.parseExpression(&quot;#person.name&quot;).getValue(context);//调用变量方法parser.parseExpression(&quot;#person.name&quot;).getValue(context);//设置root对象context.setRootObject(person);//获取root对象属性parser.parseExpression(&quot;name&quot;).getValue(context);//调用root对象方法parser.parseExpression(&quot;toString()&quot;).getValue(context2); 集合和Map数组数组访问12345678910111213141516//创建数组String[] arr = new String[]{&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;};//设置数组变量到表达式上下文context.setVariable(&quot;arr&quot;,arr);//使用[]获取元素parser.parseExpression(&quot;#arr[0]&quot;).getValue(context);//使用方法Object value = parser.parseExpression(&quot;#arr.toString()&quot;).getValue(context);//数组设置为root对象context.setRootObject(arr);//索引元素parser.parseExpression(&quot;[0]&quot;).getValue(context);//调用方法parser.parseExpression(&quot;toString()&quot;).getValue(context); 数组构造1234567int[] arr1 = (int[]) parser.parseExpression(&quot;new int[4]&quot;).getValue(context);//声明并初始化int[] arr2 = (int[]) parser.parseExpression(&quot;new int[]{1,2,3}&quot;).getValue(context);//多维数组int[][] arr3 = (int[][]) parser.parseExpression(&quot;new int[4][5]&quot;).getValue(context); 列表列表访问列表在表达式追踪可以通过[]访问 1234567891011121314151617//声明列表LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();list.add(&quot;ddd&quot;);list.add(&quot;eee&quot;);list.add(&quot;fff&quot;);//设置list变量context.setVariable(&quot;list&quot;,list);//可以通过[]获取值，也可以通过[]获取值在表达式中使用其各种方法parser.parseExpression(&quot;#list.get(1)&quot;).getValue(context);parser.parseExpression(&quot;#list[0]&quot;).getValue(context);//设置为root对象context.setRootObject(list);//访问时和访问变量类似，只不过去掉变量名即可parser.parseExpression(&quot;get(1)&quot;).getValue(context)parser.parseExpression(&quot;[0]&quot;).getValue(context) 内联列表可以在表达式在直接使用{}声明列表 123List numbers = (List) parser.parseExpression(&quot;{1,2,3,4}&quot;).getValue(context);List listOfLists = (List) parser.parseExpression(&quot;{{'a','b'},{'x',1}}&quot;).getValue(context); MapMap索引在表达式中可以通过[key]的方式获取value，其中key的单引号是可选的。另外还可以调用map的方法，此处不演示 1234567891011121314//创建mapHashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;name&quot;,&quot;魔力猫&quot;);map.put(&quot;age&quot;,3);//设置map为表达式上下文变量context.setVariable(&quot;map&quot;,map);//访问key为name的值Object value = parser.parseExpression(&quot;#map[name]&quot;).getValue(context);//设置为root对象context.setRootObject(map);//访问key为name的值parser.parseExpression(&quot;[0]&quot;).getValue(context); 内联Map在表达式中可以直接使用{key:value}表示一个Map,其中key的单引号是可选的 1Map map = (Map) parser.parseExpression(&quot;{name:'魔力猫',age:3}&quot;).getValue(context); 集合选择使用.?[selectionExpression]语法可以对集合进行过滤，返回包含原始元素子集的新集合，评估Map时可以访问Key和Value属性 1Map newMap = parser.parseExpression(&quot;map.?[value&lt;27]&quot;).getValue(); 只获取与选择匹配的第一个元素，语法为：.^[selectionExpression] 只获得最后一个匹配的选择，语法是 .$[selectionExpression] 集合投影使用.![projectionExpression]语法可以对集合进行投影操作，返回一个新集合 1List names = (List)parser.parseExpression(&quot;persons.![name]&quot;); 运算符SpEL内允许使用以下类型运算符： 关系运算符： 标准关系运算符：&gt;(gt)、&gt;=(ge)、==(eq)、!=(ne)、&lt;=(le)、&lt;(lt)； 额外支持：instanceof； 正则表达式运算符：matches； 逻辑运算符：&amp;&amp;(and)、||(or)、!(not)； 数学运算符：+、-、*、/(div)、%(mod)、^； 赋值运算符：=； 三元运算符：布尔表达式?Exp1:Exp2； 1name != null ? name : &quot;张三&quot; Elvis运算符：变量?:exp。变量为空则将:后的值赋给该变量； 1name?:'张三' 空安全运算符：使用?声明变量，执行变量时不会抛出异常，而是返回null 1isNull?.toString() 类型使用T来指定java.lang.Class类型实例 1Class stringClass = parser.parseExpression(&quot;T(String)&quot;).getValue(Class.class); 创建对象可以使用new关键字调用构造函数，除了位于java.lang包中的类型之外，都需要使用类型的全类名 1Person person = (Person) parser.parseExpression(&quot;new test.anno.Person()&quot;).getValue(context); Bean引用如果表达式上下文配置了bean解析器 123ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.setBeanResolver(new MyBeanResolver()); 可以使用@符号从表达式中查找bean 1Object bean = parser.parseExpression(&quot;@beanName&quot;).getValue(context); 如果想要访问beanFactory本身，可以在bean名称前加上一个&amp;符号 1Object bean = parser.parseExpression(&quot;&amp;beanName&quot;).getValue(context); 表达式模板表达式模板允许将文本与多个评估块混合，使用#{}分隔 1234String randomPhrase = parser.parseExpression( &quot;随机数为#{T(java.lang.Math).random()}&quot;, new TemplateParserContext()).getValue(String.class); 关于TemplateParserContext()请查看解析器","link":"/2020/03/28/language/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9ASpring%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%EF%BC%88SpEL%EF%BC%89/"},{"title":"Spring 核心功能：控制反转（IOC）","text":"控制反转（IOC）也被称为依赖注入（DI）。这是一个由对象通过构造函数的参数、工厂方法的参数或者配置来定义依赖性，然后会在创建 bean 时注入这些依赖项的过程。而原本的 bean 如果想要获取依赖项，需要通过构造函数或者单例模式、构造器模式等方式获取依赖项的实例，所以可以发现Spring的依赖注入其实是原本bean 获取以来的逆过程，所以得名：控制反转。 BeanDefinition在Spring中，构成应用程序主干并由Spring IOC管理的对象称为bean，它由IOC容器实例化、组装和管理。可以通过配置元数据对bean之间的依赖关系进行配置。bean以beanDefinition形式存在于IOC容器中。 BeanDefinition 是一个接口，包含了很多配置信息 bean 的实际限定类名 bean 行为配置元素，说明 bean 在容器中的行为方式（范围、声明周期回调等） 对其他依赖的 bean 的引用 在新创建的对象中设置的其他配置设置——例如，池的大小限制或在管理连接池的 bean 中使用的连接数 bean 属性AbstractBeanDefinition是beanDefinition的子类，其中定义了一组属性： scope：bean的作用范围 lazyInit：是否延迟加载，对应bean的lazy-init autowireMode：自动注入模式 AUTOWIRE_NO = 0; AUTOWIRE_BY_NAME = 1; AUTOWIRE_BY_TYPE = 2; AUTOWIRE_CONSTRUCTOR = 3; dependencyCheck：依赖检查 dependsOn：依赖项数组，对应bean属性depend-on autowireCandidate：装配该bean时是否对把其他bean注入进来 primary：有多个备案候选项时作为首选者，对应bean属性primary lenientConstructorResolution：是否一个宽松的模式解析构造函数 nonPublicAccessAllowed：允许访问非公开的构造器和方法，程序设置 qualifiers：用于记录Qualifier，对应子元素qualifier constructorArgumentValues：构造函数注入属性，对应bean属性constructor-arg propertyValues：普通属性集合 factoryBeanName：对应bean属性factory-bean factoryMethodName：对应bean属性factory-method initMethodName：对应bean属性init-method destroyMethodName：对应bean属性destroy-method synthetic：创建AOP或不是用户定义时为true role：bean的角色 ROLE_APPLICATION = 0 :用户 ROLE_SUPPORT = 1：某些复杂配置一部分 ROLE_INFRASTRUCTURE = 2：完全内部使用，与用户无 description：bean描述 resource：bean定义的资源 bean 实例化BeanDefinition本质上时创建一个或多个对象的方法。在bean被访问时，容器会查看该bean，如果当前容器中没有，则会使用BeanDefinition创建对应的bean对象并加入到容器中 嵌套类名如果在OutClass在com.example包中，并且OutClass类中有一个静态内部类 InnerClass，则他们之间可以使用美元符号（$）或点（.）分隔，比如 com.example.SomeThing$InnerClass或com.example.SomeThing.InnerClass。 构造函数实例化点击查看示例 静态工厂方法实例化定义使用静态工厂方法创建的 bean 时，使用class 属性指定包含static工厂方法的类和命名属性以factory-method指定工厂方法本身的名称 12345&lt;bean id=&quot;clientService&quot; &lt;!--工厂类 --&gt; class=&quot;examples.ClientService&quot; &lt;!--工厂类中创建bean的静态方法 --&gt; factory-method=&quot;createInstance&quot;/&gt; 实例工厂方法初始化实力工厂方法从容器中调用现有的bean的非静态方法创建bean。使用此方式需要将**class属性留空**，使用factory-bean属性中指定当前（或父或祖先）容器中 bean 的名称，使用factory-method属性设置工厂方法本身的名称 123456789&lt;!-- 工厂的bean，其中包含createInstance()方法 --&gt;&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- 通过上面的工厂bean创建bean --&gt;&lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt; BeanDefinition继承BeanDefinition包含很多配置信息，包括构造其参数，属性值、初始化方法等。BeanDefinition之间可以存在继承关系，一个子BeanDefinition能够根据需要覆盖或增加一些值。使用BeanDefinition继承可以节省定义bean的工作量，相当于一种模板。可以通过parent属性来指定父子关系： 1234567891011@Datapublic class ParentBean { private String name; private Integer age;}@Datapublic class ChildBean { private String name; private Integer age;} xml配置如下 123456789&lt;bean name=&quot;parentBean&quot; class=&quot;test.pojo.ParentBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;6&quot;/&gt;&lt;/bean&gt;&lt;bean name=&quot;childBean&quot; class=&quot;test.pojo.ChildBean&quot; parent=&quot;parentBean&quot;&gt; &lt;!--覆盖父beanDefinition属性--&gt; &lt;property name=&quot;age&quot; value=&quot;1000&quot;/&gt;&lt;/bean&gt; 其中还可以继承或覆盖构造函数参数、属性、方法、初始化/销毁方法、静态工厂设置等信息，但也有一些配置始终是子类配置： depends on autowire mode dependency check singleton lazy init 父BeanDefinition也可以不指定类，只需要将abstract属性设置为true 1234&lt;bean name=&quot;parentBean&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;6&quot;/&gt;&lt;/bean&gt; 此时父bean不能实例化也不能用于ref，只能当作模板来使用 BeanFactory 接口beanFactory 接口提供了spring ioc基本功能的规范，也是访问ioc容器的根接口 ApplicationContext 接口ApplicationContext是beanFactory 的一个扩展，它在其基础上添加了更多企业特定的功能，是beanFactory的超集。它补充了如下内容： 更容易与Spring AOP集成 消息资源处理（用于国际化） 活动发布 应用特定上下文，注解、配置文件等 ApplicationContext 接口代表IOC容器。通过读取配置元数据执行bean的实例化、组装和管理。ApplicationContext提供了几种实现，类图如下： 容器实例化ApplicationContext的不同实现类用于读取不同的配置元数据： 读取xml文件 FileSystemXmlApplicationContext ClassPathXmlApplicationContext GenericXmlApplicationContext 读取Groovy配置 GenericGroovyApplicationContext StaticApplicationContext 基于Java配置类 AnnotationConfigApplicationContext 结合读者委托 GenericApplicationContext 基于xml 配置12345public static void main(String[] args) { //提供给 ApplicationContext 构造函数的一个或多个字符串形式的位置路径 ClassPathXmlApplicationContext application = new ClassPathXmlApplicationContext(&quot;service.xml&quot;, &quot;daos.xml&quot;);} 基于Groovy 配置一般用法 123public static void main(String[] args) { ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);} 使用读者委托 123456789public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); new GroovyBeanDefinitionReader(context) .loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;); context.refresh();} 基于Java 注解配置方式一：通过指定配置类或组件类，读取其上声明的组件扫描器，进而读取包内的bean 1234567891011//启动器代码public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfig.class); Person person = ctx.getBean(&quot;person&quot;, Person.class); System.out.println(person);}//组件扫描@ComponentScan(&quot;test&quot;)public class MyConfig {} 方式二：通过register方法进行注入 1234567public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.register(AppConfig.class, OtherConfig.class); ctx.register(AdditionalConfig.class); ctx.refresh(); MyService myService = ctx.getBean(MyService.class);} AnnotationConfigApplicationContext是spring 3.0引入的。种通用ApplicationContext的实现不仅能够接受 @Configuration类作为输入，还能够接受普通@Component类和使用 JSR-330 元数据注释的类 当@Configuration类作为输入提供时，@Configuration类本身被注册为 beanDefinition，并且@Bean类中所有声明的方法也被注册为beanDefinition； 当@Component提供 JSR-330 类时，它们被注册为beanDefinition，并且根据提供的@Autowired或@Inject进行依赖注入； 基于Reader委托不同Reader负责读取不同来源的信息： AnnotatedBeanDefinitionReader XmlBeanDefinitionReader GroovyBeanDefinitionReader PropertiesBeanDefinitionReader（已过时） GenericApplicationContext可以结合不同Reader来读取对应的配置文件 123456789public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); //用对应的Reader包装上下文对象 new XmlBeanDefinitionReader(context) //加载对应bean配置 .loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;); //最后需要刷新上下文 context.refresh();} 附加功能开头介绍了位于org.springframework.context包内的 ApplicationContext 类提供了几个附加功能，下面逐个介绍 国际化ApplicationContext扩展了一个MessageSource接口，这个接口提供了国际化功能。该接口介绍如下： 123456789101112public interface MessageSource { //用于从MessageSource找到指定语言环境的消息，如果未找到，使用默认消息 @Nullable String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale); //与上一个方法基本相同，只不过这个不能指定默认消息，找不到消息直接报错 String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException; //上述方法中使用的所有属性都包装在一个名为MessageSourceResolvable中 String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;} spring在加载ApplicationContext时会自动搜索类型和名称为MessageSource的bean，如果找到了，就将所有信息的调用委托给这个信息源。如果没有找到，则从父容器查找同名bean，如果还没找到，则实例化一个空的DelegatingMessageSource用来接受上述的方法调用。 spring提供了三个MessageSource的实现：ResourceBundleMessageSource、ReloadableResourceBundleMessageSource和StaticMessageSource，他们都实现了 HierarchicalMessageSource接口，用来嵌套消息。其中StaticMessageSource很少使用，示例如下 ResourceBundleMessageSource： 1234567891011&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;format&lt;/value&gt; &lt;value&gt;exception&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--设置字符集，解决中文乱码--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;&lt;/bean&gt; 上面示例配置了两个资源文件 12345#format.properties name=马冬梅#exceptions.propertiename=马什么梅 获取消息 12345public static void main(String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(&quot;test.xml&quot;); String message = resources.getMessage(&quot;name&quot;, null, &quot;Default&quot;, Locale.CHINA); System.out.println(message);} 如果正常情况会输出”马冬梅”。程序会顺序查找定义的basenames列表中配置的配置文件。对于每个配置文件都可以设置不同的语言环境，只需要在properties文件名后加上语言环境。拿上面的例子举例 123456#format.properties 下面两个不匹配会选这个，作为备胎name=xxx#format_en_GB.propertiesname=madongmei#format_zh_CN.propertiesname=马冬梅 只需要更改第四个参数就可以读取不同配置文件了，不了解添加什么后缀可以看Locale类 1resources.getMessage(&quot;name&quot;, null, &quot;Default&quot;, Locale.CHINA); 标准和自定义事件spring中时间是通过ApplicationEvent和ApplicationListener接口提供的。如果自定义~实现ApplicationListener接口，每次ApplicationEvent发布到ApplicationContext，都会通知该bean 标准事件spring内置事件 事件 解释 ContextRefreshedEvent 上下文初始化或刷新时发布。初始化表示所有bean都已加载，后置处理器执行，单例被实例化并且上下文对象已准备好使用。刷新戴白哦热刷新或直接调用refresh()方法手动刷新 ContextStartedEvent 上下文已启动时发布 ContextStoppedEvent 上下文停止时发布 ContextClosedEvent 上下文关闭时发布 RequestHandledEvent 一个http请求已获得服务，请求完成后发布，只适用于web的DispatcherServlet ServletRequestHandledEvent RequestHandledEvent的父类 基于代码自定义事件自定义事件，首先创建类集成ApplicationEvent 类并声明初始化方法 123456//自定义事件public class MyCustomEvent extends ApplicationEvent { public MyCustomEvent(Object source) { super(source); }} 然后定义事件发布者 123456789101112131415public class MyCustomPublisher implements ApplicationEventPublisherAware { private ApplicationEventPublisher publisher; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) { this.publisher = applicationEventPublisher; } //发布自定义事件 public void publish(){ //该方法是阻塞式的 publisher.publishEvent(new MyCustomEvent(this)); }} 定义事件监听 12345678public class MyCustomListener implements ApplicationListener&lt;MyCustomEvent&gt; { //收到事件后，触发该方法 @Override public void onApplicationEvent(MyCustomEvent event) { //业务逻辑... }} 上面定义的三个类都需要注册到容器中，没啥营养这里不再列出。spring运行时会检测到MyCustomPublisher并自动调用setApplicationEventPublisher方法传入spring容器本身。通过其ApplicationEventPublisher接口的publishEvent方法发布事件，然后阻塞，之到接收者接收到事件进行处理。 基于注释的事件监听器还是根据上面例子，改为基于注解的方式的监听器 12345678public class MyCustomListener{ //收到事件后，触发该方法 @EventListener public void onApplicationEvent(MyCustomEvent event) { //业务逻辑... }} 如果要监听多个事件 1234@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})public void handleContextStart() { // ...} 可以添加监听事件的条件 1234@EventListener(condition = &quot;#blEvent.content == 'my-event'&quot;)public void onApplicationEvent(MyCustomEvent event) { //业务逻辑...} 时间的SpEL表达式可以使用如下数据 名称 描述 举例 Event ApplicationEvent #root.event 或者 event 参数数组 访问参数数组 #root.args[i] 或 args[i] 参数名称 任何方法参数和名称 #blEvent o或#a0 异步监听器使用@Async开启异步监听 12345@EventListener@Asyncpublic void onApplicationEvent(MyCustomEvent event) { //业务逻辑...} 异步监听不能通过返回值来发布后续事件。如果发生异常也不会传播给调用者 监听顺序使用@Order注解可以设置监听器监听顺序（越小优先级越高） 12345@EventListener@Order(42)public void onApplicationEvent(MyCustomEvent event) { //业务逻辑...} 通用事件监听可以通过泛型进一步定义事件结构 1234@EventListenerpublic void onPersonCreated(MyCustomEvent&lt;Animal&gt; event) { // ...} 访问底层资源点击跳转 应用程序启动追踪todo 常用方法ApplicationContext是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过getBean方法 getType(...)：调用指定的bean名称，确定bean运行时类型 getBean(...)：获取bean实例 12345//创建和配置beansApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);//获取beanPetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class); 元数据详细配置配置元数据表示在应用程序中Spring应该如何实例化、配置和组装bean。一般使用xml格式提供，但也可以使用其他形式 xml 配置 XML 的配置元数据基本格式如下 1234567&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;misterkaoli&quot;/&gt;&lt;/bean&gt; Spring也支持嵌套属性标签，在解析时会将内部元素&lt;value/&gt;的文本转换为的对应属性 1234567891011&lt;bean id=&quot;mappings&quot; class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt; &lt;!-- 类型为 java.util.Properties --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; jdbc.driver.className=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; p-namespace允许使用bean标签的属性代替&lt;property/&gt;子标签，如下所示 123456789101112&lt;bean name=&quot;exampleBean&quot; class=&quot;com.example.ExampleBean&quot;&gt; &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt; &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;&lt;/bean&gt;&lt;!--等价于--&gt;&lt;bean name=&quot;exampleBean&quot; class=&quot;com.example.ExampleBean&quot; p:email=&quot;someone@somewhere.com&quot; p:spouse-ref=&quot;jane&quot;/&gt;&lt;!--等价于--&gt; &lt;c-namespace&gt;允许使用bean标签属性代替&lt;constructor-arg&gt;子标签，如下所示 1234567891011&lt;!-- traditional declaration with optional argument names --&gt;&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt; &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt; &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt; &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;&lt;/bean&gt;&lt;!--等价于--&gt;&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot; c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt; 复合属性名称 当一个bean中由属性A，A包含属性B，B又包含属性C，此时我想要给C赋值，就可以使用符合属性名称 123&lt;bean id=&quot;test&quot; class=&quot;test.TestBean&quot;&gt; &lt;property name=&quot;A.B.C&quot; value=&quot;123&quot; /&gt;&lt;/bean&gt; &lt;bean&gt;&lt;bean&gt;标签内容如下： **id**：指定一个字符串，表示bean的标识符，由字母、数字和特殊字符组成，只能指定一个； **name**：能指定多个标识符，不同标识符用逗号、分号或空格分隔； **class**：使用完全限定的类名定义bean的类型； **scope**：bean的作用域，[详细说明](#bean 作用域) **destroy-method**：指定销毁回调方法，详细说明 **init-method**：指定初始化回调方法，详细说明 **parent**：指定BeanDefinition的父子关系，详细说明 **abstract**：指定BeanDefinition是否是纯模板，详细说明 **&lt;lookup-method&gt;**：通过方法注入bean，详细说明 **&lt;replaced-method&gt;**：替换目标bean的方法，详细说明 **depends-on**：显式指定一个或多个单例的bean在初始化/销毁当前bean之前进行初始化/销毁，多个bean使用逗号、空格和分包分隔； **lazy-init**：bean懒加载，在第一次使用到时才加载； **autowire**：为bean定义指定自动装配模式，&lt;property&gt;和&lt;constructor-arg/&gt;的依赖项会覆盖自动装配，不能装配简单属性 no：没有自动装配（默认） byName：按属性名称自动装配，若未找到，则不设置属性值 byType：按属性类型自动装配，若未找到，则不设置属性值 constructor：类似与byType，但是指定的是构造函数参数，若未找到，则报错 **autowire-candidate**：设置为false，则按类型的自动装配不可用（包括@Autowired注解），不会影响按名称的引用； **default-autowire-candidates**：通过表达式限制bean的名称，多个表达式以逗号分隔。例如*Repository指定依赖的bean必须以Repository结尾； **&lt;property&gt;**：定义bean的属性 **name**：JavaBean属性的名称 **value**：属性的值，spring会自动将值转换为实际类型 **&lt;value&gt;**：作用同value，一般值比较复杂时使用 **ref**：所引用Bean的定义名称 **&lt;ref&gt;**：功能同ref **bean**：目标bean名称 **parent**：通过该属性指定目标bean是对当前容器父容器中的bean的引用 **idref**：一个防错方式，功能类似value属性，但他会在会在容器部署时查看指定id的bean是否存在，而不是在实例化时； **&lt;bean&gt;**：内部bean定义不需要指定id或name，创建时会忽略id、name和scope。这是个匿名bean，外部的其他bean不能访问 **&lt;list&gt;**：List类型，详细说明 **&lt;set&gt;**：set类型，详细说明 **&lt;map&gt;**：map类型，详细说明 **&lt;props&gt;**：props类型，详细说明 **&lt;null/&gt;**：表示null值 **&lt;constructor-arg/&gt;**：构造函数实例化bean时的的参数 name：JavaBean中构造函数的参数名 **value**：参数的值，spring会自动将值转换为实际类型 **type**：参数类型 **index**：参数索引，从0开始 **ref**：所引用Bean的定义名称 **&lt;qualifier&gt;**：[详细说明](#@Qualifier 对应的 xml 配置) 集合属性可以使用&lt;list/&gt;，&lt;set/&gt;，&lt;map/&gt;，和&lt;props/&gt;标签表示Collection类型List，Set，Map，和Properties详细配置如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;property name=&quot;myProperties&quot;&gt; &lt;props&gt; &lt;!--Properties单个值的定义--&gt; &lt;prop key=&quot;p1&quot;&gt;p1&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;p2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;!--list单个值的定义--&gt; &lt;value&gt;l1&lt;/value&gt; &lt;!--引用外部bean--&gt; &lt;ref bean=&quot;refBean&quot;/&gt; &lt;!--list和set还可以定义其他任意集合元素--&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;!--map单个值的定义--&gt; &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;/&gt; &lt;!--key和value都可以引用外部bean--&gt; &lt;entry key-ref=&quot;refBean&quot; value-ref=&quot;refBean&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;set&gt; &lt;!--set单个值的定义--&gt; &lt;value&gt;s1&lt;/value&gt; &lt;!--引用外部bean--&gt; &lt;ref bean=&quot;refBean&quot;/&gt; &lt;!--set和list还可以定义其他任意集合元素--&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean name=&quot;refBean&quot; class=&quot;test.pojo.RefBean&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 上面引用的java类如下： 12345678910111213141516@Data@NoArgsConstructor@ToStringpublic class TestBean { private List myList; private Set mySet; private Map myMap; private Properties myProperties;}@Data@NoArgsConstructor@AllArgsConstructorpublic class RefBean { private String name;} 集合合并Spring容器还支持集合合并，可以定义父&lt;list/&gt;，&lt;map/&gt;，&lt;set/&gt;或&lt;props/&gt;元素，然后定义其子元素，这样最终子元素的值就是子集合和父集合的并集，如果有相同的元素，子集合会覆盖父集合的值，配置如下 12345678910111213141516171819&lt;bean name=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;test.pojo.CollectionMerge&quot;&gt; &lt;property name=&quot;myProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;p1&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;p2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--指明parent，不需要指明class--&gt;&lt;bean name=&quot;child&quot; parent=&quot;parent&quot;&gt; &lt;property name=&quot;myProperties&quot;&gt; &lt;!--子集合指定merge=&quot;true&quot;开启集合合并--&gt; &lt;props merge=&quot;true&quot;&gt; &lt;prop key=&quot;p2&quot;&gt;p22&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;p33&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 对应的bean类如下 12345@Data@NoArgsConstructorpublic class CollectionMerge { private Properties myProperties;} 最终子集合的结果为 1CollectionMerge(myProperties={p3=p33, p2=p22, p1=p1}) 补充： 如果不指定id和name，容器会为该bean生成一个唯一名称。但如果想根据名称引用bean，则需要指定名称； 对于指定泛型的集合Spring会自动进行转换； &lt;import&gt;&lt;import&gt;标签内容如下： resource：其他xml文件位置。默认位置路径是相对于当前xml文件的，也可以使用绝对路径。不建议使用 ../ 和 classpath:URL，因为这样会创建当前应用程序之外的文件的依赖关系 &lt;alias&gt;&lt;alias&gt;标签内容如下： name：bean名字 alias：别名 1&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt; &lt;beans&gt;&lt;beans&gt;标签内容如下： **default-init-method**：默认初始化回调，详细介绍 **default-destroy-method**：默认销毁回调，详细介绍 **profile**：项目配置环境 &lt;beans&gt;标签可以内嵌&lt;beans&gt;标签 profile 示例12345678910111213141516171819&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xsi:schemaLocation=&quot;...&quot;&gt; &lt;!-- 不同环境使用不同的bean配置，也可以把beans拆分为多个xml文件 --&gt; &lt;beans profile=&quot;development&quot;&gt; &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=&quot;production&quot;&gt; &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt; &lt;/beans&gt;&lt;/beans&gt; &lt;context:XXX&gt;注解组件扫描&lt;context:component-scan/&gt;标签内容如下： **base-package**：要扫描的包 **&lt;context:include-filter&gt;**：扫描过滤器，查看详情 **&lt;context:exclude-filter/&gt;**：扫描过滤器，查看详情 扫描包配置： 1&lt;context:component-scan base-package=&quot;test.annotation&quot;&gt;&lt;/context:component-scan&gt; 使用&lt;context:component-scan&gt;隐式启用 &lt;context:annotation-config&gt;。&lt;context:component-scan&gt;使用时通常不需要包含 &lt;context:annotation-config&gt; 1&lt;context:annotation-config/&gt; &lt;context:annotation-config/&gt;的作用是引入了以下后置处理器，用于处理了相应注解： ConfigurationClassPostProcessor AutowiredAnnotationBeanPostProcessor： @Autowired CommonAnnotationBeanPostProcessor： @Resource @PostConstruct @PreDestroy PersistenceAnnotationBeanPostProcessor： @PersistenceContext EventListenerMethodProcessor： 引入properties文件123&lt;beans&gt; &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;&lt;/beans&gt; jdbc.properties内容如下 1234jdbc.properties jdbc.url=jdbc:hsqldb:hsql://localhost/xdb jdbc.username=sa jdbc.password=111111 java 注解配置此处只列出spring常用和官方提供的注解，如果想要查看其他注解，索引如下 JSR 330 标准注释：[查看详情](#JSR 330 标准注释) @Bean使用范围 类 方法 作用 用来将bean加入到ioc容器中，[查看详情](#@Bean 注解) @Autowired使用范围 构造方法 属性 属性 required：是否必须。默认为true，若不存在则会报错。详细内容下文列出 作用 用于注入属性，[详细内容](#@Autowired 注解) @Resouece使用范围 方法 字段 作用 注入bean依赖，[查看详情](#@Resource 注解) @ConstructorProperties使用范围 构造方法 作用 显示命名构造方法的参数，查看详情 @Required (弃用)使用范围 作用在setXXX()的方法上 作用 只起到提示的作用，如果注释的方法所对应的bean没有配置，就会报错。spring 5.1已经弃用@Required注解，推荐使用构造函数注入进行所需设置。 @Lookup使用范围 方法 作用 用来指定需要注入的方法，点击方法注入查看例子 @PostConstruct使用范围 方法 作用 指定bean初始化回调方法，查看详情 @PreDestroy使用范围 方法 作用 指定bean销毁回调方法，详细说明 @Primary使用范围 @bean注解的方法上 组件类上 作用 指定优先的候选项，[查看详情](#@primary 注解) @Qualifier使用范围 方法参数 和@Autowired配合使用 作用 根据名字过滤bean，[查看详情](#@Qualifier 注解) @PropertySource使用范围 配置类上 作用 读取外部配置，查看详情 @Value使用范围 方法参数 字段 作用 读取外部配置，[查看详情](#@Value 注解) @Scope使用范围 @bean标记的方法 组件注解标记的类 作用 为bean设置作用域，[查看详情](#@Scope 注解) @Configuration使用范围 配置类 作用 声明配置类，[查看详情](#@Configuration 注解) @import使用范围 配置类 作用 导入外部配置类，[查看详情](#@import 注解) @Conditional使用范围 @bean标记的方法 配置类上 作用 用于判断配置类或bean是否引入，[查看详情](#@Conditional 注解) @ImportResource使用范围 配置类 作用 引入外部xml文件，[查看详情](#@ImportResource 注解) @Profile使用范围 配置类 组件类 @bean方法 作用 根据当前环境判断注释的类或bean是否应该被注册，[查看详情](#@Profile 注解) @Component使用范围 bean类上 作用 声明组件类并注册到ioc容器中，又根据语义不同用其封装了多个注解，[查看详情](#@Component 及其组合注解) 依赖注入依赖注入就是在容器创建bean时注入所需要的依赖项，依赖注入由两种方式： 基于构造函数的依赖注入 基于 Setter 的依赖注入 基于构造函数的依赖注入基于构造函数的DI是通过让其调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。和静态工厂方法构造bean几乎是等效的 123456789101112131415161718192021//当前bean@Data@NoArgsConstructorpublic class TestBean { private String name; private int age; private RefBean refBean; public TestBean(String name, int age, RefBean refBean) { this.name = name; this.age = age; this.refBean = refBean; }}//被引用的bean@Datapublic class RefBean { private String name;} 通过构造方法进行依赖注入 123456789&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg value=&quot;张三&quot;/&gt; &lt;constructor-arg value=&quot;6&quot;/&gt; &lt;constructor-arg ref=&quot;refBean&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;refBean&quot; class=&quot;test.pojo.RefBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/bean&gt; 也可以通过@ConstructorProperties注解代替xml配置文件，代码如下： 123456@ConstructorProperties({&quot;name&quot;,&quot;age&quot;,&quot;refBean&quot;})public TestBean(String name1, int age1, RefBean refBean) { this.name = name1; this.age = age; this.refBean = refBean;} 构造参数函数解析 &lt;constructor-arg/&gt; 标签中如果不指定name属性，参数会按照顺序传入构造函数，只要参数类型都对应正确，属性就能正确注入。如果参数类型对应不上，比如把 &lt;constructor-arg/&gt; 标签位置调换一下，那么就会报错。 123456&lt;!--运行会报错--&gt;&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg value=&quot;6&quot;/&gt; &lt;constructor-arg value=&quot;张三&quot;/&gt; &lt;constructor-arg ref=&quot;refBean&quot;/&gt;&lt;/bean&gt; 为了防止这种问题的发生，可以指定name、index或type属性，这三个属性指的都是构造函数的参数，目的就是消除歧义。下面以name举例（点击查看其他属性） 123456&lt;!--运行成功--&gt;&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;6&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;constructor-arg ref=&quot;refBean&quot;/&gt;&lt;/bean&gt; 另外，可以通过 [@ConstructorProperties()](# @ConstructorProperties)注解指定构造函数的参数 基于 Setter 的依赖注入基于 Setter 的 DI 是通过容器在调用无参数构造函数或无参数static工厂方法来实例化bean 后调用 bean 上的 setter 方法来完成的。 12345678910111213141516//当前类@Data@NoArgsConstructorpublic class TestBean { private String name; private int age; private RefBean refBean;}//被引用bean@Data@NoArgsConstructor@AllArgsConstructorpublic class RefBean { private String name;} 通过 Setter 进行依赖注入 123456789&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;refBean&quot; ref=&quot;refBean&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;refBean&quot; class=&quot;test.pojo.RefBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; 点击查看标签属性 基于构造函数和 setter 两种方式可以混合使用，也就是通过构造函数注入依赖项后，还支持使用 setter 进行依赖注入，下面配置是可行的 12345&lt;bean id=&quot;testBean&quot; class=&quot;test.pojo.TestBean&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;3&quot;/&gt; &lt;property name=&quot;refBean&quot; ref=&quot;refBean&quot;/&gt;&lt;/bean&gt; 依赖注入方式的选择选择规则 对必须依赖项使用构造函数，Spring官方提倡使用构造函数注入，理由如下： 这样可以将应用程序组件实现为不可变对象，并确保所需的依赖项不是null； 构造函数注入的组件大多是以初始化完毕的状态返回的； 对可选依赖项使用setter，理由如下： 如果只使用setter，则必须在代码使用依赖项的任何地方执行非空检查； 可以在在setter方法上使用 @Request 注释可用于使属性成为必须的依赖项； 对于不公开任何setter函数的第三方类，构造函数注入可能是唯一可用形式； 依赖解析过程容器执行bean依赖解析过程如下： 使用ApplicationContext扫描所有的配置元数据执行 bean 创建和初始化。配置元数据可以由 XML、Java 代码或注释指定； 对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数（如果您使用它而不是普通构造函数）的形式表示。在实际创建 bean 时，将这些依赖关系提供给 bean； 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用； 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，例如int、 long、String、boolean等； 每个bean作为依赖项注入到其他bean中时就都已经完全配置了； 循环依赖如果使用构造函数注入，则可能会产生循环依赖。例如A的构造函数需要B，B的构造函数需要依赖A，这样A和B都不会初始化成功，Spring检测到后会抛出BeanCurrentlyInCreationException异常。为了解决这类问题，spring在容器加载时检测配置问题，解析依赖项，并且会尽可能晚的设置属性。 方法注入大多数情况下，容器中的bean基本都是单例的。当一个单例的bean依赖另一个非单例的bean时，就可能因为bean的周期不同而出现问题。比如A是单例的，B不是单例的，A依赖B，并且A中有一个方法每次调用都需要B，但A只会在初始化时注入B，无法在每次需要时都为A提供B的新实例。 可以通过实现ApplicationContextAware接口，并在A需要B时调用getBean(&quot;B&quot;)方法获取B实例，代码如下： 123456789101112131415161718192021222324252627282930313233public class A implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } protected B CreateB() { return this.applicationContext.getBean(&quot;b&quot;, B.class); } public Object process(String State) { // 从ioc容器中获取B实例 B b =CreateB(); // 设置B实例状态 b.setState(State); // 执行业务逻辑 return b.execute(); }}@Datapublic class B { private String state; public B execute() { //业务代码 System.out.println(state); return this; }} 这种方式可以解决问题，但A的业务代码与Spring存在耦合。使用方法注入可以更简洁的解决问题，代码如下： 123456789101112public abstract class A { protected abstract B CreateB(); @Lookup public Object process(String State) { B b = CreateB(); b.setState(State); return b.execute(); }} 上面代码使用@Lookup注解进行配置，如果不使用注解也可以使用xml文件配置 12345678&lt;bean name=&quot;b&quot; class=&quot;test.pojo.B&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;a&quot; class=&quot;test.pojo.A&quot;&gt; &lt;!--b如果是单例，每次返回的都是一个实例，如果不是单例，每次返回不同实例--&gt; &lt;lookup-method name=&quot;CreateB&quot; bean=&quot;b&quot;/&gt;&lt;/bean&gt; 使用方法注入后代码量小了很多，而且类中看不到Spring的部分，耦合度也降低了。 查找方法注入查找方法注入是一种覆盖被容器管理的bean的方法的功能，通过&lt;lookup-method&gt;标签或@Lookup注解指定bean中应该覆盖的方法并将容器中对应名字的bean作为方法的返回结果返回。Spring会通过CGLIB进行动态代理来动态生成覆盖该方法的子类并实现该方法的注入。使用时需要注意以下内容： 需要方法注入的类不能被final修饰，需要注入的方法也不能被final修饰； 对具有abstract方法的类进行单元测试需要自己实现子类和方法？ 组件扫描需要到具体类中的具体方法 不适合用于工厂方法，特别是配置类中以@bean修饰的方法，这种情况下，容器不会创建实例，无法在运行时生成子类 要注入的方法格式如下： 1&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments); 如果方法时abstract的，则动态生成的子类实现该方法，负责，动态生成的子类会覆盖原始类中的具体方法。 任意方法替换任意方法替换也可以实现方法注入，但一般没什么用。如果使用xml配置，可以使用 &lt;replaced-method&gt;为已部署的bean中咸鱼的方法替换为另一个方法的实现。举例如下： 假设A中有一个replace()方法，我希望将这个方法替换掉 12345678public class A { public String replace(){ System.out.println(&quot;我是原版的&quot;); return &quot;我是原版的&quot;; }} 定义一个ReplaceA并继承MethodReplacer接口实现reimplement方法，这个方法就是用于替换A中的方法 1234567891011121314public class ReplaceA implements MethodReplacer { /** * @param o * @param method 被替换的方法 * @param objects 参数列表 * @return * @throws Throwable */ @Override public String reimplement(Object o, Method method, Object[] objects) throws Throwable { System.out.println(&quot;我要替换A的方法&quot;); return &quot;我要替换A的方法&quot;; }} 在xml文件中如下配置 123456789&lt;bean name=&quot;replaceA&quot; class=&quot;test.pojo.ReplaceA&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;a&quot; class=&quot;test.pojo.A&quot;&gt; &lt;replaced-method name=&quot;replace&quot; replacer=&quot;replaceA&quot;&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt; 配置完成之后，ioc容器中的A的replace()方法就已经被替换掉了 123ClassPathXmlApplicationContext application = new ClassPathXmlApplicationContext(&quot;collections.xml&quot;);A a = application.getBean(&quot;a&quot;, A.class);a.replace(); //输出：我要替换A的方法&quot; 在&lt;replaced-method&gt;中可以使用一个或多个&lt;arg-type&gt;来指定被覆盖方法的签名，只有在方法被覆盖并且类中存在多个变体时参数的签名才是必须的 bean 作用域声明了一个beanDefination相当于创建了一个这个bean的模板，spring通过这个模板创建多个实例。spring中不仅可以配置bean的依赖和配置，还可以定义beanDefination创建的对象的范围（作用域）。spring定义了六个作用域，下面表格已列出，其中后四个仅在web-aware的上下文情况下有效，另外还可以自定义作用域 Scope 描述 singleton 单例（默认），每个ioc容器中只有一个该对象实例 prototype 任意数量的对象实例 request 单个bean在单个http请求内有效 session 单个bean在http session内有效 application 单个bean在ServletContext内有效 websocket 单个bean在websocket有效 单例当定义一个bean作用域为singleton时，让其会创建该beanDefination的一个实例，存储在单例bean的缓存中，并且对名为该bean的所有后续请求都返回该缓存实例。 原型scope为prototype时，每次对特定bean发出的请求都会创建一个新的bean实例。可以通过注入或者通过容器的getBean方法来进行请求。通常对一些有状态的bean建议声明为prototype作用域，对无状态的bean使用singleton作用域。 spring不会管理prototype的bean的完整的声明周期，只有容器实例化、配置以及组装原型对象并返回给客户端，之后就没有在进一步的操作了.不论作用域是什么，都会调用初始化声明周期回调方法。但是，在prototype情况下不会调用配置的销毁的生命周期回调方法，需要客户端清理prototype的bean并释放所持有的资源，可以通过自定义bean post-processor对bean进行清理 使用具有原型依赖的单例bean当使用的一个单例bean中需要用到原型bean时可以使用方法注入来解决问题 其他作用域request，session，application，和websocket这四个作用域仅用于使用一个web-aware的ApplicationContext实现（例如XmlWebApplicationContext）。不在ClassPathXmlApplicationContext等常规容器下使用，否则会报错 todo 自定义bean扩展生命周期回调可以通过实现InitializingBean和DisposableBean接口的方式与容器对 bean 生命周期的管理进行交互。容器为前者调用 afterPropertiesSet() 为后者调用 destroy() 以让 bean 在初始化和销毁 bean 时执行某些操作。除了初始化和销毁的回调外，还可以实现Lifecycle接口来管理Spring中对象的生命周期。 初始化回调可以通过实现InitializingBean接口并重写afterPropertiesSet()方法来进行bean的初始化。但官方不建议使用这种方式，因为它会使业务代码与Spring耦合。建议使用以下方式 12345678public class SpringLifeCycle { //bean初始化回调 @PostConstruct public void init(){ System.out.println(&quot;初始化回调&quot;); }} 上面使用注解方式，也可以使用xml指定初始化回调方法 12345&lt;!--init-method 设置 bean初始化回调--&gt;&lt;bean name=&quot;lifeCycle&quot; class=&quot;test.pojo.SpringLifeCycle&quot; init-method=&quot;init&quot;&gt;&lt;/bean&gt; 销毁回调可以通过实现DisposableBean接口并重写destroy()方法来进行bean的初始化。但官方不建议使用这种方式，因为它会使业务代码与Spring耦合。建议使用以下方式 12345678public class SpringLifeCycle { //bean销毁回调 @PreDestroy public void destroy(){ System.out.println(&quot;销毁回调&quot;); }} 上面使用注解方式，也可以使用xml指定销毁回调方法 12345&lt;!--destroy-method 设置 bean初始化回调--&gt;&lt;bean name=&quot;lifeCycle&quot; class=&quot;test.pojo.SpringLifeCycle&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt; 默认初始化和销毁方法在&lt;beans&gt;顶级标签上可以定义默认的回调方法名，这样在此&lt;beans&gt;标签内的&lt;bean&gt;标签如果不指定默认的初始化回调那么就会使用设置的默认的回调名的方法 12345678910public class SpringLifeCycle { public void init(){ System.out.println(&quot;初始化回调&quot;); } public void destroy(){ System.out.println(&quot;销毁回调&quot;); }} xml配置 123456&lt;beans default-init-method=&quot;init&quot; default-destroy-method=&quot;destroy&quot;&gt; &lt;bean name=&quot;lifeCycle&quot; class=&quot;test.pojo.SpringLifeCycle&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 多个生命周期机制 上面说明了三种配置生命周期回调的机制： 在InitializingBean和 DisposableBean回调接口 自定义init()和destroy()方法，使用xml配置 使用@PostConstruct和@PreDestroy 注释修饰方法 一个bean可能通过不同机制配置多个回调函数，如果每个配置的方法名都一样，那么只会执行一次，否则每个配置的方法会按照如下顺序执行： 用@PostConstruct和@PreDestroy 注释的方法 InitializingBean和DisposableBean回调接口定义的方法 自定义配置init()和destroy()方法 bean生命周期调用顺序 bean实例化：容器寻找bean的定义信息并将其实例化 依赖注入：按照BeanDefination配置bean的属性 BeanNameAware：如果实现该接口，调用setBeanName()方法 BeanFactoryAware：如果实现该接口，调用setBeanFactory()方法 BeanPostProcessors：如果实现该接口，调用ProcessBeforeInitialization()方法 initializingBean：如果实现该接口，调用afterPropertiesSet()方法 init-method：如果有该配置，调用init-method指定的方法 BeanPostProcessors：如果实现该接口，调用ProcessaAfterInitialization()方法 bean配置完成，可以在业务代码中使用 DisposableBean：如果实现该接口，调用destroy()方法 destroy-method：如果有该配置，调用destroy-method指定的方法 容器级生命周期回调Lifecycle 接口123456789public interface Lifecycle { //容器启动回调 void start(); //容器关闭回调 void stop(); boolean isRunning();} 任何spring所管理的对象都可以实现该接口，当ApplicationContext接收到启动和停止信号时，就会级联调用当前上下文中Lifecycle的所有实现。 LifecycleProcessor 接口LifecycleProcessor是Lifecycle的扩展接口，它添加了刷新和关闭上下文的回调方法 1234567public interface LifecycleProcessor extends Lifecycle { //刷新上下文回调 void onRefresh(); //关闭上下文回调 void onClose();} SmartLifecycle 接口不同bean启动和关闭的顺序可能比较重要，比如A依赖B，那么在启动时B应该在A之前启动，在关闭时A应该在B之前关闭，所以他们两个顺序时固定的，可以使用Phased接口，它提供了getPhase()方法，该方法会返回一个int值，表示执行顺序，启动时最小的phase最先启动，停止时相反。比如上面的例子就可以设置A为200，B为100 12345public interface Phased { //返回值表示启动顺序 int getPhase();} 要对特定 bean 的自动启动（包括启动阶段）进行细粒度控制需要使用SmartLifecycle接口，它实现了Phased接口 12345678910111213141516171819202122public interface SmartLifecycle extends Lifecycle, Phased { int DEFAULT_PHASE = 2147483647; //刷新回调会调用该方法，判断是否在该点启动， //返回true时，Spring容器启动时会去执行start()方法。 default boolean isAutoStartup() { return true; } //DefaultLifecycleProcessor会调用该方法 default void stop(Runnable callback) { this.stop(); //调用回调的run()方法 //相当于开启异步关闭功能 callback.run(); } //返回的是优先级 default int getPhase() { return 2147483647; }} 如上面代码所示，SmartLifecycle接口的getPhase()方法返回的如果返回的是2147483647，如果没有实现SmartLifecycle接口的Lifecycle对象默认为0，因此负的phase会在常规Lifecycle之前启动，之后停止。 LifecycleProcessor接口的默认实现是DefaultLifecycleProcessor，负责在每个阶段中调用对象组的stop()方法，直到超时为止，默认是30秒，可以在上下文中定义bean的timeoutPerShutdownPhase 1234&lt;bean id=&quot;lifecycleProcessor&quot; class=&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;&gt; &lt;!-- timeout value in milliseconds --&gt; &lt;property name=&quot;timeoutPerShutdownPhase&quot; value=&quot;10000&quot;/&gt;&lt;/bean&gt; 实际使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class SpringLifeCycle implements SmartLifecycle { //启动信号 private boolean isRunning; //Lifecycle方法 @Override public void start() { System.out.println(&quot;start-&gt;容器启动回调&quot;); //正在运行 isRunning = true; } @Override public void stop() { System.out.println(&quot;stop-&gt;容器关闭回调&quot;); //标记停止 isRunning = false; } //容器是否正在运行 @Override public boolean isRunning() { System.out.println(&quot;isRunning&quot;); return isRunning; } //SmartLifecycle方法 //容器启动时是否去执行start()方法 @Override public boolean isAutoStartup() { System.out.println(&quot;isAutoStartup&quot;); return true; } @Override public void stop(Runnable callback) { System.out.println(&quot;stop-&gt;生命周期结束&quot;); isRunning = false; callback.run(); } //优先级 @Override public int getPhase() { System.out.println(&quot;getPhase-&gt;获取优先级&quot;); return Integer.MAX_VALUE; }} Awarespring提供了很多的Aware接口，他们的目的是让bean可以获取Spring容器的服务。其实就是一堆用来做依赖注入的回调方法，通过这些方法可以在某些阶段向bean注入一些东西。但这种方式不太好，因为bean代码与spring存在耦合，相比之下用注解进行依赖注入更好 名称 注入依赖 ApplicationContextAware 应用上下文对象 ApplicationEventPublisherAware BeanClassLoaderAware BeanFactoryAware BeanNameAware bean的名字 LoadTimeWeaverAware MessageSourceAware NotificationPublisherAware ResourceLoaderAware ServletConfigAware ServletContextAware ApplicationContextAware如果需要将ApplicationContext注入到bean中，可以创建一个bean并实现ApplicationContextAware接口 123public interface ApplicationContextAware extends Aware { void setApplicationContext(ApplicationContext applicationContext) throws BeansException;} ApplicationContextAware接口中包含setApplicationContext方法，通过实现这个方法完成对applicationContext的注入 12345678public class TestAware implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; }} ApplicationEventPublisherAware如果需要将配置的beanName注入到bean中，可以创建一个bean并实现BeanNameAware接口 123public interface BeanNameAware extends Aware { void setBeanName(String var1);} 通过实现该接口的setBeanName方法完成对beanName的设置 123456789public class TestAware implements BeanNameAware { private String beanName; @Override public void setBeanName(String s) { this.beanName = s; }} 其他Aware接口每个Aware接口的使用方式其实没有区别，关键在于理解每个Aware接口注入实例的作用。关于其他的Aware接口的使用方式不再列出，参照上面两个例子写即可。 其他扩展点BeanPostProcessorSpring框架提供了BeanPostProcessor接口，通过实现该接口并重写之内的方法来定义回调逻辑，Spring会负责自动检测并调用适当的方法 1234567891011public interface BeanPostProcessor { @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; }} 可以配置多个BeanPostProcessor实例，并且BeanPostProcessor可以通过实现Ordered接口设置order来控制这些实例的运行顺序。 当在配置类中使用@bean注解一个定义BeanPostProcessor的工厂方法时，工厂方法的返回值应该是实现或者至少是BeanPostProcessor接口，明确指定post-processor。否则ApplicationContext无法自动检测到。 BeanFactoryPostProcessor此接口用于对bean配置元数据进行操作，可以通过这个接口读取配置元数据并在容器实例化bean之前更改配置元，和BeanPostProcessor类似，但BeanPostProcessor接口时是用来更改bean实例的。该接口也需要与Ordered解耦一起使用指定顺序。 1234@FunctionalInterfacepublic interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;} FactoryBeanFactoryBean接口用于ioc容器的实例化逻辑，如果有复杂的初始化逻辑，可以通过java代码的方式替换冗长的xml。FactoryBean接口提供了三种方法： T getObject()：返回此工厂创建的对象的实例。实例可能会被共享，这取决于这个工厂是返回单例还是原型； boolean isSingleton():true代表FactoryBean返回单例，false表示其他情况 。此方法的默认实现返回true； Class&lt;?&gt; getObjectType(): 返回getObject()方法返回的对象类型，如果不知道类型就返回null； 12345678910111213public interface FactoryBean&lt;T&gt; { String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;; @Nullable T getObject() throws Exception; @Nullable Class&lt;?&gt; getObjectType(); default boolean isSingleton() { return true; }} 代码举例： 1234567891011121314public class MyFactoryBean implements FactoryBean&lt;MyBean&gt; { @Override public MyBean getObject() throws Exception { return new MyBean(); } @Override public Class&lt;?&gt; getObjectType() { return MyBean.class; }}public class MyBean {} 基于java和注解的容器配置注解注入在XML注入之前执行，所以，如果两种方式同时使用，XML可能会覆盖注释的某些配置。 组件扫描与组件组件扫描@ComponentScan和@ComponentScans@ComponentScan注解和@ComponentScans注解用于扫描spring组件。一般声明在配置类上，主要扫描@Component注解和包含@Component的组合注解。 @ComponentScan注解内声明扫描组件所在的包，比较重要的属性如下： value/basePackages：扫描的包，默认是该配置类所在的包。 excludeFilters：排除要扫描的项，查看详情 includeFilters：指定要扫描的包，查看详情 123@ComponentScan(&quot;com.test&quot;)public class MyConfig {} @ComponentScans注解内部是一个@ComponentScan注解的数组 123@ComponentScans({@ComponentScan(value = &quot;test&quot;)})public class MyConfig {} 如果需要使用xml的方式扫描可以如下配置 1&lt;context:component-scan base-package=&quot;org.example&quot;/&gt; 组件扫描过滤可以通过指定@ComponentScan的excludeFilters和includeFilters属性自定义过滤器，每个过滤器都需要type和expression属性 过滤器类型 示例表达式 说明 annotation（默认） org.example.SomeAnnotation 在目标组件的类级别存在该注释或其组合注释 assignable org.example.SomeClass 目标组件继承或实现了该类 aspectj org.example..*Service+ 与目标组件匹配的aspectj表达式 regex org.example.Default.* 与目标组件匹配的正则表达式 custom org.example.MyTypeFilter 根据接口的自定义实现 也可以使用等效的xml标签： &lt;context:exclude-filter /&gt; &lt;context:include-filter /&gt; 下面例子表示扫描test包，然后排除符合test.anno.*Value的类 123456@ComponentScan(value = &quot;test&quot;, excludeFilters = { @ComponentScan.Filter( type = FilterType.REGEX, pattern = &quot;test.anno.*Value&quot;)}, ) 上面例子等效于xml文件 123456&lt;beans&gt; &lt;context:component-scan base-package=&quot;test&quot;&gt; &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;test.anno.*Value&quot;/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; spring默认会自动检测使用@Component、@Repository、@Service、@Controller、@RestController或@Configuration进行注释或元注释的类。如果希望ji禁用这个默认行为可以设置 123@ComponentScan(value = &quot;xxx&quot;, useDefaultFilters = false ) 等效的xml配置 1234&lt;context:component-scan base-package=&quot;xxx&quot; use-default-filters=&quot;false&quot;&gt;&lt;/context:component-scan&gt; @Component 及其组合注解@Component注解用来标记spring的一个组件，是一个通用注解，使用@Component注解提供给各个层的注解有： @Repository：持久层 @Service：服务层 @Controller：表示层 @Configuration：配置类 他们用来标记应该注册进容器的bean类上 123@Component(&quot;dog&quot;)public class Dog implements Animal{} 这些组件注解如果没指明value，他的bean名称会由BeanNameGenerator生成。默认情况下是首字母小写的名称，比如上面例子如果不指定名称则为dog。 如果不想使用默认的名称生成策略，可以实现 BeanNameGenerator 接口，并确保包含一个默认的无参数构造函数。然后，在配置扫描器时提供完全限定的类名，如下配置 1234567891011121314@Configuration@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)public class AppConfig { // ...}public class MyNameGenerator implements BeanNameGenerator { //在该方法中指定命名策略即可 @Override public String generateBeanName(BeanDefinition beanDefinition, BeanDefinitionRegistry beanDefinitionRegistry) { return null; }} @Bean 注解可以在组件中使用@bean注解向容器中注入bean，也可以在该bean工厂方法上添加其他spring注解设置该beanDefinition，一般声明在@Configuration修饰的类上，这时是完整模式。声明在其他类上时被称为精简模式，精简模式不能声明依赖，也就是说这个bean工厂方法的参数不能引入其他bean依赖 1234567891011121314151617181920212223@Configurationpublic class MyConfig { //指定bean的name，默认是方法名，多个名字可使用一个数组传递 @Bean(name = &quot;cat&quot;) //可以声明为static static public Animal getCat(){ return new Cat(); } @Bean //限定修饰符? @Qualifier(&quot;public&quot;) //作用域 @Scope(&quot;singleton&quot;) //懒加载 @Lazy @Description(&quot;bean的描述信息&quot;) public Animal getDog(){ return new Dog(); } } 方法中可以定义参数，会自动进行依赖注入 1234567public interface BaseConfig { @Bean default TransferServiceImpl transferService() { return new TransferServiceImpl(); }} 可以同时定义bean的各种声明周期配置 12345678910111213@Configurationpublic class AppConfig { @Bean(initMethod = &quot;init&quot;) public BeanOne beanOne() { return new BeanOne(); } @Bean(destroyMethod = &quot;cleanup&quot;) public BeanTwo beanTwo() { return new BeanTwo(); }} @Scope 注解@Scope 使用@Scope 注解用于指定bean的scope，如果想要使用自定义策略可以实现ScopeMetadataResolver接口 1234567public class MyBeanScope implements ScopeMetadataResolver { @Override public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) { return null; }} 然后在类扫描器中指定它 12345@Configuration@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)public class AppConfig { // ...} xml形式 1234&lt;beans&gt; &lt;context:component-scan base-package=&quot;org.example&quot; scope-resolver=&quot;org.example.MyScopeResolver&quot;/&gt;&lt;/beans&gt; scoped-proxyspring提供了一种通过作用域代理来处理依赖的方式。使用 XML 配置时创建此类代理的最简单方法是&lt;aop:scoped-proxy/&gt;元素。使用注释在 Java 中配置 bean提供了对属性@Scope的等效支持。proxyMode默认值为ScopedProxyMode.DEFAULT，这通常表示不应创建作用域代理，除非在组件扫描指令级别配置了不同的默认值。您可以 指定ScopedProxyMode.TARGET_CLASS、ScopedProxyMode.INTERFACES或ScopedProxyMode.NO @Configuration 注解@Configuration 使用@Configuration是一个类级别的注解，用来表示一个配置类，内部可声明多个@bean，本身是用来替代xml的，也可以和xml配合使用 12345678910111213141516@Configurationpublic class MyConfig { @Bean(name = &quot;cat&quot;) public Cat getCat(){ return new Cat(); } @Bean(name = &quot;dog&quot;) public Dog getDog(){ return new Dog(); }} 查找方法注入在单例范围的 bean 依赖于原型范围的 bean 的情况下，会用到查找方法注入。 12345678910111213141516171819202122232425262728293031public abstract class CommandManager { public Object process(Object commandState) { // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } // okay... but where is the implementation of this method? protected abstract Command createCommand();}@Bean@Scope(&quot;prototype&quot;)public AsyncCommand asyncCommand() { AsyncCommand command = new AsyncCommand(); // inject dependencies here as required return command;}@Beanpublic CommandManager commandManager() { // return new anonymous implementation of CommandManager with createCommand() // overridden to return a new prototype Command object return new CommandManager() { protected Command createCommand() { return asyncCommand(); } }} @import 注解@import注解用来引入另一个配置类并进行加载，这个注解也是spring boot的核心 123456789101112131415161718@Configurationpublic class ConfigA { @Bean public A a() { return new A(); }}@Configuration@Import(ConfigA.class)public class ConfigB { @Bean public B b() { return new B(); }} @Conditional 注解@Conditional一般用于配置类中，与@bean一起使用。表示必须满足某些条件才能实例化bean。它内部引入了一个实现了Condition接口的类，并且重写了matches方法，在改方法中会条件判断是否成立，如果成立返回true，否则返回false，下面举例说明 @Profile 注解此处只是为了解释@Conditional，@Profile的使用会在后文详细介绍。 @Profile 注解内部就是条件注解实现的，判断依据是当前项目的环境 12@Profile(&quot;test&quot;)//测试环境才加载@Profile(&quot;dev&quot;)//开发环境标识 他一般作用在@bean方法上和配置类上 1234567@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional({ProfileCondition.class})public @interface Profile { String[] value();} 他引入了一个ProfileCondition类，其内部的matches方法定义了判断条件的逻辑，参数有条件上下文和注解的元数据 123456789101112131415161718192021222324class ProfileCondition implements Condition { ProfileCondition() { } public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) { Iterator var4 = ((List)attrs.get(&quot;value&quot;)).iterator(); Object value; do { if (!var4.hasNext()) { return false; } value = var4.next(); } while(!context.getEnvironment().acceptsProfiles(Profiles.of((String[])((String[])value)))); return true; } else { return true; } }} @ImportResource 注解@ImportResource 注解用于导入外部的xml文件，一般声明在@Configuration类上 123456789101112131415161718@Configuration@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)public class AppConfig { @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean public DataSource dataSource() { return new DriverManagerDataSource(url, username, password); }} 生成候选组件索引路径扫描速度很快，但仍可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。现有的扫描注解和配置必须不变，然后加入以下jar包 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt; &lt;version&gt;6.0.0-SNAPSHOT&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果是gradle 12345678910//5.6及以下版本dependencies { compileOnly &quot;org.springframework:spring-context-indexer:6.0.0-SNAPSHOT&quot;}//4.6及以上版本dependencies { annotationProcessor &quot;org.springframework:spring-context-indexer:6.0.0-SNAPSHOT&quot;} 合格jar包会生成一个META-INF/spring.components的文件，挡在类路径找到该文件时，索引会自动启动 依赖注入@Autowired 注解@Autowired 注解只按照类型匹配，想要通过bean名字匹配需要结合@Qualifier使用 应用于构造函数只有一个构造函数时不需要 @Autowired 注解，属性会自动注入 12345678910@Componentpublic class Person { private Cat cat; public Person(Cat cat) { this.cat = cat; } } 扫描到Person类时会自动调用构造函数，然后注入属性 如果有多个构造函数需要通过@Autowired 注解指定要解析的构造函数，若不指定默认调用无参构造，若无参构造也没有则报错 1234567891011121314151617@Componentpublic class Person { private Cat cat; private Dog dog; public Person(Cat cat) { this.cat = cat; } @Autowired public Person(Cat cat, Dog dog) { this.cat = cat; this.dog = dog; }} 多个构造函数标记@Autowired必须都将required设置为false，spring会优先选取匹配参数最多的构造函数，如果一个都不满足，则使用默认构造函数。如果只有一个构造函数标记@Autowired则可以为true。 应用于setter 方法12345678910@Componentpublic class Person { private Cat cat; @Autowired public void setCat(Cat cat) { this.cat = cat; }} 应用于任意名称和多个参数的方法12345678910@Componentpublic class Person { private Cat cat; @Autowired public void ohohohoh(Cat cat) { this.cat = cat; }} spring会自动调用该方法注入依赖 应用于字段1234567@Componentpublic class Person { @Autowired private Cat cat; } 获取对应类型的所有bean123456789101112131415161718192021@Componentpublic class Person { //Cat和Dog的bean会被注入到animals @Autowired private Animal[] animals; //不是必须要用数组，也可以是任何适用的集合类型 private List&lt;Animal&gt; animals;}public interface Animal {}@Componentpublic class Cat implements Animal {}@Componentpublic class Dog implements Animal{} 如果希望列表中的bean按特定顺序注入可以在目标bean实现Ordered接口，或者使用@Order或@Priority注释，否则会按容器中相应bean加载顺序注入 Map会根据value的值进行匹配，只要类型相同就都注入 12345678@Componentpublic class Person { //会将所有Animal类型的bean注入，key是bean的name @Autowired private Map&lt;String,Animal&gt; animals;} 使用集合类型接收时至少要匹配到一个元素，如果一个都没匹配到，自动装配会失败 补充： 可以使用泛型作为隐式的限定，同一个类型的bean，不同的泛型类型也会作为限定条件； @Primary 注解由于@Autowired注解是根据类型进行注入的，所以可能出现多个候选者，这时候就需要使用 @primary 注解指定应有限考虑特定的bean 12345678910111213141516@Componentpublic class Cat implements Animal {}@Primary@Componentpublic class Dog implements Animal{}@Componentpublic class Person { @Autowired private Animal animal;} 如果不加@Primary因为cat和dog都是Animal类型的bean，不知道该注入哪个于是就会报错。上面指定dog为@primary，最终注入的就是dog； 如果是通过@bean注解注册bean，也可以在@bean注解的方法上加@primary，效果是一样的 123456@Bean @Primary public MovieCatalog firstMovieCatalog() { ... } @Bean public MovieCatalog secondMovieCatalog() { ... } @Qualifier 注解如果有多个bean候选项，可以通过@Qualifier注解指定bean的限定值，一般使用beanName作为限定值，用于过滤候选项。 应用于构造函数上12345678910@Componentpublic class Person { private Animal animal; public Person(@Qualifier(&quot;cat&quot;) Animal animal) { this.animal = animal; }} 应用于 @Autowired 注释的方法上1234@Autowiredpublic void sss(@Qualifier(&quot;cat&quot;) Animal animal) { this.animal = animal;} 和 @Autowired 一起使用123@Autowired@Qualifier(&quot;cat&quot;)private Animal animal; @Qualifier 对应的 xml 配置todo 1234&lt;bean class=&quot;xxx&quot;&gt; &lt;qualifier value=&quot;xxx&quot;/&gt; &lt;!-- ... --&gt;&lt;/bean&gt; 自定义限定注解123456@Target({ElementType.FIELD, ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface MyQualifier { String value();} 补充： 除了上面的例子外，@Qualifier 还可以用于过滤bean后注入到集合依赖中； 如果只想使用name主bean有先考虑使用@Resource； @Resource 注解@Resource注解默认根据名称和类型注入bean name：bean的名字，默认值下面例子中列出 type：对于类型，默认值下面例子中列出 应用于字段上如果没有指定name默认是字段名称，如果没有指定type，默认类型就为字段的类型 1234567@Componentpublic class Person { @Resource(name = &quot;cat&quot;) private Animal animal; } 应用于方法上如果没有指定name会将注入的变量名作为名称，比如下面例子默认就是cat。方法名可以随意。如果没有指定type，默认是参数类型，下面例子默认就是Animal 1234@Resource(name = &quot;cat&quot;)public void setCat(Animal cat) { this.cat = cat;} 环境配置Environment接口是集成在spring上下文中的环境抽象，他存储了当前应用程序中的配置文件和属性。配置文件会根据当前的活跃状态向容器中注册bean，而属性包括JVM、操作系统环境变量、命令行参数，一般会在所有应用程序中发挥作用。 @PropertySource注解@PropertySource用于导入外部配置内容，导入的配置会存储在上下文中的environment对象中 12345@PropertySource(&quot;classpath:MyConfig.properties&quot;)@Configurationpublic class MyConfig {} @PropertySource内部可以存在${…}占位符，此占位符会根据环境中的属性进行解析 1@PropertySource(&quot;classpath:/com/${test.placeholder:default/path}/MyConfig.properties&quot;) 上面环境中如果有test.placeholder属性则被解析，否则会使用冒号后的默认配置default/path，如果未指定默认配置则会报错 补充： Spring Boot 默认配置一个PropertySourcesPlaceholderConfigurer的bean，该bean 将从application.properties和application.yml文件中获取属性。 PropertySource 接口Environment对象内中存在propertySources属性，它内部包含一个PropertySource的CopyOnWriteArrayList 列表，上下文的环境信息以这种形式保存在这个列表中。Spring的StandardEnvironment配置了两个 PropertySource 对象，一个代表 JVM 系统属性集（System.getProperties()），一个代表系统环境变量集（System.getenv()）。想要获取配置可以使用以下方法 12345ConfigurableEnvironment environment = ctx.getEnvironment();//是否包含配置environment.containsProperty(&quot;key&quot;);//获取配置信息environment.getProperty(&quot;key&quot;); 搜索配置是分层的，会按照propertySources从头向后变量，默认顺序如下： ServletConfig 参数（如果适用——例如，在DispatcherServlet上下文的情况下） ServletContext 参数（web.xml 上下文参数条目） JNDI 环境变量（java:comp/env/条目） JVM 系统属性（-D命令行参数） JVM系统环境（操作系统环境变量） 上面的是默认顺序，也可以自己选择添加的位置 123MutablePropertySources sources = ctx.getEnvironment().getPropertySources();//设置为头部，最高优先级sources.addFirst(new MyPropertySource()); @Value 注解@Value通常用于注入外部属性，如果值不带${…}占位符则直接注入，如果值带${…}占位符，请看下面的例子 12# 配置文件名：MyConfig.propertiestest.value=aaa 引入配置文件 12345@PropertySource(&quot;classpath:MyConfig.properties&quot;)@Configurationpublic class MyConfig {} 应用于字段上12345678@Componentpublic class TestValue { @Value(&quot;${test.value}&quot;) public String value;} 应用于构造方法上123456789@Componentpublic class TestValue { public String value; public TestValue(@Value(&quot;${test.value}&quot;) String value) { this.value = value; }} 默认属性值spring 提供了一个默认的宽松嵌入式值解析器。它将尝试解析属性值，如果无法解析占位符，会将@Value注解中的值注入属性，下面例子中因为根本没有test.value1这个配置，所以解析失败，默认将${test.value1}字面量注入属性。属性只能是字符串类型，其他类型会报错 12@Value(&quot;${test.value1}&quot;)public String value; 如果要严格控制不存在的值，可以声明一个PropertySourcesPlaceholderConfigurer的bean，如果通配符解析错误会初始化失败 1234@Beanpublic static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() { return new PropertySourcesPlaceholderConfigurer();} spring提供了内置转换器支持允许自动处理简单的类型转换，多个逗号分隔的值会自动转换为字符数组。举例如下 123456789//注入值@Value(&quot;${test.value}&quot;)public float value;@Value(&quot;${test.value1}&quot;)public String[] value;//配置test.value=1test.value1=one,two,three 设置属性默认值可以使用如下配置 123//如果取值失败会使用默认值@Value(&quot;${xxx.xxx:默认值}&quot;)public String[] value; 自定义类型转换spring使用ConversionService来处理@Value注解中将String类型转换为目标类型的过程，如果想要自定义这个转化过程可以提供自定义的ConversionService的bean实例 12345678910@Configurationpublic class AppConfig { @Bean public ConversionService conversionService() { DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(); conversionService.addConverter(new MyCustomConverter()); return conversionService; }} todo @Value 包含SpEL表达式当@Value包含SpEL表达式时，该值会在运行时动态计算 1 todo（看到SpEL时补充） @Profile 注解Environment对象中粗壮乃activeProfiles的set集合，里面存放着当前的激活状态 @Profile 作用@Profile 用于声明一个或多个配置文件处于活动状态，如果指定配置不处于活跃状态，那么标记该注解的类不被解析和注册。可以包含一个配置文件名称（production）或者配置文件表达式。还可以使用更复杂的逻辑表达式（production &amp; test），逗号分隔按或算： !：配置文件的逻辑“非”； &amp;：配置文件的逻辑“与”； |：配置文件的逻辑“或”； 如果一个@Configuration类标有@Profile，如果指定的配置文件不是活跃状态，呢么其内的方法和注释都将被跳过。如果通过@Import引入了一个标有@Profile注解的@Component或@Configuration类，如果指定的配置文件没有激活，那么不会注册该类 1234567891011121314151617181920@Configuration//这两个环境时生效@Profile({&quot;production&quot;,&quot;development&quot;})public class MyConfig { //不同环境使用不同数据源配置 @Bean(&quot;dataSource&quot;) @Profile(&quot;development&quot;) public DataSource standaloneDataSource() { //... } //使用不同配置的@Bean的方法名称应不同 @Bean(&quot;dataSource&quot;) @Profile(&quot;production&quot;) public DataSource jndiDataSource() throws Exception { //... }} 激活配置文件方式一：在启动类中通过代码配置 12AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(&quot;development&quot;); 方式二：使用spring.profiles.active属性激活配置文件，可以在系统环境变量、JVM系统属性、servlet 上下文参数等方式配置 1-Dspring.profiles.active=&quot;profile1,profile2&quot; 方式三：通过Environment配置 1ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;); 如果没有配置激活文件，默认激活default 123456789@Configuration@Profile(&quot;default&quot;)public class DefaultDataConfig { @Bean public DataSource dataSource() { //... }} 自定义读取配置文件todo 123456789@Beanpublic static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() { PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); //设置前缀 placeholderConfigurer.setPlaceholderPrefix(&quot;pre.&quot;); //设置后缀 placeholderConfigurer.setPlaceholderSuffix(&quot;.suf&quot;); return placeholderConfigurer;} 12the.value1=bbbthe.value2=ccc 12@Value(&quot;pre.the.value1.suf-pre.the.value2.suf&quot;)public String value;//bbb-ccc JSR 330 标准注释spring 3开始spring提供了对JSR 330 标准注释的支持。这些注释的扫描方式与spring注解相同。如果想要使用，需要引入相关jar包 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.inject&lt;/groupId&gt; &lt;artifactId&gt;jakarta.inject-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt; 其中注解对比如下表： spring注解 JSR 330 注解 说明 @Autowired @Inject @Inject没有required属性，可以使用Optional替代 @Component @Named / @ManagedBean JSR-330 does not provide a composable model, only a way to identify named components. @Scope(“singleton”) @Singleton 默认也是单例 @Qualifier @Qualifier / @Named ObjectFactory Provider Provider使用get方法 破东西，呸，不好用！ 注册 LoadTimeWeaver当spring需要动态转换类时，会用到LoadTimeWeaver类。将其加载到JVM中，可以使用@EnableLoadTimeWeaving注解到配置类上，以此来引入该类 1234@Configuration@EnableLoadTimeWeavingpublic class AppConfig {} 对应的xml配置 123&lt;beans&gt; &lt;context:load-time-weaver/&gt;&lt;/beans&gt; 一般这个类会在jpa转换时用到，此处不再赘述，详细查看spring data jpa","link":"/2020/02/05/language/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IOC%EF%BC%89/"},{"title":"Spring 核心功能：数据绑定与验证","text":"spring提供了一个数据绑定（DataBinder）与验证（Validator）的设计，目的是不用将验证视为业务逻辑、更易于本地化和可以插入任何可用的验证器 数据验证Jakarta Bean Validationspring提供对Bean Validation（Jakarta Bean Validation）的支持，它是一个java规范，允许开发人员通过注解或自定义注解来表达对象模型（数据验证）的约束。他的一个被认可的实现是Hibernate Validator，这里使用Hibernate Validator为例 引入依赖Maven： 1234567891011121314151617&lt;!--hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;7.0.2.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; Gradle： 123456//hibernate-validatorimplementation group: 'org.hibernate.validator', name: 'hibernate-validator', version: '7.0.2.Final'//javax.el-apiimplementation group: 'javax.el', name: 'javax.el-api', version: '3.0.0'//javax.elimplementation group: 'org.glassfish', name: 'javax.el', version: '3.0.0' 声明约束Hibernate Validator 包含一组基本的常用约束。这些是 Jakarta Bean 验证规范定义的主要约束，此外，Hibernate Validator 提供了有用的自定义约束。每个约束都可以声明message字段值，在验证失败时可以通过方法查看错误值 基本约束 约束名称 作用范围 作用 @AssertFalse 布尔 元素为false @AssertTrue 布尔 元素为true @DecimalMax(value=, inclusive=) 数字、字符序列等 元素值小于value，inclusive表示是否带等于 @DecimalMin(value=, inclusive=) 数字、字符序列等 元素值大于value，inclusive表示是否带等于 @Digits(integer=, fraction=) 数字、字符序列等 值最多为integer位数，和fraction位小数 @Max(value=) 数字、字符序列等 元素值小于等于value @Min(value=) 数字、字符序列等 元素值大于等于value @Negative 数字、字符序列等 元素是否为负 @NegativeOrZero 数字、字符序列等 元素是否为负或0 @Positive 数字、字符序列等 元素是否为正 @PositiveOrZero 数字、字符序列等 元素是否为正或0 @Future 日期类型 日期在未来 @FutureOrPresent 日期类型 日期在现在或未来 @Past 日期类型 日期在过期 @PastOrPresent 日期类型 日期在现在或过去 @Email 字符序列 检查电子邮箱格式 @NotBlank 字符序列 元素不为空 @Pattern(regex=, flags=) 字符序列 检查是否匹配正则 @NotEmpty Collection、map、字符序列 元素不为空 @Size(min=, max=) Collection、map、字符序列 元素大小介于min、max之间（包含） @NotNull 任意类型 元素值不为null @Null 任意类型 元素为null 说明： 字符序列（CharSequence）是一个接口，他的子类有String、StringBuffer、StringBuilder； 附加约束 约束名称 作用范围 作用 @Currency(value=) MonetaryAmount 货币单位是否是指定货币单位的一部分 @DurationMax(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=) Duration 元素不大于根据注释参数构造的元素，inclusive代表是否允许相等 @DurationMin(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=) Duration 元素不小于根据注释参数构造的元素，inclusive代表是否允许相等 @CreditCardNumber(ignoreNonDigitCharacters=) 字符序列 检查元素是否通过Luhn 校验和测试 @EAN 字符序列 检查带注释的字符序列是否为有效的EAN条形码。type 确定条码的类型。默认值为 EAN-13 @ISBN 字符序列 检查带注释的字符序列是否是有效的ISBN。type确定 ISBN 的类型。默认值为 ISBN-13。 @Length(min=, max=) 字符序列 元素长度在min和max之间 @CodePointLength(min=, max=, normalizationStrategy=) 字符序列 字符序列的代码点长度是否介于两者之间min并max包括在内。如果设置，则验证标准化值normalizationStrategy @LuhnCheck(startIndex= , endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=) 字符序列 字符序列中的数字是否通过了 Luhn 校验和算法 @Mod10Check(multiplier=, weight=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=) 字符序列 检查带注释的字符序列中的数字是否通过了通用 mod 10 校验和算法 @Mod11Check(threshold=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=, treatCheck10As=, treatCheck11As=) 字符序列 检查带注释的字符序列中的数字是否通过了 mod 11 校验和算法 @Normalized(form=) 字符序列 验证带注释的字符序列是否根据给定的form @URL(protocol=, host=, port=, regexp=, flags=) 字符序列 根据 RFC2396 检查带注释的字符序列是否是有效的 URL @Range(min=, max=) 数字、字符序列等 检查注释值是否介于（包括）指定的最小值和最大值之间 @ScriptAssert(lang=, script=, alias=, reportOn=) 任意类型 检查是否可以根据注释元素成功评估给定脚本 @UniqueElements Collection 检查带注释的集合是否仅包含唯一元素 Hibernate Validator 还提供了一些特定于国家/地区的限制条件，例如用于验证社会安全号码，有需要点击查看 约束声明位置 字段约束 12@NotNullprivate String name; getter约束 12@NotNullpublic String getxxx() {return xxx;} 容器约束 1private Set&lt;@ValidPart String&gt; set = new HashSet&lt;&gt;(); 类约束 12@ValidPassengerCountpublic class Car {...} 参数约束 12//name不能为空,可以连续加多个约束，空格分隔public void funName(@NotNull String name) {...} 返回值约束 1234//返回值不能为null@NotNull//返回集合不能包含nullpublic List&lt;@NotNull Customer&gt; funName() {return null;} 级联约束：级联约束需要在将要进行约束的字段标记@Valid即可 约束继承：父类声明的约束在子类也一样有效 验证字段验证字段使用Validator类 123ValidatorFactory factory = Validation.buildDefaultValidatorFactory();Validator validator = factory.getValidator(); Validator方法： validate()：对给定 bean 的所有约束执行验证 1validator.validate(person); validateProperty()：验证给定对象的单个命名属性，不能检查级联 12//第二个参数是字段名字符串validator.validateProperty(person,&quot;name&quot;); validateValue()：给定对象的单个命名属性进行验证，不能检查级联 1validator.validateValue( person.class,&quot;name&quot;,null); 验证方法验证方法使用ExecutableValidator类 123ValidatorFactory factory = Validation.buildDefaultValidatorFactory();ExecutableValidator executableValidator = factory.getValidator().forExecutables(); ExecutableValidator方法： validateParameters()：验证方法参数 12345Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateParameters( person, Person.class.getMethod(&quot;printMessage&quot;,String.class), new Object[]{&quot;参数1&quot;}); validateReturnValue()：验证方法返回值 12345Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateReturnValue( person, Person.class.getMethod(&quot;printMessage&quot;,String.class), Collections.&lt;Person&gt;emptyList()); validateConstructorParameters()：验证构造函数参数 1234Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateParameters( Person.class.getConstructor(String.class), new Object[]{&quot;参数1&quot;}); validateConstructorReturnValue()：验证构造函数返回值 1234executableValidator.validateConstructorReturnValue( Person.class.getConstructor(), new Person()); 获取验证结果ConstraintViolation类用于包装验证结果，常用方法如下： getMessage()：内插错误消息 getMessageTemplate()：非插值错误消息 getRootBean()：正在验证的根 bean getRootBeanClass()：正在验证的根 bean类 getPropertyPath()：从根 bean 到验证值的属性路径 getInvalidValue()：值未能通过约束 getConstraintDescriptor()：约束元数据报告失败 getExecutableParameters()：验证方法时返回方法或构造函数验证的参数数组 getExecutableReturnValue()：验证返回值时提供对验证对象的访问 约束示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Data@AllArgsConstructor@NoArgsConstructorpublic class Person { @NotNull(message = &quot;名字不能为空&quot;) @Length(min = 1,max = 5,message = &quot;名字长度在1-5之间&quot;) private String name; @Range(min = 0,max = 150,message = &quot;年龄在0-150之间&quot;) private int age; @NotNull(message = &quot;生日不能为空&quot;) @Past(message = &quot;生日要在过去&quot;) private Date birthday; @NotNull(message = &quot;邮箱不能为空&quot;) @Email(message = &quot;邮箱格式不正确&quot;) private String email; //返回值约束 @NotBlank(message = &quot;返回值不能为空&quot;) public String getFormatPrint(){ return String.format(&quot;name=%s,age=%d,birthday=%s&quot;,name,age,birthday); } //参数约束 public void printMessage(@NotBlank(message = &quot;参数不能为空&quot;) String message){ System.out.println(message); } //级联验证 @Valid @NotEmpty private List&lt;Cat&gt; cats; @Data @NoArgsConstructor public static class Cat{ @NotBlank(message = &quot;猫名字不能为空&quot;) private String name; public Cat(String name) { this.name = name; } }} 验证代码 12345678910111213141516171819202122232425262728ValidatorFactory factory = Validation.buildDefaultValidatorFactory();//字段验证Validator validator = factory.getValidator();//方法验证ExecutableValidator executableValidator = factory.getValidator().forExecutables();//构造beanPerson person = new Person();//名字长度大于5person.setName(&quot;克里斯蒂安刘能&quot;);//不给猫加名字person.setCats(Collections.singletonList(new Person.Cat()));//验证字段Set&lt;ConstraintViolation&lt;Person&gt;&gt; constraintViolationSet = validator.validate(person);for (ConstraintViolation&lt;Person&gt; constraintViolation : constraintViolationSet) { System.out.println(constraintViolation.getMessage());}//验证方法Set&lt;ConstraintViolation&lt;Person&gt;&gt; printMessage = executableValidator.validateParameters( person, Person.class.getMethod(&quot;printMessage&quot;,String.class), new Object[]{&quot;&quot;});for (ConstraintViolation&lt;Person&gt; constraintViolation : printMessage) { System.out.println(constraintViolation.getMessage());} 自定义约束创建约束注释123456789101112131415161718@Target({ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(validatedBy = {MyConstraintValidator.class})public @interface MyCheck { //违反约束的默认消息 String message() default &quot;字符串值必须为yes&quot;; //此约束所属的验证组的属性 Class&lt;?&gt;[] groups() default {}; //Jakarta Bean Validation API 的客户端可以使用该属性将自定义有效负载对象分配给约束 Class&lt;? extends Payload&gt;[] payload() default {}; //允许指定所需的案例模式,一般不需要 String[] value() default {};} 实现一个验证器实现ConstraintValidator&lt;A extends Annotation, T&gt; 接口并实现其方法即可 12345678910111213141516171819202122/** * 父类泛型解释 * A extends Annotation：这里是MyCheck，表示要验证的注释类型 * T：这里是String，表示要处理的元素类型 */public class MyConstraintValidator implements ConstraintValidator&lt;MyCheck, String&gt; { //访问当前验证注解的属性值 @Override public void initialize(MyCheck constraintAnnotation) { } //包含实际的验证逻辑 @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) { if(&quot;yes&quot;.equals(s)){ return true; } return false; }} 接下来只需要把注解放到想要验证的地方就可以了，此处不演示 验证单个对象（spring）spring提供了Validator接口，可以创建一个验证类实现该接口，并实现其中的方法，用于数据的验证 12345678910111213141516171819202122232425262728293031323334353637public class Person { private String name; private int age; //getters/setters}public class PersonValidator implements Validator { /** * Validator是否可以提供验证该clazz类的实例 * @param clazz * @return */ @Override public boolean supports(Class&lt;?&gt; clazz) { return Person.class.equals(clazz); } /** * 验证给定的对象，并将错误信息返稿errors里 * @param target 验证码目标对象 * @param errors 包装错误信息，内部包括target对象 */ @Override public void validate(Object target, Errors errors) { //拒绝该属性 ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name为空&quot;); Person p = (Person) target; if (p.getAge() &lt; 0) { errors.rejectValue(&quot;age&quot;, &quot;年龄为负数&quot;); } else if (p.getAge() &gt; 110) { errors.rejectValue(&quot;age&quot;, &quot;年纪过大&quot;); } }} 说明： ValidationUtils是spring提供的工具类； 拒绝字段时除了自定义的拒绝code（例如rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)），还会自动注册其他code（还会注册too.darn.old.ageand too.darn.old.age.int）； 上述代码可通过如下代码调用验证和获取结果 1234567Person person = new Person();person.setName(&quot;张三&quot;);DataBinder binder = new DataBinder(person);binder.setValidator(new PersonValidator());binder.validate();BindingResult results = binder.getBindingResult();System.out.println(results); 验证嵌套对象（spring）验证嵌套对象时最好将每个对象的验证逻辑封装在自己的Validator实现中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Person { private String name; private Cat cat; //getters/setters}public class Cat { private String name; //getters/setters}public class CatValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; clazz) { return Cat.class.equals(clazz); } @Override public void validate(Object target, Errors errors) { ValidationUtils.rejectIfEmptyOrWhitespace(errors,&quot;cat.name&quot;,&quot;没名字&quot;); }}public class PersonValidator implements Validator { private CatValidator catValidator; public PersonValidator(CatValidator catValidator) { this.catValidator = catValidator; } /** * Validator是否可以提供验证该clazz类的实例 * @param clazz * @return */ @Override public boolean supports(Class&lt;?&gt; clazz) { return Person.class.equals(clazz); } /** * 验证给定的对象，并将错误信息返稿errors里 * @param target 验证码目标对象 * @param errors 包装错误信息 */ @Override public void validate(Object target, Errors errors) { ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name为空&quot;); Person p = (Person) target; //去执行cat的验证 ValidationUtils.invokeValidator(this.catValidator,p.getCat(),errors); }} 数据绑定DataBinderDataBinder是spring提供的数据绑定机制，可以与Validator接口的实现类配合使用，进行数据验证，用法如下 123456789Person person = new Person();person.setName(&quot;张三&quot;);DataBinder binder = new DataBinder(person);binder.setValidator(new PersonValidator());//执行验证binder.validate();//获取错误信息BindingResult results = binder.getBindingResult();System.out.println(results); BeanWrapper 接口BeanWrapper接口以及其对应实现（BeanWrapperImpl）位于org.springframework.beans包内。BeanWrapper提供了设置和获取属性值、获取属性描述符和查询属性以确定他们是可读还是可写的功能。此外BeanWrapper还提供对嵌套属性的支持，还有对设置索引属性的支持。BeanWrapper会在DataBinder和BeanFactory中被使用 表达式 说明 name 属性名 cat.name 嵌套属性 list[1] 集合属性 map[key] 键值对映射 举例如下： 1234567891011121314151617181920212223@Datapublic class Cat { private String name;}@Datapublic class Person { private String name; private Cat cat;}BeanWrapperImpl person = new BeanWrapperImpl(new Person());//设置值（方式一）person.setPropertyValue(&quot;name&quot;,&quot;张三&quot;);//设置值（方式二）PropertyValue value = new PropertyValue(&quot;cat&quot;, new Cat());person.setPropertyValue(value);//设置嵌套属性person.setPropertyValue(&quot;cat.name&quot;,&quot;猫咪&quot;);//获取person对象Person rootInstance = (Person)person.getRootInstance();System.out.println(rootInstance); PropertyEditor 接口Spring内部使用PropertyEditor接口进行属性编辑，将这些字符串装换为对应的Object类型。比如使用xml声明bean属性时，spring就会尝试使用ClassEditor将参数解析为Class对象。如果需要在绑定属性时做自定义操作，可以自己实现PropertyEditor并注册到ioc容器中 内置 PropertyEditor 实现spring内置了很多PropertyEditor的实现，BeanFactory和ApplicationContext都会通过他们来使用BeanWrapper进行属性转换。他们都位于org.springframework.beans.propertyeditors包中，并且大多数由PropertyEditor 注册 ByteArrayPropertyEditor：将字符串转换为对应的字节表示 ClassEditor：将表示类的字符串解析为实际类 CustomBooleanEditor：可自定义的Boolean编辑器 CustomCollectionEditor：将任意原集合转换为目标集合类型 CustomDateEditor：自定义DateFormat，默认未注册 CustomNumberEditor：处理数字类型 FileEditor：将字符串解析为java.io.File对象 InputStreamEditor：将字符串转换为InputStream LocaleEditor：将字符串（格式[language]_[country]_[variant]）转换为Locale对象，反之亦然 PatternEditor：字符串解析为java.util.regex.Pattern对象，反之亦然 PropertiesEditor：将字符串转换为Properties对象 StringTrimmerEditor：修剪字符串的属性编辑器。可选地允许将空字符串转换为null值，默认未注册 URLEditor：将url字符串转化为url对象 自定义 PropertyEditor自定义 PropertyEditor可以通过属性注入时的字符串value值创建自己希望的实例，然后注入到bean中。 bean类如下 1234567891011121314@Datapublic class Cat { private String name; public Cat(String name) { this.name = name; }}@Datapublic class Person { private String name; private Cat cat;} 将Cat注入到Person中 12345&lt;!--注入属性--&gt;&lt;bean name=&quot;person&quot; class=&quot;test.anno.Person&quot;&gt; &lt;!--此时使用的是value--&gt; &lt;property name=&quot;cat&quot; value=&quot;猫名字&quot;/&gt;&lt;/bean&gt; 自定义Cat类型的编辑器CatTypeEditor 123456public class CatTypeEditor extends PropertyEditorSupport { @Override public void setAsText(String text) throws IllegalArgumentException { super.setValue(new Cat(text)); }} 通过xml文件配置属性的映射关系并注册进ioc容器中 12345678&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt; &lt;property name=&quot;customEditors&quot;&gt; &lt;map&gt; &lt;!--配置类型和编辑器的映射--&gt; &lt;entry key=&quot;test.anno.Cat&quot; value=&quot;test.anno.CatTypeEditor&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 也可以通过实现PropertyEditorRegistrar接口进行注册 12345678//这里直接使用注解注入了，使用xml也一样@Configurationpublic class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar { @Override public void registerCustomEditors(PropertyEditorRegistry propertyEditorRegistry) { propertyEditorRegistry.registerCustomEditor(Cat.class,new CatTypeEditor()); }} xml文件中配置注册器 12345678&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt; &lt;!--注册自定义注册器--&gt; &lt;property name=&quot;propertyEditorRegistrars&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;customPropertyEditorRegistrar&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 类型转换spring 3引入了一个core.convert的包，用于提供通用的类型转换。它可以用来替代自定义 PropertyEditor，将外部的字符串value值转化为所需的属性类型 自定义转换器创建转换器类，实现Converter接口，实现convert方法 12345678910111213@FunctionalInterfacepublic interface Converter&lt;S, T&gt; { @Nullable T convert(S source); default &lt;U&gt; Converter&lt;S, U&gt; andThen(Converter&lt;? super T, ? extends U&gt; after) { Assert.notNull(after, &quot;After Converter must not be null&quot;); return (s) -&gt; { T initialResult = this.convert(s); return initialResult != null ? after.convert(initialResult) : null; }; }} 泛型S、T表示将数据从S类型转换为T类型 123456public class StringToCatConverter implements Converter&lt;String,Cat&gt; { @Override public Cat convert(String source) { return new Cat(source); }} 自定义转换器工厂当需要集中定义将字符串转化为有公共接口的多个类时，应该实现ConverterFactory接口 123public interface ConverterFactory&lt;S, R&gt; { &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);} 其中泛型表示将S转换为T类型，T必须是R的子类型 12345678910111213141516171819202122232425262728293031public class StringToAnimalConverterFactor implements ConverterFactory&lt;String,Animal&gt; { @Override public &lt;T extends Animal&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) { return null; } //根据不同的T类型创建不同的转换器，T可能是Cat也可能时Dog都实现了Animal private final class StringToAnimalConverter&lt;T extends Animal&gt; implements Converter&lt;String, T&gt; { private Class&lt;T&gt; AnimalType; public StringToAnimalConverter(Class&lt;T&gt; AnimalType) { this.AnimalType = AnimalType; } @SneakyThrows public T convert(String source) { Animal a = (Animal)AnimalType.newInstance(); a.setName(source); return (T)a; } } //使用反射效率低，个人觉得还是每个目标类型都定义一个转换器比较好，如下所示 private final class StringToAnimalConverter&lt;T&gt; implements Converter&lt;String, Cat&gt; { public Cat convert(String source) { return new Cat(&quot;猫名字&quot;); } }} 多对源类型与目标类型转换GenericConverter提供多对源类型和目标类型之间进行转换。它提供了可用的源和目标字段的上下文，可以在实现逻辑时使用。 1234567891011121314151617181920212223242526272829303132public interface GenericConverter { //返回支持的源→目标类型对 @Nullable Set&lt;GenericConverter.ConvertiblePair&gt; getConvertibleTypes(); //类型转换方法 @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType); //元-&gt;目标类型对 public static final class ConvertiblePair { private final Class&lt;?&gt; sourceType; private final Class&lt;?&gt; targetType; public ConvertiblePair(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType) { Assert.notNull(sourceType, &quot;Source type must not be null&quot;); Assert.notNull(targetType, &quot;Target type must not be null&quot;); this.sourceType = sourceType; this.targetType = targetType; } public Class&lt;?&gt; getSourceType() { return this.sourceType; } public Class&lt;?&gt; getTargetType() { return this.targetType; } //equals()/hashCode()/toString() }} 此接口一般只有在非常复杂的情况下才会使用 类型转换条件通过ConditionalGenericConverter接口可以定义类型转换条件。比如希望在目标字段上存在特定注解时才进行转换，或者时在目标类型上定义了特定方法才进行转换 123456public interface ConditionalConverter { boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);}public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {} 举例如下 12345678910111213141516171819public class StringToCatConditionalGenericConverter implements ConditionalGenericConverter { //转换条件 @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return false; } //可以转换的源类型-目标类型对 @Override public Set&lt;ConvertiblePair&gt; getConvertibleTypes() { return null; } //转换方法 @Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { return null; }} 通用类型转换逻辑ConversionService接口定义了一个统一的api，用于在运行时执行类型转换逻辑 1234567891011public interface ConversionService { boolean canConvert(@Nullable Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType); boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType); @Nullable &lt;T&gt; T convert(@Nullable Object source, Class&lt;T&gt; targetType); @Nullable Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);} 1 GenericConversionService类和ConversionServiceFactory类是ConversionService的实现类，特们提供了大多数环境的通用实现，默认可以在字符串、数字、枚举、集合、映射和其他常见类型之间进行转换。如果想用自定义转换器进行补充，只需要补充或覆盖默认转换器，配置如下 12345678&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;example.MyCustomConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 字段格式Formatter 接口Formatter 接口提供了简单的字段格式化功能 123456789101112public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {}@FunctionalInterfacepublic interface Printer&lt;T&gt; { String print(T object, Locale locale);}@FunctionalInterfacepublic interface Parser&lt;T&gt; { T parse(String text, Locale locale) throws ParseException;} 自定义格式转换，需要实现Formatter接口，实现其中的方法 1234567891011121314151617181920212223242526272829303132@Datapublic class MyDateFormatter implements Formatter&lt;Date&gt; { //时间格式 private String pattern; public MyDateFormatter(String pattern) { this.pattern = pattern; } public MyDateFormatter() { this.pattern = &quot;yyyy-MM--dd&quot;; } //解析方法，将字符串转化为对应的类型 @Override public Date parse(String formatted, Locale locale) throws ParseException { return getDateFormat(locale).parse(formatted); } //输出方法，将对象转换为对应格式的字符串 @Override public String print(Date date, Locale locale) { return getDateFormat(locale).format(date); } protected DateFormat getDateFormat(Locale locale) { DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale); dateFormat.setLenient(false); return dateFormat; }} 通过FormattingConversionServiceFactoryBean注册到ioc容器中 123456789&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt; &lt;!--自定义的formatter加入到该属性结合中--&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;test.anno.MyDateFormatter&quot; /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 也可以通过java代码形式 12345678910@Beanpublic FormattingConversionService conversionService() { DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); conversionService.addFormatter(new MyDateFormatter()); return conversionService;} 通过以下格式注入会调用自定义的MyDateFormatter类的parse方法进行转换 1234&lt;!--注入属性--&gt;&lt;bean name=&quot;person&quot; class=&quot;test.anno.Person&quot;&gt; &lt;property name=&quot;birthday&quot; value=&quot;2000-3--2&quot;/&gt;&lt;/bean&gt; 注解格式转换字段格式可以通过字段类型和注解进行配置，想要将注解绑定到Formatter，需要实现AnnotationFormatterFactory接口 1234567891011//A是一个注解类型，用来修饰与格式化逻辑的相关字段public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; { //返回能使用注解的字段类型 Set&lt;Class&lt;?&gt;&gt; getFieldTypes(); //返回一个Printer打印注解字段的值 Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType); //返回一个Parser用来解析注解字段的值 Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);} 自定义注解 12345678910111213141516171819@Documented@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})public @interface MyDateFormat { MyDateFormat.Style style() default MyDateFormat.Style.DEFAULT; //时间格式化类型 String pattern() default &quot;&quot;; //默认为英文格式 public static enum Style { DEFAULT, CHINESE; private Style() { } }} 实现AnnotationFormatterFactory接口并实现抽象方法，将需要使用的注解作为其泛型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//父类传递的泛型为MyDateFormatpublic class MyDateFormatAnnotationFormatterFactory implements AnnotationFormatterFactory&lt;MyDateFormat&gt; { public static Set&lt;Class&lt;?&gt;&gt; Types; static { Set&lt;Class&lt;?&gt;&gt; fieldTypes = new HashSet(8); fieldTypes.add(Date.class); Types = Collections.unmodifiableSet(fieldTypes); } public MyDateFormatAnnotationFormatterFactory() { } //返回可以解析的类集合 @Override public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() { return Types; } //获取打印器 @Override public Printer&lt;?&gt; getPrinter(MyDateFormat annotation, Class&lt;?&gt; fieldType) { return this.configureFormatterFrom(annotation); } //获取解析器 @Override public Parser&lt;?&gt; getParser(MyDateFormat annotation, Class&lt;?&gt; fieldType) { return this.configureFormatterFrom(annotation); } //这里获取打印器和解析器是上一小节自定义的Formatter类 //也可以直接返回SimpleDateFormat值? private Formatter&lt;Date&gt; configureFormatterFrom(MyDateFormat annotation) { String pattern = annotation.pattern(); //如果制定了时间格式 if (StringUtils.hasLength(pattern)) { return new MyDateFormatter(pattern); } else { MyDateFormat.Style style = annotation.style(); if (style == MyDateFormat.Style.CHINESE) { return new MyDateFormatter(&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;); } else { return new MyDateFormatter(&quot;yyyy:MM:dd HH:mm:ss&quot;); } } }} 创建注册器，用于同一添加 1234567891011121314151617181920@Datapublic class MyDateFormatterRegistrar implements FormatterRegistrar { private MyDateFormatter myDateFormatter; private MyDateFormatAnnotationFormatterFactory myDateFormatAnnotationFormatterFactory; public MyDateFormatterRegistrar() { myDateFormatter = new MyDateFormatter(); myDateFormatAnnotationFormatterFactory = new MyDateFormatAnnotationFormatterFactory(); } @Override public void registerFormatters(FormatterRegistry registry) { registry.addFormatter(myDateFormatter); //添加myDateFormatter，其实这里不添加也可以 registry.addFormatterForFieldType(Date.class,myDateFormatter); //添加myDateFormatAnnotationFormatterFactory registry.addFormatterForFieldAnnotation(myDateFormatAnnotationFormatterFactory); }} 和上一小节一样，通过FormattingConversionServiceFactoryBean注册进ioc容器 123456789&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt; &lt;!--将自定义的formatterRegistrar注入到该属性集合中--&gt; &lt;property name=&quot;formatterRegistrars&quot;&gt; &lt;set&gt; &lt;bean class=&quot;test.anno.MyDateFormatterRegistrar&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 或者也可以通过java代码配置 1234567891011@Beanpublic FormattingConversionService conversionService() { DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); MyDateFormatterRegistrar registrar = new MyDateFormatterRegistrar(); registrar.registerFormatters(conversionService); return conversionService;} 接下来只需要在需要用到的地方加上自定义的@MyDateFormat注解 12@MyDateFormatprivate Date Birthday; 然后在注入属性时就会自动调用MyDateFormatAnnotationFormatterFactory类的getParser方法获取解析器，然后进行解析了 1234&lt;!--注入属性--&gt;&lt;bean name=&quot;person&quot; class=&quot;test.anno.Person&quot;&gt; &lt;property name=&quot;birthday&quot; value=&quot;2000:7:7 7:7:7&quot;/&gt;&lt;/bean&gt;","link":"/2020/05/20/language/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%AA%8C%E8%AF%81/"},{"title":"Spring 核心功能：数据缓冲器和编解码器","text":"java的NIO提供了ByteBuffer，很多库基于ByteBuffer构建自己的缓冲区api。spring-core模块提供了一组抽象来处理字节缓冲区api： DataBufferFactory：创建抽象数据缓冲区 DataBuffer：字节缓冲区，可以被池化 DataBufferUtils：数据缓冲区的工具类 Codecs：将数据缓冲区流编码或解码为更高级别对象 DataBufferFactory1234567891011public interface DataBufferFactory { DataBuffer allocateBuffer(); DataBuffer allocateBuffer(int initialCapacity); DataBuffer wrap(ByteBuffer byteBuffer); DataBuffer wrap(byte[] bytes); DataBuffer join(List&lt;? extends DataBuffer&gt; dataBuffers);} 他又两个实现类DefaultDataBufferFactory和NettyDataBufferFactory。 DataBufferFactory有两种创建DataBuffer的方式 分配一个新的数据缓冲区，可以指定容量，也可按需增长或缩小 12345DefaultDataBufferFactory bufferFactory = new DefaultDataBufferFactory();//不指定大小，默认为256DefaultDataBuffer dataBuffer = bufferFactory.allocateBuffer();//指定缓冲区大小DefaultDataBuffer dataBuffer1 = bufferFactory.allocateBuffer(10); 包装现有的byte[]或java.nio.ByteBuffer，他使用DataBuffer装饰给定的数据，不会重新分配空间 123DefaultDataBufferFactory bufferFactory = new DefaultDataBufferFactory();byte[] bytes = new byte[]{};DefaultDataBuffer dataBuffer = bufferFactory.wrap(bytes); DataBufferDataBuffer提供了与Netty类似的操作，另外还包括以下功能 以独立的位置读取和写入，不需要flip()进行读写反复切换 自动扩容 通过PooledDataBuffer实现池化缓冲区和引用计数 将缓冲区视为java.nio.ByteBuffer、InputStream或OutputStream 对于给定的byte，确定其索引或最后的索引 PooledDataBuffer字节缓冲区可以是直接或非直接的。直接市值可以分配在java堆之外，这就节省了I/O的复制操作，但他们创建和释放的成本呢也很高，所以引入了池技术来解决这一问题。 PooledDataBuffer 是 DataBuffer 的扩展，使用引用计数方式管理资源的创建和释放。当分配 PooledDataBuffer 时，引用计数为 1。调用 retain() 增加计数，调用 release() 减少计数。只要计数大于0，就保证缓冲区不会被释放。当计数减少到 0 时，可以释放池化缓冲区，这实际上可能意味着为缓冲区保留的内存返回到内存池。 DataBufferUtils很多情况下，不推荐对PooledDataBuffer直接进行操作，最好使用DataBufferUtils 中的便捷方法，这些方法只在DataBuffer 是 PooledDataBuffer 的实例时才对 DataBuffer 应用释放或保留。DataBufferUtils提供了很多实用的方法来操作数据缓冲区 release(dataBuffer)：读取缓冲区并准备释放 join(dataBuffers)：将数据缓冲区流聚合到单个数据缓冲区中 Codecsorg.springframework.core.codec提供了以下接口 Encoder：编码器，将Publisher&lt;T&gt;成转换数据缓冲区流。 Decoder：解码器，将Publisher&lt;DataBuffer&gt;转换成更高级别的对象流。 spring-core提供了对byte[]、ByteBuffer、DataBuffer、Resource和 String编码器和解码器实现。spring-web模块添加了 Jackson JSON、Jackson Smile、JAXB2、Protocol Buffers 和其他编码器和解码器。","link":"/2020/06/01/language/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%99%A8%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/"},{"title":"Spring 核心功能：资源访问","text":"由于JDK提供的资源访问类并不能很好的满足底层资源的访问需求，所以Spring设计了一个Resource接口。Spring框架使用Resource装载各种资源，包括配置文件资源、国际化属性文件资源等 Resource 接口Resource位于org.springframework.core.io包中，用于抽象对低级资源的访问。 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Resource extends InputStreamSource { //此资源是否存在 boolean exists(); default boolean isReadable() { return this.exists(); } //当前是否能打开资源，比如如果已经被打开了就不能再次打开 default boolean isOpen() { return false; } default boolean isFile() { return false; } //资源实际的url URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; default ReadableByteChannel readableChannel() throws IOException { return Channels.newChannel(this.getInputStream()); } long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; @Nullable String getFilename(); //获取资源描述信息 String getDescription();} 它继承了InputStreamSource 接口 1234public interface InputStreamSource { //定位并打开资源，每次调用返回一个新的输入流 InputStream getInputStream() throws IOException;} Spring内部大量使用Resource，有如下内置实现： UrlResource ClassPathResource FileSystemResource PathResource ServletContextResource InputStreamResource ByteArrayResource 上面每种Resource的内置实现都支持将路径转化为 java.net.URL 1、UrlResourceUrlResource内部包装了一个类型为java.net.URL的url属性，它用来访问任何可以通过url访问的对象，通过标准化的字符串前缀来表示资源类型： file：用于访问文件系统路径； https：同于通过https协议访问资源； ftp：通过ftp访问资源； UrlResource是通过构造函数来创建的。通常会在调用api方法时隐式创建，此时PropertyEditor会根据前缀创建适当的资源，如果前缀不能识别，则会假定该前缀是个标准url字符串并创建一个UrlResource 2、ClassPathResourceClassPathResource类表示从类路径获取资源。使用线程上下文加载器和给定的加载器或给定的资源加载类进行加载。ClassPathResource支持将资源的类路径在文件系统中的资源解析为java.io.File。但不支持资源的类路径位于jar包中且没有拓展到文件系统中的资源，此时只能解析为 java.net.URL。通过构造函数创建ClassPathResource时会检查classpath:前缀，如果识别到了，就创建ClassPathResource 3、FileSystemResourceFileSystemResource类内部包装了java.io.File类，也支持java.nio.file.Path类，内部的方法都是通过File类的api方法实现的。解析路径一般可以使用绝对路径和相对路径，绝对路径是相对于文件系统的根目录，而相对路径是相对于当前工作目录，但FileSystemResource中无论开头有没有/，都将路径视为相对路径，，所以加与不加/没什么区别。如果确实需要使用绝对路径，应该避免使用FileSystemResource，或者使用file:前缀强制使用UrlResource 1ctx.getResource(&quot;file:/src/main/resources/test.properties&quot;); 4、PathResourcePathResource与FileSystemResource类似，但它内部是纯java.nio.file.Path实现的，通过Path类的api实现操作和转换 5、ServletContextResource这是ServletContext 资源的Resource实现，它解析web应用根目录中的相对路径。如果web应用程序被扩展并且资源位于文件系统上时，他始终支持流访问和url访问。它是否被扩展并在文件系统上或直接从 JAR 或其他地方（如数据库）访问实际上取决于 Servlet 容器 6、InputStreamResourceInputStreamResource 是给定 InputStream 的资源实现。仅当没有特定的资源实现适用时才应使用它。尽可能首选 ByteArrayResource 或任何基于文件的资源实现。与其他 Resource 实现相比，这是一个已打开资源的描述符。因此，它从 isOpen() 返回 true。如果您需要将资源描述符保存在某处或需要多次读取流，请不要使用它 7、ByteArrayResource这是给定字节数组的资源实现。它为给定的字节数组创建一个 ByteArrayInputStream ResourceLoader 接口ResourceLoader 接口用来返回Resource实例对象 12345678public interface ResourceLoader { String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;; Resource getResource(String location); @Nullable ClassLoader getClassLoader();} 所有应用程序上下文都实现了ResourceLoader接口，随意可以直接通过应用上下文你对象获取Resource实例 12ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;test.xml&quot;);Resource resource = ctx.getResource(&quot;test.properties&quot;); 不同上下文获取的resource类型不同 ClassPathXmlApplicationContext：ClassPathResource FileSystemXmlApplicationContext：FileSystemResource WebApplicationContext：ServletContextResource 可以通过指定前缀强制使用对应的Resource 前缀 例子 说明 classpath: classpath:com/myapp/config.xml 从类路径加载 file: file:///data/config.xml 从文件系统加载 https: https://myserver/logo.png 加载为url 无 /data/config.xml 取决于使用的ApplicationContext ResourcePatternResolver 接口1、接口说明ResourcePatternResolver接口是ResourceLoader接口的扩展接口它定义了将位置模式转化为Resource转化为Resource对象 12345public interface ResourcePatternResolver extends ResourceLoader { String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;; Resource[] getResources(String locationPattern) throws IOException;} 接口中定义了一个classpath*:资源前缀，并且getResources()方法返回的是一个Resource数组。 ApplicationContext 中默认的ResourceLoader 实际上是PathMatchingResourcePatternResolver 的一个实例。 1public class PathMatchingResourcePatternResolver implements ResourcePatternResolver {...} PathMatchingResourcePatternResolver是一个独立的实现，可在ApplicationContext外部使用，并且可以通过使用ResourceArrayPropertyEditor填充Resource[]的bean属性。PathMatchingResourcePatternResolver 能够将指定的资源位置路径解析为一个或多个匹配的资源对象。 资源路径可能是一对一的简单路径，也可能是包含classpath*:前缀内部 Ant 样式模式的特殊路径。 2、通配符【1】classpath* 前缀classpath* 前缀表示类路径中的JAR文件或不同目录可以包含多个同路径同名文件。也就是说classpath*:会搜索当前类路径和jar包中的类路径，而classpath:只会搜索当前项目的类路径。 1ctx.getResource(&quot;classpath*:conf/appContext.xml&quot;); 【2】Ant 风格当路径位置包含 Ant 样式模式时遵循最长匹配原则，并且可使用如下通配符 ?：匹配任意一个字符 *：匹配零个、一个、多个字符 **：匹配零个、一个、多个目录 补充： 当classpath*与Ant一起使用时，在模式开始之前，至少要与一个根目录匹配，否则只会查找文件系统。例如声明为classpath*:*.xml时可能不会从jar根目录中检索文件 ResourceLoaderAware 接口ResourceLoaderAware 接口用于将ResourceLoader保存到bean中 123public interface ResourceLoaderAware extends Aware { void setResourceLoader(ResourceLoader resourceLoader);} 当一个类实现ResourceLoaderAware接口并注册到容器中，在上下文启动时会自动调用setResourceLoader()方法，并将自己作为参数传递进去。也可以通过@Autowired进行注入，当路径包含classpath*:前缀时应优先使用@Autowired","link":"/2020/07/25/language/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"title":"Spring 核心功能：面向切面编程（AOP）","text":"Spring AOP 是spring提供的一种AOP实现，目的不是提供最完整的 AOP 实现，而是提供 AOP 实现和Spring IOC之间的紧密集成。如果需要使用全面的AOP解决方案可以使用AspectJ。Spring IOC和Spring AOP可以与AspectJ无缝集成。另外Spring可以使用@AspectJ注解和模式两种方式配置AOP AOP概念AOP术语Advice（通知）：将要增加的功能，是织入到目标类连接点上的一段程序代码； Pointcut（切入点）：需要增强的方法集，可能包括多个连接点； Aspect（切面）：通知与切入点的结合； Join point（连接点）：使用通知的地方，spring中指方法的执行； introduction（引入）：引入是一种特殊的通知，它为类添加一些属性和方法； Target object（目标对象）：增强逻辑的织入目标类； AOP proxy（代理）：一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类； Weaving（织入）：把通知应用到目标对象来创建新的代理对象的过程； spring 通知类型 前置通知：连接点之前执行 返回通知：连接点正常执行完毕后（没有异常发生） 异常通知：方法抛出异常退出时执行 后置通知：无论连接点退出后执行（无论是异常还是返回），相当于finally 环绕通知：自定义通知，提供了全方位功能的通知类型 注解方式和xml文件形式通知的执行顺序不同，注解方式环绕通知是在外层，而xml方式的环绕通知在内层。上面只有返回通知没有异常通知是因为环绕通知里写了try-catch 注解通知的执行顺序为： 环绕前置 前置通知 连接点方法 返回通知/异常通知 后置通知 环绕返回/环绕异常 环绕后置 xml配置通知的执行顺序为： 前置通知 环绕前置 连接点方法 环绕返回/环绕异常 环绕后置 后置通知 返回通知/异常通知 基于注解配置AOP引入依赖Maven 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt; Gradle 1todo 启动@AspectJ支持@AspectJ是AspectJ 5的一部分，Spring使用AspectJ提供的用于切入点解析和匹配的库来解释与AspectJ 5相同的注释。不过，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ Java 配置添加@EnableAspectJAutoProxy 注释 12345@Configuration@EnableAspectJAutoProxypublic class AppConfig {} XML 配置1&lt;aop:aspectj-autoproxy/&gt; 需要在 &lt;beans&gt;中加入 12345678910111213141516&lt;!--必须包含--&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;!--完整配置如下--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 相关注解 @Aspect：声明切面 @Pointcut：声明切入点参数是一个切入点表达式 @DeclareParents：声明引入（introduction） @Before：前置通知 @AfterReturning：返回通知 @AfterThrowing：异常通知 @After：后置通知 @Around：环绕通知 @Pointcut内部接切入点表达式，advice的相关通知注解可以直接写切入点表达式，也可以时对命名切入点的简单引用（切入点方法的全限定名），每个通知都可以注入参数，具体可以看注解的声明，示例代码中会进行演示 切入点表达式切入点表达式中可以使用以下指示符： execution：用于匹配方法，格式如下 1execution([访问修饰符] 返回值类型 [类型].方法名称(参数类型列表) [抛出异常模式]) within：用于匹配指定的类的所有方法 1within(类型) this：this指代理对象，匹配指定类型的子代理对象类的所有方法 1this(类型) target：target指目标对象，匹配指定类型的子类（非代理类）的所有方法 1target(类型) args：用于匹配指定参数列表方法 1args(参数类型/参数名称) @within：用于匹配标记指定注解的类型的所有方法 1@within(注解类型) @target：用于匹配持有指定注解的对象的所有方法 1@target(注解类型) @args：匹配运行时传入的参数的类型持有指定注解的方法 1@args(注解类型列表) @annotation：匹配持有指定注解的方法 1@args(注解类型) 多个切入点表达式之间可使用以下操作符： &amp;&amp; || ! 切入点表达式通配符： *：匹配任何数量字符。*在参数中表示一个任意类型的参数； ..：匹配任何数量字符的多个部分。在类型中表示匹配任何数量子包；(..)可以匹配任意个参数的方法； +：匹配指定类型的子类型，仅能作为后缀放在类型模式后边； 切入点对象在任何使用通知注解标记的方法上可以直接将JoinPoint、ProceedingJoinPoint、JoinPoint.StaticPart作为参数注入。通过切入点对象可以获取aop相关的对象，用法如下 1234567891011@Before(value = &quot;pointCut(p1,p2)&quot;)public void doBefore(JoinPoint jp,Object bean,String p2,String p1) { //获取方法参数 Object[] args = jp.getArgs(); //获取代理对象 Object aThis = jp.getThis(); //获取目标对象 Object target = jp.getTarget(); //获取方法通知的描述信息 Signature signature = jp.getSignature();} 绑定参数args()切入点表达式有两个目的，其一是限制方法的参数列表，二是当使用参数名称代替参数类型时，声明的参数列表中的参数可以传递到通知方法中 12@Pointcut(value = &quot;execution(* test.aop.Cat.cry(String,String)) &amp;&amp; args(p1,p2)&quot;)private void pointCut(String p1,String p2) {...} 代理对象 ( this)、目标对象 ( target) 和注释 ( @within、 @target、@annotation和@args) 都可以以类似的方式绑定，只不过他们绑定的参数不是目标方法参数，而是他们对应的对象，比this就是代理对象。另外切入点对象直接作为参数即可不需要特别配置 12@Around(value = &quot;test.aop.MyAspect.pointCut(p1,p2) &amp;&amp; this(proxy) &amp;&amp; @annotation(myAuditable)&quot;)public void doAround(ProceedingJoinPoint pjp, String p1, String p2, Object proxy, Auditable myAuditable) throws Throwable {...} argNames属性用来指定参数的顺序，如果不使用这个属性，参数可以随意放置，只要名字和通知声明的一样就可以匹配到。如果使用这个属性，那么参数就必须和该属性声明的顺序一致 12@Before(value = &quot;pointCut(p1,p2) &amp;&amp; target(bean) &quot;,argNames = &quot;jp,bean,p2,p1&quot;)public void doBefore(JoinPoint jp,Object bean,String p2,String p1) {...} 声明引入使用@DeclareParents声明引入 1234567891011@Retention(RetentionPolicy.RUNTIME)//作用在字段上@Target({ElementType.FIELD})public @interface DeclareParents { //类型模式 String value(); //接口的实现类 Class defaultImpl() default DeclareParents.class;} 他作用在一个字段上，这个字段需要是一个接口，注解内部的defaultImpl时该接口的一个实现类 123456789101112131415@Aspectpublic class UsageTracking { //value中是却如点的类型 //DefaultMyInterface是MyInterface的子类 @DeclareParents(value=&quot;test.aop.*+&quot;, defaultImpl=DefaultMyInterface.class) //MyInterface是自定义接口 public static MyInterface mixin; @Before(&quot;com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)&quot;) public void recordUsage(UsageTracked usageTracked) { usageTracked.incrementUseCount(); }} 示例代码被代理类 12345678910111213@Componentpublic class Cat{ private String name; @Auditable(&quot;注解value&quot;) public String cry(String p1,String p2){ System.out.println(&quot;喵喵叫&quot;); if(p1.length()&gt;0){ throw new RuntimeException(&quot;出现异常&quot;); } return p1+&quot;:&quot;+p2; }} 自定义注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable { String value();} 切面编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//声明切面@Aspect//注入ioc容器@Componentpublic class MyAspect { //切入点 @Pointcut(value = &quot;execution(* test.aop.Cat.cry(String,String)) &amp;&amp; args(p1,p2)&quot;) private void pointCut(String p1,String p2) { } //前置通知 @Before(value = &quot;pointCut(p1,p2) &amp;&amp; target(bean) &quot;,argNames = &quot;jp,bean,p2,p1&quot;) public void doBefore(JoinPoint jp,Object bean,String p2,String p1) { //获取方法参数 Object[] args = jp.getArgs(); //获取代理对象 Object aThis = jp.getThis(); //获取目标对象 Object target = jp.getTarget(); //获取方法通知的描述信息 Signature signature = jp.getSignature(); System.out.println(&quot;前置通知-&gt;参数为：p1=&quot;+p1+&quot;,p2=&quot;+p2); } //返回通知 @AfterReturning( value = &quot;test.aop.MyAspect.pointCut(p1,p2)&quot;, returning = &quot;retVal&quot;) public void doReturn(Object retVal,String p1,String p2) { System.out.println(&quot;返回通知-&gt;返回值为：&quot; + retVal); } //异常通知 @AfterThrowing( value = &quot;test.aop.MyAspect.pointCut(p1,p2)&quot;, throwing = &quot;ex&quot;) public void doThrowing(Exception ex,String p1,String p2) { System.out.println(&quot;异常通知-&gt;异常为：&quot; + ex); } //后置通知 @After(&quot;test.aop.MyAspect.pointCut(p1,p2)&quot;) public void doAfter(String p1,String p2) { System.out.println(&quot;后置通知&quot;); } //环绕通知 @Around(value = &quot;test.aop.MyAspect.pointCut(p1,p2) &amp;&amp; this(proxy) &amp;&amp; @annotation(myAuditable)&quot;) public void doAround(ProceedingJoinPoint pjp, String p1, String p2, Object proxy, Auditable myAuditable) throws Throwable { //注释的value String value = myAuditable.value(); try { System.out.println(&quot;环绕前置&quot;); Object retVal = pjp.proceed(); System.out.println(&quot;环绕返回-&gt;返回值为：&quot; + retVal); }catch (Exception e){ System.out.println(&quot;环绕异常-&gt;异常为：&quot; + e); }finally { System.out.println(&quot;环绕后置&quot;); } }} 执行结果 123456789101112131415环绕前置前置通知-&gt;参数为：p1=参数1,p2=参数2喵喵叫返回通知-&gt;返回值为：参数1参数2后置通知环绕返回-&gt;返回值为：参数1参数2环绕后置 环绕前置前置通知-&gt;参数为：p1=参数1,p2=参数2喵喵叫异常通知-&gt;异常为：java.lang.RuntimeException: 出现异常后置通知环绕异常-&gt;发生异常：java.lang.RuntimeException: 出现异常环绕后置 通知的执行顺序为： 环绕前置 前置通知 连接点方法 返回通知/异常通知 后置通知 环绕返回/环绕异常 环绕后置 基于xml配置AOP基于模式就是基于xml标签的形式配置aop 引入依赖123456&lt;!--springIOC的包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 启动aop支持如论是使用模板形式还是使用注解形式都需要引入aop命名空间 12345678910111213141516&lt;!--必须包含--&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;!--完整配置如下--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 相关配置 &lt;aop:config&gt;：所有切面和通知的配置都要放在&lt;aop:config&gt;标签内 &lt;aop:pointcut&gt;：声明切入点，可以声明在&lt;aop:config&gt;和&lt;aop:aspect&gt;中 &lt;aop:aspect&gt;：声明切面， ref：表示引入的切面bean order：当有多个通知指向一个连接点时通过order指定执行顺序，值越小越先执行 关于切入点表达式等查看上一节相关部分。关于每个标签用法查看下一节的示例代码 通知标签属性所有通知标签的公共属性如下： method：通知方法 pointcut-ref：引用已声明切入点id pointcut：内联切入点表达式，不能与pointcut-ref一起使用 arg-names：同argNames，定义参数顺序 通知标签特殊属性如下： &lt;aop:before&gt;：前置通知 &lt;aop:after-returning&gt;：返回通知 returning：返回值参数名，通知方法必须声明一个为该名称的参数 &lt;aop:after-throwing&gt;：异常通知 throwing：异常参数名，通知方法必须声明一个为该名称的参数 &lt;aop:after&gt;：后置通知 &lt;aop:around&gt;：环绕通知，通知方法的第一个参数必须是ProceedingJoinPoint 另外&lt;aop:after-throwing&gt;和&lt;aop:after-throwing&gt;分别有和用于声明异常和返回值参数名 声明引入使用&lt;aop:declare-parents&gt;声明引入 12345&lt;aop:declare-parents types-matching=&quot;类型模式&quot; implement-interface=&quot;接口&quot; default-impl=&quot;接口实现&quot; delegate-ref=&quot;属性名称&quot;/&gt; advisor通过&lt;aop:advisor&gt;声明advisor，这是xml配置所独有的。advisor相当于一个独立的切面，只有一条通知。其属性包括 pointcut-ref：切入点引用 pointcut：切入点表达式 advice-ref：通知引用 order：定义Ordered值，越小优先级越高 12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id=&quot;businessService&quot; expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt; &lt;aop:advisor pointcut-ref=&quot;businessService&quot; advice-ref=&quot;tx-advice&quot;/&gt;&lt;/aop:config&gt;&lt;tx:advice id=&quot;tx-advice&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 示例代码被代理类 12345678910111213@Componentpublic class Cat{ private String name; @Auditable(&quot;注解value&quot;) public String cry(String p1,String p2){ System.out.println(&quot;喵喵叫&quot;); if(p1.length()&gt;0){ throw new RuntimeException(&quot;出现异常&quot;); } return p1+&quot;:&quot;+p2; }} 自定义注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Auditable { String value();} 切面代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyAspect { //前置通知 public void doBefore(JoinPoint jp,Object bean,String p2,String p1) { //获取方法参数 Object[] args = jp.getArgs(); //获取代理对象 Object aThis = jp.getThis(); //获取目标对象 Object target = jp.getTarget(); //获取方法通知的描述信息 Signature signature = jp.getSignature(); System.out.println(&quot;前置通知-&gt;参数为：p1=&quot;+p1+&quot;,p2=&quot;+p2); } //返回通知 public void doReturn(Object retVal,String p1,String p2) { System.out.println(&quot;返回通知-&gt;返回值为：&quot; + retVal); } //异常通知 public void doThrowing(Exception ex,String p1,String p2) { System.out.println(&quot;异常通知-&gt;异常为：&quot; + ex); } //后置通知 public void doAfter(String p1,String p2) { System.out.println(&quot;后置通知&quot;); } //环绕通知 public void doAround(ProceedingJoinPoint pjp, String p1, String p2, Object proxy, Auditable myAuditable) throws Throwable { //注释的value String value = myAuditable.value(); try { System.out.println(&quot;环绕前置&quot;); Object retVal = pjp.proceed(); System.out.println(&quot;环绕返回-&gt;返回值为：&quot; + retVal); }catch (Exception e){ System.out.println(&quot;环绕异常-&gt;发生异常：&quot; + e); }finally { System.out.println(&quot;环绕后置&quot;); } }} xml配置 12345678910111213141516171819&lt;!--切面类--&gt;&lt;bean id=&quot;myAspectBean&quot; class=&quot;test.aop.MyAspect&quot;/&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;myPointCut&quot; expression=&quot;execution(* test.aop.Cat.cry(String,String)) and args(p1,p2)&quot;/&gt; &lt;!--切面--&gt; &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;myAspectBean&quot;&gt; &lt;!--前置通知--&gt; &lt;aop:before method=&quot;doBefore&quot; pointcut=&quot;execution(* test.aop.Cat.cry(String,String)) and args(p1,p2) and target(bean)&quot; arg-names=&quot;jp,bean,p2,p1&quot;/&gt; &lt;!--返回通知--&gt; &lt;aop:after-returning method=&quot;doReturn&quot; pointcut-ref=&quot;myPointCut&quot; returning=&quot;retVal&quot;/&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method=&quot;doThrowing&quot; pointcut-ref=&quot;myPointCut&quot; throwing=&quot;ex&quot;/&gt; &lt;!--后置通知--&gt; &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;myPointCut&quot;/&gt; &lt;!--环绕通知--&gt; &lt;aop:around method=&quot;doAround&quot; pointcut=&quot;execution(* test.aop.Cat.cry(String,String)) and args(p1,p2) and this(proxy) and @annotation(myAuditable)&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 执行结果 123456789101112131415前置通知-&gt;参数为：p1=参数1,p2=参数2环绕前置喵喵叫环绕异常-&gt;发生异常：java.lang.RuntimeException: 出现异常环绕后置后置通知返回通知-&gt;返回值为：null前置通知-&gt;参数为：p1=参数1,p2=参数2环绕前置喵喵叫环绕返回-&gt;返回值为：参数1参数2环绕后置后置通知返回通知-&gt;返回值为：null 通知的执行顺序为： 前置通知 环绕前置 连接点方法 环绕返回/环绕异常 环绕后置 后置通知 返回通知/异常通知 代理机制spring aop使用jdk和cglib两种方式实现动态代理，如果目标对象至少实现了一个接口，则使用jdk代理，如果类没有实现任何接口，则使用cglib代理。可以使用如下配置强行使用cglib代理 123456&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;!-- other beans defined here... --&gt;&lt;/aop:config&gt;&lt;!--要在使用 @AspectJ 自动代理支持时强制 CGLIB 代理--&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; 说明： 使用cglib，方法不能被final修饰，因为生成的子类无法覆盖该方法 方法自调在被代理方法中如果调用类内其他方法，那么被调用方法不是被代理的，这叫做自调。如果希望解决自调，可以通过更改被代理类代码的方式 123this.方法()//改为((被代理类) AopContext.currentProxy()).方法(); 创建代理&lt;aop:config&gt;方式123456789101112//创建代理工厂ProxyFactory factory = new ProxyFactory(new target());//添加被代理类实现接口factory.addInterface(targetUInterface.class);//添加通知factory.addAdvice(new myAdvice());//设置被代理类方法内部调用代理factory.setExposeProxy(true);//获取代理对象Pojo pojo = (target) factory.getProxy();//调用方法代理pojo.theMethod(); &lt;aop:aspectj-autoproxy&gt;方式12345678910//创建根据给定的targetObject创建代理的工厂AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);//添加一个被@AspectJ修饰的切面factory.addAspect(SecurityManager.class);//也可以添加切面的实例factory.addAspect(usageTracker);//获取代理对象MyInterfaceType proxy = factory.getProxy(); 事务使用@Transactional注解可以开启事务，底层是通过aop代理实现的 可以声明在类上和方法上 声明在类上表示该类的任何公共操作都使用事务 声明在方法上会覆盖声明在类上的事务语义 使用 AspectJtode Spring AOP API切入点核心接口切入点的核心接口如下 12345678910111213141516171819202122232425262728293031323334public interface Pointcut { Pointcut TRUE = TruePointcut.INSTANCE; //匹配部分 ClassFilter getClassFilter(); //细粒度组合操作 MethodMatcher getMethodMatcher();}//用于将切入点限制为给定的一组目标类@FunctionalInterfacepublic interface ClassFilter { ClassFilter TRUE = TrueClassFilter.INSTANCE; //如果该matches()方法始终返回 true，则所有目标类都匹配 boolean matches(Class&lt;?&gt; clazz);}public interface MethodMatcher { MethodMatcher TRUE = TrueMethodMatcher.INSTANCE; //用于测试此切入点是否曾经匹配目标类上的给定方法，可以在创建aop代理时评估 boolean matches(Method method, Class&lt;?&gt; targetClass); //如果MethodMatcher实现时静态的，则返回false boolean isRuntime(); //如果双参数匹配方法返回 true，isRuntime()方法返回true， //则在每次方法调用时都会调用三参数匹配方， //这让切入点在目标通知开始之前立即查看传递给方法调用的参数 boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args);} tode","link":"/2020/03/18/language/Java/Spring/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%88AOP%EF%BC%89/"},{"title":"Spring 注解：@ControllerAdvice","text":"@ControllerAdvice 是 Spring3.2 提供的新注解，用来修饰一个类，在 Spring Boot 中可以搭配其他三个注解（@ExceptionHandler、@ModelAttribute、@InitBinder）使用。 可以用来实现以下几个功能： 全局异常处理 全局数据绑定 全局数据预处理 全局异常处理（@ExceptionHandler）12345678910@ControllerAdvicepublic class MyGlobalHandler { @ExceptionHandler(Exception.class) public ModelAndView customException(Exception e) { ModelAndView mv = new ModelAndView(); mv.addObject(&quot;message&quot;, e.getMessage()); mv.setViewName(&quot;myerror&quot;); return mv; }} 在该类中，可以创建多个方法，每个方法上添加@ExceptionHandler注解，参数填入异常的类型，这样就可以实现不同异常的全局处理。 全局数据绑定（@ModelAttribute）123456789@ControllerAdvicepublic class MyGlobalHandler { @ModelAttribute(name = &quot;keyName&quot;) public Map&lt;String,Object&gt; mydata() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;张三&quot;); return map; }} 被 @ModelAttribute 注解所标记方法的返回值是一个全局数据，可以在全局的其他地方获取到，默认全局数据的 key 就是返回的变量名，value 是方法返回值，如果想自定义key可以通过 @ModelAttribute 的name属性指定。 定义完成后，在任何一个Controller 的接口中，都可以获取到上面定义的数据： 123456789@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(Model model) { Map&lt;String, Object&gt; map = model.asMap(); System.out.println(map); return &quot;hello controller advice&quot;; }} 全局数据预处理（@InitBinder）在进行开发时前台发送请求到后台时经常会遇到的一种情况就是传过来的数据要组装成一种对象的格式，@InitBinder 注解可以对HTTP请求参数进行预处理，再绑定到对应的接口。这里我们就可以对参数做一些额外的处理，比如时间格式的转换等。 123456789@ControllerAdvicepublic class MyGlobalHandler { @InitBinder public void bindingPreparation(WebDataBinder binder) { DateFormat dateFormat = new SimpleDateFormat(&quot;MMM d, YYYY&quot;); CustomDateEditor orderDateEditor = new CustomDateEditor(dateFormat, true); binder.registerCustomEditor(Date.class, orderDateEditor); } } 对于request传递的简单数据类型（String、int、float等）springmvc可以自动的进行属性绑定，但复杂类型的却不行，WebDataBinder类可以用来绑定数据与属性解析器（PropertiesEditor），实现复杂属性的绑定。上述代码中的CustomDateEditor就是一个PropertiesEditor用于解析Date类型的数据。 当需要实现不同的实体类中要求的Date格式不同的需求时，可以如下配置： 123456789@InitBinder public void bindingPreparation(WebDataBinder binder) { DateFormat dateFormat1 = new SimpleDateFormat(&quot;d-MM-yyyy&quot;); CustomDateEditor orderDateEditor = new CustomDateEditor(dateFormat1, true); DateFormat dateFormat2 = new SimpleDateFormat(&quot;MMM d, YYYY&quot;); CustomDateEditor shipDateEditor = new CustomDateEditor(dateFormat2, true); binder.registerCustomEditor(Date.class, &quot;orderDate&quot;, orderDateEditor); binder.registerCustomEditor(Date.class, &quot;shipDate&quot;, shipDateEditor); } 只要为每个变量绑定一个不同的Editor就可以了，对于不同的变量进行不同的处理。","link":"/2021/04/24/language/Java/Spring/Spring%E6%B3%A8%E8%A7%A3%EF%BC%9A@ControllerAdvice/"},{"title":"Kubernetes 部署","text":"Kubernetes部署方式 Minikube部署安装过程Minikube用于部署单节点K8s集群，需要先安装完docker 123456789101112131415161718192021# 安装 minikube，使用rpm包安装$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm$ sudo rpm -Uvh minikube-latest.x86_64.rpm# 验证安装$ minikube version# 安装 kubectl$ minikube kubectl# 启动，可以自己指定版本，镜像国家cn默认从阿里云拉取镜像$ minikube start --kubernetes-version=v1.23.3 --image-mirror-country='cn'# $ minikube kubectl -- get pods -A# 设置别名$ vim .bashrc# 在文件末尾添加：alias kubectl=&quot;minikube kubectl&quot;$ source .bashrc# 验证$ kubectl get nodes# 配置命令补全$ sudo dnf install bash-completion$ source /usr/share/bash-completion/bash_completion$ source &lt;(kubectl completion bash) 接下来就可以使用kubectl命令进行操作了","link":"/2022/09/17/tools/Kubernetes/Kubernetes%E9%83%A8%E7%BD%B2/"},{"title":"Hadoop 部署","text":"Hadoop部署方式 需要事先下载好java1.8版本，版本太高可能有问题，这里推荐下载jre1.8，我第一次下载同版本jdk1.8后启动hadoop会警告（但运行正常） 单机部署安装过程123456789101112131415# 首先在官网下载hadoop，然后进行解压$ tar -zxvf hadoop-x.x.x.tar.gz# 移动到/opt/hadoop$ sudo mv hadoop/ /opt/hadoop/$ cd /opt/hadoop# 修改所有者和组$ sudo chown -R zcy:zcy hadoop/# 接下来编写配置文件# 进入配置文件目录$ cd /opt/hadoop/hadoop-3.3.4/etc/hadoop/# 配置hadoop环境变量$ vim hadoop-env.sh# 事先下载好的java1.8export JAVA_HOME=/opt/hadoop/jre1.8.0_341$ source hadoop-env.sh 接下来在该目录下配置Hadoop的配置文件，各个文件配置如下 core-site.xml（需要更改hadoop.tmp.dir路径） 123456789101112&lt;configuration&gt; &lt;!-- 用来指定hdfs的老大（NameNode）的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 用来指定Hadoop运行时产生文件的存放目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hadoop-3.3.4/data/&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml （无需更改） 123456789101112&lt;configuration&gt; &lt;!-- 指定HDFS保存数据副本数量 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;!-- 是否开启权限检查 --&gt; &lt;property&gt; &lt;name&gt;dfs.permissions.enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml（无需更改） 1234567891011121314151617181920212223&lt;configuration&gt; &lt;!-- 告诉hadoop以后MR运行在yarn上 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt; &lt;/property&gt; &lt;!-- 历史服务器端地址 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;localhost:10020&lt;/value&gt; &lt;/property&gt; &lt;!-- 历史服务器 web 端地址 --&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;localhost:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml（无需更改） 12345678910111213141516&lt;configuration&gt; &lt;!-- NodeManager获取数据的方式是shuffle--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定YARN的老大（resourcemanager）的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_HOME,PATH,LANG,TZ,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 最后配置环境变量和启动Hadoop 1234567891011121314# 配置环境变量# 回到家目录$ cd $ vim .bash_profile# hadoop环境变量export HADOOP_HOME=&quot;/opt/hadoop/hadoop-3.3.4&quot; #自己hadoop的目录位置export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin$ source .bash_profile# 初始化$ hdfs namenode -format# 启动$ start-dfs.sh$ start-yarn.sh 通过访问以下两个网址确定是否开启成功： hdfs可视化界面 http://localhost:9870/ yarn可视化界面 http://localhost:8088/ mapred –daemon start historyserver 开启历史服务打开配置文件 mapred-site.xml 添加如下内容 1234567891011&lt;!-- 历史服务器端地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;localhost:10020&lt;/value&gt;&lt;/property&gt;&lt;!-- 历史服务器 web 端地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;localhost:19888&lt;/value&gt;&lt;/property&gt; 配置完后在yarn页面点击任务的history可能无法跳转，因为默认是根据hostname代理的，需要先将hostname改为localhost（可以先使用hostname命令确认一下） 123456789101112# 修改hosts文件，配置hostname$ sudo vim /etc/hosts# 设置hostnameHOSTNAME=localhost# 设置hostname$ sudo hostname localhost# 重启终端# 重启hadoop$ stop-all.sh$ start-all.sh# 启动历史服务器$ mapred --daemon start historyserver 开启日志聚集打开配置文件 mapred-site.xml 添加如下内容 1234567891011121314&lt;property&gt; &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置日志聚集服务器地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://localhost:19888/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置日志保留时间为 7 天 --&gt;&lt;property&gt; &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt; &lt;value&gt;604800&lt;/value&gt;&lt;/property&gt; 配置完后重启历史服务器和yarn 1234$ mapred --daemon stop historyserver$ stop-yarn.sh$ stop-yarn.sh$ mapred --daemon start historyserver 总体验证使用hadoop提供的示例程序验证功能是否都正常 123456789101112# 创建wordcount，填入内容$ vim wordcounthahalalaheiheiheiheihiehiegaga# 将wordcount上传到hdfshdfs dfs -put wordcount /wcoutput# 执行任务$ hadoop jar /opt/hadoop/hadoop-3.3.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.4.jar wordcount /wordcount /wcoutput 然后进入 http://localhost:8088/ 界面可以看到进行中的任务，等任务执行完毕后点击后面的 history，如果跳转成功，说明历史服务启动成功。接着在跳转到的界面点击中间那栏最右边的logs，如果跳转成功，说明日志聚集开启成功","link":"/2022/09/27/language/Java/Hadoop/Hadoop%E9%83%A8%E7%BD%B2/"},{"title":"Scrapy 基础知识","text":"介绍scrapy框架核心租价、基本命令、代码编写、以及各个组件的执行顺序 Scrapy 基础知识常用命令如果没有安装过scrapy应先执行 1$ pip install scrapy 创建爬虫工程该命令会在spiders下新建爬虫文件 1$ scrapy startproject 工程名 举例： 1$ scrapy genspider bilibili_test 创建爬虫文件该命令会在spiders下新建爬虫文件 1$ scrapy genspider 爬虫文件名 目标网站 举例： 1$ scrapy genspider bilibili www.bilibili.com 执行爬虫该命令会在spiders下新建爬虫文件 1$ scrapy crawl 爬虫文件名(不需要后缀) 参数： **–nolog:**不输出日志 **-o:**将parse()方法的返回值存储到指定输出文件，可以选择下列文件格式： csv json xml jl jsonlines marshal pickle 举例： 1$ scrapy crawl bilibili 项目结构创建爬虫工程后得到目录结构如下; 1234567891011- 工程名: spiders: #爬虫文件目录 __init__.py 爬虫文件.py #爬虫网站数据以及数据解析逻辑，将数据封装成item __init__.py items.py #数据封装对象 middlewares.py pipelines.py #管道，用于处理item类型对象，进行持久化 settings.py #爬虫配置- main.py- scrapy.cfg 项目包含的py文件中初始化了对应的类，在这些类中实现重写相应方法的逻辑代码，scrapy会按照顺序调用这些方法 核心组件 上面组件包括： 引擎(Scrapy Engine)：用来处理整个系统的数据流处理, 触发事务(框架核心)； 调度器(Scheduler)：用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址； 下载器(Downloader)：用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)； 爬虫(Spiders)：爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面； 项目管道(Pipeline)：负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据； 代码编写代码编写流程如下: 编写item用于封装解析到的数据； 编写spider用于指定访问的url和解析请求到的数据并将数据封装成item对象； 编写pipeline用于对item进行处理，一般是持久化； 编写middleware，一般用于配置代理以及user-agent等； 数据封装对象根据自身需求定义item类，封装需要的数据 下面例子是将文章封面图的link以及文章的title封装成item 12345678910# 封装文章数据class ArticleItem(scrapy.Item): # 属性的定义方式如下: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field()# 封装文章图片地址class ArticleImageItem(scrapy.Item): src = scrapy.Field() 爬虫文件爬虫文件中定义了将要请求的url以及页面数据的解析逻辑 下面是用于爬取b站某页专栏的代码，省略了解析表达式和网址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class BilibiliSpider(scrapy.Spider): name = 'bilibili' allowed_domains = ['www.bilibili.com'] # url方式一：初始请求数组 # start_urls = ['https://www.xxx.com/xxx'] # url方式二：start_requests()方法发起请求 def start_requests(self): print('Spider--start_requests()') # 爬取多页数据 for page in range(1, 2): print('Spider--start_requests()--for') # 手动发起请求，每次请求一个url，使用模板字符串拼接页数 yield scrapy.Request(f'https://search.bilibili.com/article?vt=67519417&amp;keyword=%E5%A4%8F%E6%97%A5%E9%87%8D%E7%8E%B0&amp;from_source=webtop_search&amp;spm_id_from=333.1007&amp;search_source=2&amp;page={page}') def parse(self, response: HtmlResponse): print('Spider--parse()') list_items = response.css('body &gt; #server-search-app .body-contain .article-item') for list_item in list_items: article_item = ArticleItem() # css()和xpath()方法返回的是selector列表 # extract()方法将selector列表解析成字符串列表 # extract_first()方法将selector列表中第一个数据解析成字符串并返回该字符串 article_item['link'] = list_item.css('a img::attr(src)').extract_first() article_item['title'] = list_item.css('.content &gt;.headline&gt;a::attr(title)').extract_first() article_url = &quot;https:&quot; + list_item.css('.content &gt;.headline &gt; a::attr(href)').extract_first() print('Spider--parse()--for') # 将article_item信息发送到管道 yield article_item # 调用parse_article()方法解析详细信息 # 请求传惨：通过meta参数传递一个map，目标方法可以接收 yield scrapy.Request(article_url, self.parse_article_image, meta={'article_item': article_item}) # 自定义解析文章详情页的方法，用于提取图片 def parse_article_image(self, response): # 获取传递的参数 article_item = response.meta['article_item'] print(f&quot;获取文章《{article_item['title']}》的图片&quot;) figure_list = response.css('#article-content &gt; #read-article-holder figure') for figure_item in figure_list: image_url = &quot;https:&quot; + figure_item.css('::attr(data-src)').extract_first() image_item = ArticleImageItem() image_item['src'] = image_url yield image_item 管道需要先配置开启管道 1234567# 开启管道# 可以配置任意个管道类，会按照优先级从小到大进行执行ITEM_PIPELINES = { # 管道类全类名: 优先级 'bilibili_test.pipelines.MysqlPipeline': 300, 'bilibili_test.pipelines.ArticleImagePipeline': 301,} 下面定义了两个管道： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 将文章信息存储到mysql数据库class MysqlPipeline: # 数据库连接 conn = None # 数据库游标多谢 cursor = None # 该方法会在爬虫开始时被调用并且只会被调用一次 def open_spider(self, spider): print('mysql管道--open_spider()') self.conn = pymysql.Connect( host='127.0.0.1', port=3306, user='root', password='123456', db='scrapy_test', charset='utf8', ) # 接收爬虫文件传递过来的item对象 def process_item(self, item: ArticleItem, spider): print('mysql管道--process_item()') if not isinstance(item, ArticleItem): # 如果不是需要的类型，直接发送到下一个管道 return item # 写入文件 self.cursor = self.conn.cursor() # 插入到mysql try: self.cursor.execute('insert into article(title,link) values(&quot;%s&quot;,&quot;%s&quot;)' % (item[&quot;title&quot;], item[&quot;link&quot;])) self.conn.commit() except Exception as e: print(e) self.conn.rollback() return item # 爬虫结束后会调用一次 def close_spider(self, spider): print('mysql管道--close_spider()') self.conn.close()# 声明父类是ImagesPipeline# ImagesPipeline是scrapy提供的专门用于图片存储的管道类class ArticleImagePipeline(ImagesPipeline): # 根据图片地址进行图片数据的请求 def get_media_requests(self, item, info): print('图片下载管道--get_media_requests()') if not isinstance(item, ArticleImageItem): # 如果不是需要的类型，直接发送到下一个管道 return item # 获取图片 yield scrapy.Request(item['src']) # 指定文件存储位置 def file_path(self, request, response=None, info=None, *, item=None): print('图片下载管道--file_path()') imageName = request.url.split('/')[-1] return imageName # 用于该管道执行结束向下一个将要执行的管道传递数据 # 如果不需要传递数据，则这个方法可以不重写 def item_completed(self, results, item, info): print('图片下载管道--item_completed()') # 把当前的item传递给下一个管道类 return item 中间件需要先配置开启管道 123456789# 开启爬虫中间件SPIDER_MIDDLEWARES = { 'bilibili_test.middlewares.BilibiliTestSpiderMiddleware': 543,}# 开启下载中间件DOWNLOADER_MIDDLEWARES = { 'bilibili_test.middlewares.BilibiliTestDownloaderMiddleware': 543,} 中间件有两个 爬虫中间件 下载中间件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192proxy_ip_list = [ '47.92.113.71:80', '117.157.197.18:3128', '111.23.16.250:3128',]user_agent_list = [ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot; # ......]# 爬虫中间件class BilibiliTestSpiderMiddleware: @classmethod def from_crawler(cls, crawler): print('爬虫中间件--from_crawler()') s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_spider_input(self, response, spider): print('爬虫中间件--process_spider_input()') # 返回None或一个异常 # 如果是None,就继续调用其他的spider middleware。 # 如果是一个异常，调用request里的errback()方法，再抛出异常是交给process_spider_exception(response, exception, spider)处理 return None def process_spider_output(self, response, result, spider): print('爬虫中间件--process_spider_output()') # 必须返回一个包括request或item对象的可迭代对象 for i in result: yield i # 当spider或其他中间件的process_spider_input()报错时被调用 def process_spider_exception(self, response, exception, spider): print('爬虫中间件--process_spider_exception()') # 应该返回 None 或一个可迭代的 Request 或 item 对象 pass # 爬虫启动请求 def process_start_requests(self, start_requests, spider): print('爬虫中间件--process_start_requests()') # 只能返回request对象 for r in start_requests: yield r def spider_opened(self, spider): print('爬虫中间件--spider_opened()') spider.logger.info('Spider opened: %s' % spider.name)# 下载中间件class BilibiliTestDownloaderMiddleware: @classmethod def from_crawler(cls, crawler): # Scrapy 使用此方法来创建爬虫 print('下载中间件--from_crawler()') s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s # 拦截请求，当每个request通过下载中间件时，该方法被调用 def process_request(self, request, spider): print('下载中间件--process_request()') # 随机选择user-agent ua = random.choice(user_agent_list) # 设置请求的ua request.headers['User-Agent'] = ua return None # 拦截响应， def process_response(self, request, response, spider): print('下载中间件--process_response()') return response # 拦截发生异常的请求 def process_exception(self, request, exception, spider): print('下载中间件--process_exception()') # 请求失败就设置代理ip if request.url.split(':') == 'https': # 设置代理ip request.meta['proxy'] = 'https//' + random.choice(proxy_ip_list) else: request.meta['proxy'] = 'http//' + random.choice(proxy_ip_list) # 返回request会重新进行请求发送 return request def spider_opened(self, spider): print('下载中间件--spider_opened()') spider.logger.info('Spider opened: %s' % spider.name) 执行顺序下面的爬虫中间件和下载中间件均的优先级相同；下列执行步骤中如果定义了多个管道，则会按照设置的优先值从小到大执行，并且位置是相邻的 初始化执行部分： 下载中间件–from_crawler() 爬虫中间件–from_crawler() 管道–open_spider() 下载中间件–spider_opened() 爬虫中间件–spider_opened() 爬虫开始部部分： 爬虫中间件–process_start_requests() Spider--start_requests() Spider--start_requests()--for 下载中间件–process_request() 下载中间件–process_response() 爬虫中间件–process_spider_input() 爬虫中间件–process_spider_output() Spider--parse() Spider--parse()--for 管道process_item() Spider--parse()--for 管道–process_item() 下载中间件–process_request()（调用scrapy.Request()触发该方法） Spider--parse()--for ……","link":"/2022/09/24/language/Python/Scrapy/Scrapy%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"Hadoop 常用命令","text":"Hadoop部署方式","link":"/2022/09/27/language/Java/Hadoop/Hadoop%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"fedora","slug":"fedora","link":"/tags/fedora/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Fedora","slug":"Fedora","link":"/tags/Fedora/"},{"name":"包管理器","slug":"包管理器","link":"/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"SpringBootWeb框架集成","slug":"SpringBootWeb框架集成","link":"/tags/SpringBootWeb%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90/"},{"name":"SpringBoot数据库集成","slug":"SpringBoot数据库集成","link":"/tags/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90/"},{"name":"SpringBoot核心功能","slug":"SpringBoot核心功能","link":"/tags/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"},{"name":"SpringBoot源码解析","slug":"SpringBoot源码解析","link":"/tags/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Spring数据访问","slug":"Spring数据访问","link":"/tags/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"},{"name":"Spring核心功能","slug":"Spring核心功能","link":"/tags/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"},{"name":"Spring注解","slug":"Spring注解","link":"/tags/Spring%E6%B3%A8%E8%A7%A3/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"部署","slug":"部署","link":"/tags/%E9%83%A8%E7%BD%B2/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","link":"/categories/Linux/Ubuntu/"},{"name":"Fedora","slug":"Linux/Fedora","link":"/categories/Linux/Fedora/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"},{"name":"Spring","slug":"Java/Spring","link":"/categories/Java/Spring/"},{"name":"Spring Boot","slug":"Java/Spring-Boot","link":"/categories/Java/Spring-Boot/"},{"name":"Spring Boots","slug":"Java/Spring-Boots","link":"/categories/Java/Spring-Boots/"},{"name":"Spring MVC","slug":"Java/Spring-MVC","link":"/categories/Java/Spring-MVC/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Scrapy","slug":"Python/Scrapy","link":"/categories/Python/Scrapy/"},{"name":"Hadoop","slug":"Java/Hadoop","link":"/categories/Java/Hadoop/"}]}