<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面向对象 - 路由器</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="路由器"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="路由器"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="类、继承、扩展、委托、接口、泛型、抽象类、内联类、数据类、密封类、枚举类、单例、对象表达式、可见性修饰符"><meta property="og:type" content="blog"><meta property="og:title" content="面向对象"><meta property="og:url" content="http://example.com/2020/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta property="og:site_name" content="路由器"><meta property="og:description" content="类、继承、扩展、委托、接口、泛型、抽象类、内联类、数据类、密封类、枚举类、单例、对象表达式、可见性修饰符"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2020-10-17T16:00:00.000Z"><meta property="article:modified_time" content="2024-01-11T05:59:48.162Z"><meta property="article:author" content="路由器"><meta property="article:tag" content="编程语言"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},"headline":"面向对象","image":["http://example.com/img/og_image.png"],"datePublished":"2020-10-17T16:00:00.000Z","dateModified":"2024-01-11T05:59:48.162Z","author":{"@type":"Person","name":"路由器"},"publisher":{"@type":"Organization","name":"路由器","logo":{"@type":"ImageObject","url":"http://example.com/img/avatar.png"}},"description":"类、继承、扩展、委托、接口、泛型、抽象类、内联类、数据类、密封类、枚举类、单例、对象表达式、可见性修饰符"}</script><link rel="canonical" href="http://example.com/2020/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="路由器" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-17T16:00:00.000Z" title="2020/10/18 00:00:00">2020-10-18</time>发表</span><span class="level-item"><time dateTime="2024-01-11T05:59:48.162Z" title="2024/1/11 13:59:48">2024-01-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="level-item">1 小时读完 (大约7675个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">面向对象</h1><div class="content"><p>类、继承、扩展、委托、接口、泛型、抽象类、内联类、数据类、密封类、枚举类、单例、对象表达式、可见性修饰符</p>
<span id="more"></span>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> [可见性修饰符] [注解] <span class="keyword">constructor</span></span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>,<span class="keyword">val</span> name:String)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(age:<span class="built_in">Int</span>, name:String, sex:String):<span class="keyword">this</span>(age,name)&#123;</span><br><span class="line">        println(<span class="string">&quot;辅助构造函数，名字:<span class="variable">$name</span>,年龄:<span class="variable">$age</span>,性别:<span class="variable">$sex</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;初始化，name=<span class="variable">$name</span>,age=<span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建类实例</span></span><br><span class="line"><span class="comment">//kotlin不需要new关键字</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> c = ClassName(实参列表)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><p>可以有一个主构造函数和一个或多个辅助构造函数，主构造函数使用<code>constructor</code>关键字声明</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">constructor</span></span>(age:<span class="built_in">Int</span>,name:String)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果主构造函数没有任何注释或可见性修饰符，则可以省略<code>constructor</code>关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>(age:<span class="built_in">Int</span>,name:String)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h4><p>主构造函数中不能包含任何代码，初始化代码需要放在以<code>init</code>关键字修饰的初始化块中，主构造函数的参数可以在初始化块和类中声明的属性初始化器追踪使用。如果有多个初始化块，会按声明顺序执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>(age:<span class="built_in">Int</span>,name:String)&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = name</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;类初始化&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;age=<span class="variable">$age</span>,name=<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;name=<span class="variable">$myName</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kotlin</code>可以在主构造函数中声明类属性并进行初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>,<span class="keyword">val</span> name:String)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入股主构造函数有注释或可见性修饰符，则需要声明<code>constructor</code>关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">public</span> <span class="meta">@Bean</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使没有主构造函数，<code>init</code>代码块也会执行</p>
<h4 id="辅助构造函数"><a href="#辅助构造函数" class="headerlink" title="辅助构造函数"></a>辅助构造函数</h4><p>辅助构造函数必须直接或间接的委托给主构造函数，使用<code>this</code>关键字完成对另一个构造函数（可以是辅助&#x2F;主构造函数）的委托</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>,<span class="keyword">val</span> name:String)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(age:<span class="built_in">Int</span>, name:String, sex:String):<span class="keyword">this</span>(age,name)&#123;</span><br><span class="line">        println(<span class="string">&quot;辅助构造函数，名字:<span class="variable">$name</span>,年龄:<span class="variable">$age</span>,性别:<span class="variable">$sex</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;初始化，age=<span class="variable">$age</span>,name=<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行的顺序是：<code>init</code>初始化块-&gt;辅助构造函数，因为初始化代码块会组为辅助构造器的第一条语句执行，初始化程序总是最早执行的。如果没有主构造函数，会生成一个不带参数的主构造函数（默认<code>public</code>），此时辅助构造函数不用使用<code>this</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(age:<span class="built_in">Int</span>, name:String, sex:String)&#123;</span><br><span class="line">        println(<span class="string">&quot;辅助构造函数，名字:<span class="variable">$name</span>,年龄:<span class="variable">$age</span>,性别:<span class="variable">$sex</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p><code>class</code>中可以生命的成员包括：</p>
<ul>
<li>构造函数和初始化块：<a href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96">详细介绍</a></li>
<li>方法</li>
<li>属性：可以声明<code>var</code>和<code>val</code>变量，使用时直接通过名称访问，<a href="#%E5%B1%9E%E6%80%A7">详细介绍</a></li>
<li>嵌套类和内部类</li>
<li>对象声明</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>声明属性的完整格式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>可选参数说明：</strong></p>
<ul>
<li><code>PropertyType</code>：如果可以从<code>property_initializer</code>或 <code>getter</code> 的返回类型推断出属性类型，则<code>PropertyType</code>是可选的</li>
<li><code>property_initializer</code>：如果<code>getter</code>和<code>setter</code>中的需要使用<code>field</code>关键字，否则可能无法赋初始值</li>
<li><code>getter</code>：如果自定义了<code>getter</code>，每次获取值都会触发<code>getter</code></li>
<li><code>setter</code>：如果自定义了<code>setter</code>，每次赋值都会触发，除了初始化。<code>val</code>属性不允许设置<code>setter</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(name: String)&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String = name</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        println(<span class="string">&quot;getter&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> field</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        println(<span class="string">&quot;setter value=<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">        field = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="field-关键字"><a href="#field-关键字" class="headerlink" title="field 关键字"></a>field 关键字</h5><p>表示当前操作的字段，并且只能在<code>getter</code>和<code>setter</code>中使用。因为我们需要在<code>getter</code>和<code>setter</code>中对属性进行获取和赋值，如果直接使用原属性就可能出现递归，循环的调用原属性，所以才需要使用<code>field</code> 操作属性</p>
<h5 id="lateinit-关键字"><a href="#lateinit-关键字" class="headerlink" title="lateinit 关键字"></a>lateinit 关键字</h5><p>一般声明为非空类型的属性必须在构造函数中初始化，但有时我们希望通过依赖注入等方式进行初始化，在这种情况下无法在构造函数将那些初始化，可以使用<code>lateinit</code>关键字标记<code>var</code>属性避免<code>null</code>检查</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里不加lateinit编译不通过</span></span><br><span class="line">    <span class="comment">//作用在var属性上，不在主构造函数中，没有自定义getter和setter</span></span><br><span class="line">    <span class="comment">//变量必须是非空的，并且不能是原始类型（Int等）</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> s:String</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断变量是否已经初始化</span></span><br><span class="line">        <span class="comment">//此检查只适用于访问类内、外部类以及顶层属性</span></span><br><span class="line">        <span class="keyword">this</span>::s.isInitialized</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>接口和类可以任意嵌套</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> value:String = <span class="string">&quot;123&quot;</span></span><br><span class="line">    <span class="comment">//类可以嵌套类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类可以嵌套接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">InnerInterface</span></span>&#123;</span><br><span class="line">        <span class="comment">//接口可以嵌套类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">IClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h4><p>被标记为<code>inner</code>的内部类可以访问外部类的成员</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> value:String = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span> = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">object</span> :TestClass&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;匿名内部类&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p><code>this</code>表示当前接收者，用于</p>
<ul>
<li>在类成员中，指的是该类当前对象，此时如果没有命名冲突可以不用写<code>this</code></li>
<li>在扩展函数或<code>function literal with receiver</code>中，<code>this</code>表示在 <code>.</code> 左侧对象</li>
</ul>
<p>在外部的作用域使用<code>this</code>（类、扩展函数、<code>function literal with receiver</code>），需要写<code>this@label</code>，<code>@label</code>是<code>this</code>的作用域</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//label @A</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="comment">// label @B</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">foo</span><span class="params">()</span></span> &#123; <span class="comment">// label @foo</span></span><br><span class="line">            <span class="keyword">val</span> a = <span class="keyword">this</span><span class="symbol">@A</span> <span class="comment">// A&#x27;s this</span></span><br><span class="line">            <span class="keyword">val</span> b = <span class="keyword">this</span><span class="symbol">@B</span> <span class="comment">// B&#x27;s this</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> c = <span class="keyword">this</span> <span class="comment">// foo()&#x27;s receiver, an Int</span></span><br><span class="line">            <span class="keyword">val</span> c1 = <span class="keyword">this</span><span class="symbol">@foo</span> <span class="comment">// foo()的接收者：Int</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> funLit = <span class="symbol">lambda@</span> <span class="function"><span class="keyword">fun</span> String.<span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> d = <span class="keyword">this</span> <span class="comment">// funLit&#x27;s receiver</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> funLit2 = &#123; s: String -&gt;</span><br><span class="line">                <span class="comment">// foo()的接收者, since enclosing lambda expression</span></span><br><span class="line">                <span class="comment">// doesn&#x27;t have any receiver</span></span><br><span class="line">                <span class="keyword">val</span> d1 = <span class="keyword">this</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>kotlin</code>中的所有类都有一个父类<code>Any</code>，如果没有声明父类，那他就是默认父类。Any有三个方法：</p>
<ul>
<li><code>equals()</code></li>
<li><code>hashCode()</code></li>
<li><code>toString()</code></li>
</ul>
<p>默认情况下，kotlin中的类是不能被继承的，如果希望可继承，需要使用<code>open</code>关键字。子类继承父类需要将父类放在类头的冒号之后</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>() :Animal()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<ul>
<li><code>kotlin</code>是单继承；</li>
<li>如果继承的基类和接口中有同名的成员，那么派生类应该对其提供自己的实现；</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果派生类具有主构造函数，则必须根据主构造函数的参数初始化基类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(<span class="keyword">var</span> name:String)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(name: String,age: <span class="built_in">Int</span>) :Animal(name)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果派生类没有主构造函数，则每个辅助构造函数都需要用<code>super</code>关键字初始化基类，或者委托给另一个构造函数。初始化基类时可以调用基类不同的构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(<span class="keyword">var</span> name:String)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :<span class="type">Animal&#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String):<span class="keyword">super</span>(name)&#123;</span><br><span class="line">        println(<span class="string">&quot;name=<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖成员"><a href="#覆盖成员" class="headerlink" title="覆盖成员"></a>覆盖成员</h3><p><code>kotlin</code>需要使用<code>open</code>关键字显示声明可覆盖的成员，子类使用<code>override</code>关键字声明覆盖的成员。另外<code>override</code>修饰的成员默认是可覆盖的，如果想要进制之后的覆盖，需要使用<code>final</code></p>
<h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(<span class="keyword">var</span> name:String)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;父类方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在主构造函数参数中覆盖属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(name: String) : Animal(name) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖方法，禁止再次覆盖</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;覆盖父类方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h4><p>可以在构造函数参数和成员中覆盖基类属性，可以使用<code>var</code>覆盖<code>val</code>，反之不行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(<span class="keyword">var</span> name:String) &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> sex: String = <span class="string">&quot;雌性&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以在主构造函数参数中覆盖属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(name: String,num:<span class="built_in">Int</span>,<span class="keyword">override</span> <span class="keyword">var</span> sex:String) : Animal(name) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> age:<span class="built_in">Int</span> = num</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="派生类初始化顺序"><a href="#派生类初始化顺序" class="headerlink" title="派生类初始化顺序"></a>派生类初始化顺序</h3><p>父类的参数和初始化块都执行完毕后才会进行子类的初始化，所以在父类的初始化过程中不应该使用子类的覆盖了的成员。因此，在设计基类时，应避免将<code>open</code>放在构造函数、属性初始值设定项或<code>init</code>块上。</p>
<p>下面是验证初始化顺序的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(name: String)&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> name:String = name.also &#123; println(<span class="string">&quot;初始化父类参数&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;执行父类初始化块&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(name: String) : Animal(name) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;执行子类初始化块&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name:String = name .also &#123; println(<span class="string">&quot;初始化子类参数&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化父类参数</span><br><span class="line">执行父类初始化块</span><br><span class="line">执行子类初始化块</span><br><span class="line">初始化子类参数</span><br></pre></td></tr></table></figure>

<h3 id="调用基类成员"><a href="#调用基类成员" class="headerlink" title="调用基类成员"></a>调用基类成员</h3><p>派生类中通过<code>super</code>关键字可以调用积累的成员</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(<span class="keyword">var</span> name: String)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(name: String) : Animal(name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.name</span><br><span class="line">        <span class="keyword">super</span>.f1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Kotlin 提供了使用新功能扩展类的能力，而无需从类继承或使用诸如装饰者之类的设计模式</p>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> 类型.方法名<span class="params">(参数列表)</span></span>:返回值&#123;</span><br><span class="line">    <span class="comment">//通过this操作对象</span></span><br><span class="line">    println(<span class="string">&quot;为A扩展方法 name:<span class="subst">$&#123;this.name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;A-&gt;f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> A.<span class="title">addFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;为A扩展方法 name:<span class="subst">$&#123;this.name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>扩展属性语法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; 类型&lt;T&gt;.变量名: 变量类型</span><br><span class="line">    [<span class="keyword">get</span>()]</span><br></pre></td></tr></table></figure>

<p>因为扩展实际上不会将属性加入到类中，所以不能使用<code>field</code>，不能初始化，只能通过<code>getter/setter</code>来定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastValue:T</span><br><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastValue:T</span><br><span class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>[size-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="将扩展声明为成员"><a href="#将扩展声明为成员" class="headerlink" title="将扩展声明为成员"></a>将扩展声明为成员</h3><p>可以在另一个类中声明一个类的扩展</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许继承可以加open</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AExtensions</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> A.<span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> A.a : String</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toString() <span class="comment">//A.toString()</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@AExtensions</span>.toString() <span class="comment">//AExtensions.toString()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将扩展类声明为<code>open</code>表示可覆盖，可以重写方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCaller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> Base.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Base extension function in BaseCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> Derived.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Derived extension function in BaseCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(b: <span class="type">Base</span>)</span></span> &#123;</span><br><span class="line">        b.printFunctionInfo()   <span class="comment">//调用扩展方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedCaller</span>: <span class="type">BaseCaller</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Base.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Base extension function in DerivedCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Derived.<span class="title">printFunctionInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Derived extension function in DerivedCaller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    BaseCaller().call(Base())   <span class="comment">// &quot;in BaseCaller&quot;</span></span><br><span class="line">    DerivedCaller().call(Base())  <span class="comment">// &quot;in DerivedCaller&quot;</span></span><br><span class="line">    DerivedCaller().call(Derived())  <span class="comment">// &quot;in DerivedCaller&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h3><p>扩展并不是将新成员插入到类中，只是让新函数可以以<code>对象.成员</code>的方式进行调用。它是静态的，在编译时就已经确定，所以不具备类的多态的概念，<strong>执行的方法仅由类型决定</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>: <span class="type">Parent</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Parent.<span class="title">getName</span><span class="params">()</span></span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Child.<span class="title">getName</span><span class="params">()</span></span> = <span class="string">&quot;添加子类方法&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printClassName</span><span class="params">(s: <span class="type">Parent</span>)</span></span> &#123;</span><br><span class="line">    println(s.getName())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printClassName(Child()) <span class="comment">//结果：添加父类方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果添加的方法与类中原有的方法参数和类型相同，则会调用原方法，但可以<strong>重载原方法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;原方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Test.<span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;添加方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Test.<span class="title">f1</span><span class="params">(i:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;添加方法2：int=<span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test().f1() <span class="comment">//结果：原方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可空接收器"><a href="#可空接收器" class="headerlink" title="可空接收器"></a>可空接收器</h3><p>使用<strong>可空接收器</strong>，即使其值为空也可以调用方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Test?.<span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    println(<span class="string">&quot;不为空&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托就是派生类不全部实现接口的方法，而是选择委托给了其他派生类，运行时根据当前派生类和其他派生类的方法生成真正的方法</p>
<h3 id="委托方法"><a href="#委托方法" class="headerlink" title="委托方法"></a>委托方法</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>一个<code>Derived</code>类可以实现一个<code>Base</code>接口通过委托其的全部的<code>public</code>成员对于指定的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>by</code>关键字是指<code>b</code>会被存储在<code>Derived</code>的对象中并且编译器会构造全部的<code>Base</code>方法转发到<code>b</code>，意思就是，将<code>Base</code>委托给<code>b</code>，根据b的真实类型构造实现方法，然后调用。</p>
<h4 id="覆盖委托实现的接口成员"><a href="#覆盖委托实现的接口成员" class="headerlink" title="覆盖委托实现的接口成员"></a>覆盖委托实现的接口成员</h4><p>可以在委托上实现接口方法，生成方法时会使用自己实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMessageLine</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessageLine</span><span class="params">()</span></span> &#123; println(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printMessage</span><span class="params">()</span></span> &#123; print(<span class="string">&quot;abc&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).printMessage() <span class="comment">//abc</span></span><br><span class="line">    Derived(b).printMessageLine() <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方式在委托对象中无法调用本类中重写的方法，委托对象只能调用自己实现的方法</p>
<h3 id="委托变量"><a href="#委托变量" class="headerlink" title="委托变量"></a>委托变量</h3><p><code>kotlin</code>支持委托属性，用于保存常见属性，以免每次使用都需要声明</p>
<ul>
<li>惰性属性：首次访问时计算</li>
<li>可观察属性：监听有关此属性的更改</li>
<li>存储在<code>map</code>中的属性，代替声明每个属性都单独字段</li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>属性委托用于将属性的行为委托给另一个对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;属性名&gt;: &lt;Type&gt; <span class="keyword">by</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>operator</code>关键字标记委托函数：</p>
<ul>
<li><p>对于只读属性 (<code>val</code>) ，委托者应该提供<code>getValue()</code>；</p>
</li>
<li><p>对于可变属性 ( <code>var</code>)，委托必须另外提供<code>setValue()</code>；</p>
</li>
</ul>
<p>方法详细介绍如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">    <span class="comment">//将value委托给了Delegate()对象，对于value的操作都会调用该对象中的方法</span></span><br><span class="line">    <span class="keyword">var</span> value:String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * thisRef：读取的对象（Value@7eda2dbb）</span></span><br><span class="line"><span class="comment">     * property：属性描述信息（var Value.value: kotlin.String）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;thisRef：<span class="variable">$thisRef</span>，property：<span class="variable">$property</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * thisRef：读取的对象（Value@7eda2dbb）</span></span><br><span class="line"><span class="comment">     * property：属性描述信息（var Value.value: kotlin.String）</span></span><br><span class="line"><span class="comment">     * value：设置传入的值（aaa）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;thisRef：<span class="variable">$thisRef</span>，property：<span class="variable">$property</span>，value：<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> v = Value()</span><br><span class="line">    v.value = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">    println(v.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用接口<code>ReadOnlyProperty</code>和<code>ReadWriteProperty</code>，可以在不创建新类的情况下将委托创建为匿名对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> readWriteProperty = <span class="keyword">object</span> :ReadWriteProperty&lt;Any?,String&gt;&#123;</span><br><span class="line">        <span class="keyword">var</span> curValue:String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">            println(<span class="string">&quot;thisRef：<span class="variable">$thisRef</span>，property：<span class="variable">$property</span>&quot;</span>) <span class="comment">//thisRef：null，property：var readWrite: kotlin.String，value：123</span></span><br><span class="line">            <span class="keyword">return</span> curValue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            curValue = value</span><br><span class="line">            println(<span class="string">&quot;thisRef：<span class="variable">$thisRef</span>，property：<span class="variable">$property</span>，value：<span class="variable">$value</span>&quot;</span>) <span class="comment">//thisRef：null，property：var readWrite: kotlin.String</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> readWrite:String <span class="keyword">by</span> readWriteProperty</span><br><span class="line">    readWrite = <span class="string">&quot;123&quot;</span></span><br><span class="line">    println(readWrite) <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> readOnlyProperty = <span class="keyword">object</span> : ReadOnlyProperty&lt;Any?, String&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> curValue:String = <span class="string">&quot;默认值&quot;</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">            println(<span class="string">&quot;thisRef：<span class="variable">$thisRef</span>，property：<span class="variable">$property</span>&quot;</span>) <span class="comment">//thisRef：null，property：val readOnly: kotlin.String</span></span><br><span class="line">            <span class="keyword">return</span> curValue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> readOnly:String <span class="keyword">by</span> readWriteProperty</span><br><span class="line">    <span class="comment">//等同</span></span><br><span class="line">    <span class="comment">//val readOnly:String by readOnlyProperty</span></span><br><span class="line"></span><br><span class="line">    println(readOnly)<span class="comment">//默认值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h4><p><code>Kotlin</code> 标准库为几种有用的委托提供工厂方法</p>
<h5 id="惰性属性"><a href="#惰性属性" class="headerlink" title="惰性属性"></a>惰性属性</h5><p><code>lazy()</code>是一个方法，它接受一个<code>lambda</code>表达式并返回一个<code>Lazy&lt;T&gt;</code>类型实例，他在第一次<code>get</code>时执行，之后每次调用返回记住的结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">&quot;第一次执行&quot;</span>)</span><br><span class="line">    <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可观察属性"><a href="#可观察属性" class="headerlink" title="可观察属性"></a>可观察属性</h5><p>每次赋值时都会调用对应处理程序。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;&lt;no name&gt;&quot;</span>) &#123;</span><br><span class="line">        prop, old, new -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$old</span> -&gt; <span class="variable">$new</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><code>prop</code>：属性<code>（property name (Kotlin reflection is not available）</code></li>
<li><code>old</code>：旧值</li>
<li><code>new</code>：新值</li>
</ul>
<h4 id="委托给另一个属性"><a href="#委托给另一个属性" class="headerlink" title="委托给另一个属性"></a>委托给另一个属性</h4><p>一个属性可以将它的 <code>getter</code> 和 <code>setter</code> 委托给另一个属性，委托属性可以是：</p>
<ul>
<li>顶级属性</li>
<li>同一类的成员或属性</li>
<li>另一个类的成员或属性</li>
</ul>
<p>语法格式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//委托给顶级属性</span></span><br><span class="line">::顶级属性名</span><br><span class="line"><span class="comment">//委托给本类属性</span></span><br><span class="line"><span class="keyword">this</span>::属性名</span><br><span class="line"><span class="comment">//委托给其他类属性</span></span><br><span class="line">ClassName::属性名</span><br></pre></td></tr></table></figure>

<p>举例如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶级属性</span></span><br><span class="line"><span class="keyword">var</span> topLevelInt: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithDelegate</span></span>(<span class="keyword">val</span> anotherClassInt: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>(<span class="keyword">var</span> memberInt: <span class="built_in">Int</span>, <span class="keyword">val</span> anotherClassInstance: ClassWithDelegate) &#123;</span><br><span class="line">    <span class="comment">//委托给本类属性</span></span><br><span class="line">    <span class="keyword">var</span> delegatedToMember: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::memberInt</span><br><span class="line">    <span class="comment">//委托给顶级属性</span></span><br><span class="line">    <span class="keyword">var</span> delegatedToTopLevel: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br><span class="line">	<span class="comment">//委托给其他类属性</span></span><br><span class="line">    <span class="keyword">val</span> delegatedToAnotherClass: <span class="built_in">Int</span> <span class="keyword">by</span> anotherClassInstance::anotherClassInt</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委托给顶级属性</span></span><br><span class="line"><span class="keyword">var</span> MyClass.extDelegated: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在map中存储属性"><a href="#在map中存储属性" class="headerlink" title="在map中存储属性"></a>在<code>map</code>中存储属性</h4><p>将属性委托给<code>map</code>，将常用于解析<code>Json</code>等动态任务中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只读</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> value:String <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可读可写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableValue</span></span>(<span class="keyword">val</span> map: MutableMap&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> value:String <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//构造函数传递map</span></span><br><span class="line">    <span class="keyword">val</span> v1 = Value(mapOf(</span><br><span class="line">            <span class="string">&quot;value&quot;</span> to <span class="string">&quot;迪莫&quot;</span>,</span><br><span class="line">    ))</span><br><span class="line">    <span class="comment">//会从map中获取对应的值</span></span><br><span class="line">    println(v1.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> v2 = MutableValue(mutableMapOf(</span><br><span class="line">            <span class="string">&quot;value&quot;</span> to <span class="string">&quot;阿布&quot;</span>,</span><br><span class="line">    ))</span><br><span class="line">    v2.value = <span class="string">&quot;瞌睡王&quot;</span></span><br><span class="line">    println(v2.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="provideDelegate"><a href="#provideDelegate" class="headerlink" title="provideDelegate"></a>provideDelegate</h4><p>通过定义<code>provideDelegate</code>操作符，用于自定义委托实现的逻辑，如果<code>by</code>右侧定义了<code>provideDelegate</code>作为一个成员或扩展方法，这个方法会被调用去创建委托实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>接口中可包含抽象方法声明，以及方法的实现。接口不能存储状态，但可以具有属性。使用<code>interface</code>关键字定义接口，接口中声明的属性可以是抽象的，也可以为<code>getter</code>提供实现，但不能有<code>backing field</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象,接口中var不能初始化，不能有getter和setter</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//val变量也不能初始化，但可以有getter</span></span><br><span class="line">    <span class="keyword">val</span> name:String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">&quot;张三&quot;</span>.also &#123; println(<span class="string">&quot;name-getter&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方抽象法，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;接口实现&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以实现多个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>() :Animal&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">3</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;子类实现&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>接口可以相互继承，也就是说，接口可以为其他接口提供实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方抽象法，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;接口实现&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cat</span>:<span class="type">Animal</span>,<span class="type">Color&#123;</span></span></span><br><span class="line">    <span class="comment">//覆盖属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> color:String</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Cat实现f1()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承方法冲突"><a href="#继承方法冲突" class="headerlink" title="继承方法冲突"></a>继承方法冲突</h3><p>继承多个接口时可能从不同接口继承了同一方法的多个实现，这时需要自己实现这些冲突的方法（无论派生类是<code>class</code>还是<code>interface</code>）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Cat-&gt;f2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Dog-&gt;f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Dog-&gt;f2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatAndDog</span>:<span class="type">Cat</span>,<span class="type">Dog&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//调用Dog接口实现的f1</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Dog&gt;.f1()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//调用Cat接口实现的f2</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Cat&gt;.f2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>只有一个抽象方法的接口称为函数式接口或SAM接口。函数式接口可以有对各非抽象成员，但只能有一个抽象成员，使用<code>fun</code>声明函数式接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> MySAM&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(i:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//匿名内部类的方式调用</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="keyword">object</span> :MySAM&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    println(s.invoke(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sam调用</span></span><br><span class="line">    <span class="keyword">val</span> s2 = MySAM&#123;it+<span class="number">1</span>&#125;</span><br><span class="line">    println(s2.invoke(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><code>kotlin</code>中的类和方法可以有泛型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cry</span><span class="params">(t:<span class="type">T</span>)</span></span>:T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&lt;<span class="type">T</span>&gt; :<span class="type">Animal</span>&lt;<span class="type">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//返回t本身</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cry</span><span class="params">(t:<span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协变-out"><a href="#协变-out" class="headerlink" title="协变 out"></a>协变 out</h3><p><code>&lt;out T&gt;</code>代表可以接收<code>T</code>类型的父类，但<code>T</code>不能作为参数，只能作为方法的返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Production</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(a: <span class="type">Production</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objects: Production&lt;Any&gt; = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="逆变-in"><a href="#逆变-in" class="headerlink" title="逆变 in"></a>逆变 in</h3><p><code>&lt;in T&gt;</code>代表可以接收<code>T</code>类型的子类，但<code>T</code>不能作为返回值，只能作为方法的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Consumer&lt;in T&gt; &#123;</span><br><span class="line">    fun consume(item: T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun demo(a: Consumer&lt;Number&gt;) &#123;</span><br><span class="line">    val objects: Consumer&lt;Double&gt; = a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通用约束"><a href="#通用约束" class="headerlink" title="通用约束"></a>通用约束</h3><p>约束类型的上限，对应于<code>java</code>的<code>extends</code>关键字，冒号后指定类型上限</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="type">T:String</span>&gt;</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有指定上限，默认上限是<code>Any?</code>，一个尖括号内只能指定一个上限，如果需要指定多个，需要使用<code>where</code>子句</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span></span><br><span class="line"><span class="keyword">where</span> T : CharSequence,</span><br><span class="line">	  T : Comparable&lt;T&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码<code>T</code>必须实现<code>CharSequence</code>和<code>Comparable&lt;T&gt;</code> </p>
<h3 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h3><h4 id="类型预测"><a href="#类型预测" class="headerlink" title="类型预测"></a>类型预测</h4><p><code>in</code>和<code>out</code>可以加到方法的参数中，用来限定传入的参数。</p>
<p>上面的<code>in</code>和<code>out</code>分别用来声明接收子类和父类，但他们都有限制，<code>out</code>不能作为参数，<code>in</code>不能用作返回值。当泛型<code>T</code>在一个类中既需要作为参数也需要作为返回值时，<code>in</code>和<code>out</code>就都无法使用了。如下代码所示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Projections</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t:T</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">product</span><span class="params">()</span></span>:T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">override</span> <span class="keyword">var</span> t: T):Projections&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">consume</span><span class="params">(item: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        t = item</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">product</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from:<span class="type">Value</span>&lt;<span class="type">Any</span>&gt;,to:<span class="type">Value</span>&lt;<span class="type">Any</span>&gt;)</span></span>&#123;</span><br><span class="line">    to.consume(from.product())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> f:Value&lt;Any&gt; = Value(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t:Value&lt;Any&gt; = Value(<span class="string">&quot;啦啦啦&quot;</span>)</span><br><span class="line">    copy(f,t)</span><br><span class="line">    println(t.product())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中<code>Value</code>类存储一个值，这个值是泛型的，通过<code>copy</code>函数可以将一个<code>Value</code>传递给另一个<code>Value</code>，但这样<code>from</code>和<code>to</code>的泛型就必须一致，比如，如果将</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f:Value&lt;Any&gt; = Value(<span class="string">&quot;哈哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f:Value&lt;String&gt; = Value(<span class="string">&quot;哈哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>就会报错，想要解决可以将<code>from</code>声明为<code>out</code>，虽然问题解决了，但这样的话<code>from</code>就无法调用参数为<code>T</code>的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from:<span class="type">Value</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;,to:<span class="type">Value</span>&lt;<span class="type">Any</span>&gt;)</span></span>&#123;</span><br><span class="line">    to.consume(from.product())</span><br><span class="line">    from.consume(<span class="string">&quot;3&quot;</span>)<span class="comment">//编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果使用<code>in</code>，锁门<code>from</code>中的<code>T</code>需要是<code>Any</code>子类，这样就不能赋值给<code>to</code>中的<code>T</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from:<span class="type">Value</span>&lt;<span class="type">in</span> <span class="type">Any</span>&gt;,to:<span class="type">Value</span>&lt;<span class="type">Any</span>&gt;)</span></span>&#123;</span><br><span class="line">    to.consume(from.product()) <span class="comment">//编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>综上所述</strong>，可以通过<code>in</code>和<code>out</code>预测所传入的类型，但存在一定限制</p>
<h4 id="星映射"><a href="#星映射" class="headerlink" title="星映射"></a>星映射</h4><p>todo</p>
<ul>
<li>对于<code>Foo&lt;out T : TUpper&gt;</code>，其中<code>T</code>是具有上限的协变类型参数<code>TUpper</code>，<code>Foo&lt;*&gt;</code>等效于<code>Foo&lt;out TUpper&gt;</code>。这意味着当<code>T</code>未知时，您可以安全地<em>读取</em><code>TUpper</code>from 的值<code>Foo&lt;*&gt;</code>。</li>
<li>对于<code>Foo&lt;in T&gt;</code>，其中<code>T</code>是逆变类型参数，<code>Foo&lt;*&gt;</code>等效于<code>Foo&lt;in Nothing&gt;</code>。这意味着当未知时，您无法以安全的方式<em>写入</em>任何内容。<code>Foo&lt;*&gt;``T</code></li>
<li>对于<code>Foo&lt;T : TUpper&gt;</code>，其中<code>T</code>是具有上限的不变类型参数<code>TUpper</code>，<code>Foo&lt;*&gt;</code>相当于<code>Foo&lt;out TUpper&gt;</code>用于读取值和<code>Foo&lt;in Nothing&gt;</code>用于写入值。</li>
</ul>
<p>对于<code>interface Function&lt;in T, out U&gt;</code></p>
<ul>
<li><code>Function&lt;*, String&gt;</code>是指<code>Function&lt;in Nothing, String&gt;</code>。</li>
<li><code>Function&lt;Int, *&gt;</code>是指<code>Function&lt;Int, out Any?&gt;</code>。</li>
<li><code>Function&lt;*, *&gt;</code>是指<code>Function&lt;in Nothing, out Any?&gt;</code>。</li>
</ul>
<h3 id="6、函数泛型"><a href="#6、函数泛型" class="headerlink" title="6、函数泛型"></a>6、函数泛型</h3><p>函数也可以声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(t:<span class="type">T</span>)</span></span>:T&#123;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时指定泛型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test&lt;<span class="built_in">Int</span>&gt;(<span class="number">5</span>) <span class="comment">//返回5</span></span><br></pre></td></tr></table></figure>





<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>可以使用<code>abstract</code>修饰一个类和类的成员。抽象成员在抽象类中没有实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要么初始化要么使用abstract</span></span><br><span class="line">    <span class="keyword">val</span> name:String = <span class="string">&quot;名字&quot;</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> age:<span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明open表示该方法可以被覆盖</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;方法1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> age: <span class="built_in">Int</span>) :Animal()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖方法需要override关键字</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;覆盖f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;f2实现&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h2><p>todo</p>
<p>有时必要的业务逻辑，需要将基本数据类型、String 等等参数封装在一个 Model 中，然后在 Model 中封装一些方法，对这个参数做检查、验证等等操作。参数被封装之后，需要创建包装对象，对象的创建在堆中进行分配，数据量很大的情况，对性能的损耗也非常大</p>
<h3 id="内联类定义"><a href="#内联类定义" class="headerlink" title="内联类定义"></a>内联类定义</h3><p><code>Kotlin 1.5</code>废弃了 <code>inline</code> 修饰符，引入了 <code>value class</code>，现在不推荐使用<code>inline</code>，应该使用<code>value</code>关键字声明内联类。<code>value class</code>是<code>inline class</code>的超集</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Password</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> s: String)</span><br></pre></td></tr></table></figure>

<p>在类声明之前使用<code>value</code>修饰符和<code>@JvmInline</code>注释：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Password</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> s: String)</span><br></pre></td></tr></table></figure>

<p>现阶段 <code>value classes</code> 和 <code>inline classes</code> 一样，只能在构造函数中传入一个参数，参数需要用 <code>val</code> 声明，将来可以在构造函数中添加多个参数，但是每个参数都需要用 <code>val</code> 声明</p>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>内联类可以声明属性、函数和<code>init</code>块，内联类属性不支持<code>field</code>，不支持<code>lateinit</code>&#x2F;<code>delegated</code> 属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Password</span></span>(<span class="keyword">val</span> s: String)&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> key:String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printPass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>内联类可以实现其他接口，但不能被继承</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Key</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="class"><span class="keyword">class</span> <span class="title">Password</span></span>(<span class="keyword">val</span> s: String):Key&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><h3 id="数据类定义"><a href="#数据类定义" class="headerlink" title="数据类定义"></a>数据类定义</h3><p>数据类用来保存数据，数据类必须保证以下条件：</p>
<ul>
<li>主构造函数至少有一个参数</li>
<li>所有主构造函数都需要标记为<code>val</code>或<code>var</code></li>
<li>数据类不能是抽象的、开放的、密封的、内部的</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>(<span class="keyword">var</span> name:String,<span class="keyword">val</span> age:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会自动从主构造函数中声明的所有属性派生以下成员：</p>
<ul>
<li><code>equals()</code>&#x2F;<code>hashCode()</code></li>
<li><code>Cat(name=迪莫, age=3)</code>形式的<code>toString()</code></li>
<li><code>copy()</code></li>
<li><code>componentN()</code>与声明顺序中的属性相对应的函数</li>
<li>如果自己实现或是基类中有<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>，则不会生成这些函数</li>
<li>不允许为<code>componentN()</code>和<code>copy()</code>函数提供显式实现</li>
<li>如果基类有<code>componentN()</code>并且时<code>open</code>的，数据类会生成和覆盖响应方法，如果无法覆盖就会报错</li>
</ul>
<h3 id="主体中声明属性"><a href="#主体中声明属性" class="headerlink" title="主体中声明属性"></a>主体中声明属性</h3><p>如果需要从生成的实现中排除属性，需要在数据类主体声明属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>(<span class="keyword">var</span> name:String)&#123;</span><br><span class="line">    <span class="keyword">val</span> age:<span class="built_in">Int</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中只有name在内部会生成<code>toString()</code>，<code>equals()</code>，<code>hashCode()</code>，和<code>copy()</code>和<code>component1()</code>，这些方法都会忽略<code>age</code>属性。两个<code>Cat</code>的<code>age</code>属性不同也会被视为相等</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h3><p><code>copy()</code>函数用于复制对象，允许更改某些主函数声明的属性，同时其余属性保持不变</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>(<span class="keyword">var</span> name:String)&#123;</span><br><span class="line">    <span class="keyword">val</span> age:<span class="built_in">Int</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> c = Cat(<span class="string">&quot;迪莫&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> c1 = c.copy(name = <span class="string">&quot;阿布&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解构声名"><a href="#解构声名" class="headerlink" title="解构声名"></a>解构声名</h3><p>为数据类提供的组件函数可以使用结构声名</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = Cat(<span class="string">&quot;迪莫&quot;</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (name,age) = c</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>(<span class="keyword">var</span> name:String,<span class="keyword">val</span> age:<span class="built_in">Int</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类用来限制类的继承关系，子类数量是固定的</p>
<h3 id="密封类定义"><a href="#密封类定义" class="headerlink" title="密封类定义"></a>密封类定义</h3><p>使用<code>sealed</code>关键字定义密封类</p>
<ul>
<li>定义时他的子类都在密封类内部定义，并且都是单例的</li>
<li>密封类构造函数可见性为<code>protected</code>（默认）或<code>private</code></li>
<li>密封类类似于一个枚举类，不同之处在于枚举类的实例时唯一的，而密封类可以有很多实例</li>
<li>密封类本身是抽象的，可以定义抽象方法，不能实例化</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">var</span> name:String,<span class="keyword">var</span> age:<span class="built_in">Int</span>) :Animal&#123;</span><br><span class="line">    <span class="comment">//声明了多个匿名内部类</span></span><br><span class="line">    <span class="keyword">object</span> Cat:Test(<span class="string">&quot;迪莫&quot;</span>,<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cry</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;迪莫叫&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">object</span> Dog:Test(<span class="string">&quot;音速犬&quot;</span>,<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">cry</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;音速犬叫&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用环境</strong>：</p>
<ul>
<li>对象需要是有限集合的类型之一，但不能具有任何其他类型时，使用密封类</li>
</ul>
<h3 id="配合when语句"><a href="#配合when语句" class="headerlink" title="配合when语句"></a>配合when语句</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:Animal = Test.Cat</span><br><span class="line"><span class="keyword">when</span>(a)&#123;</span><br><span class="line">    <span class="keyword">is</span> Test.Cat -&gt;&#123;&#125;</span><br><span class="line">    <span class="keyword">is</span> Test.Dog -&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不需要使用<code>else</code></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="枚举类定义"><a href="#枚举类定义" class="headerlink" title="枚举类定义"></a>枚举类定义</h3><p>使用<code>enum</code>关键字修饰枚举类，内部每个枚举类常量用逗号分隔</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    Cat,Dog,Rabbit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个枚举类常量都是对象，可以进行初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    RED(<span class="number">0xFF0000</span>),</span><br><span class="line">    GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">    BLUE(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖方法-1"><a href="#覆盖方法-1" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>枚举常量可以使用相应的方法以及覆盖基本方法来声明自己的匿名类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolState</span> </span>&#123;</span><br><span class="line">    WAITING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = TALKING</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    TALKING &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = WAITING</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span>: ProtocolState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>枚举类可以实现接口，但不允许被继承</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">IntArithmetics</span> : <span class="type">BinaryOperator</span>&lt;<span class="type">Int</span>&gt;, <span class="type">IntBinaryOperator &#123;</span></span></span><br><span class="line">    PLUS &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>, u: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = t + u</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>, u: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = t * u</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyAsInt</span><span class="params">(t: <span class="type">Int</span>, u: <span class="type">Int</span>)</span></span> = apply(t, u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类使用"><a href="#枚举类使用" class="headerlink" title="枚举类使用"></a>枚举类使用</h3><p>枚举类提供了两个方法：</p>
<ul>
<li><code>EnumClass.valueOf(value:String)</code>：返回对应名字的枚举类对象</li>
<li><code> EnumClass.values()</code>：返回全部枚举类列表</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    RED(<span class="number">0xFF0000</span>),</span><br><span class="line">    GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">    BLUE(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//枚举对象直接调用</span></span><br><span class="line">    Color.BLUE</span><br><span class="line">    <span class="comment">//枚举类常量名称</span></span><br><span class="line">    Color.valueOf(<span class="string">&quot;RED&quot;</span>).name <span class="comment">//RED</span></span><br><span class="line">    <span class="comment">//枚举类常量位置</span></span><br><span class="line">    Color.valueOf(<span class="string">&quot;RED&quot;</span>).ordinal <span class="comment">//0</span></span><br><span class="line">    <span class="comment">//枚举类常量列表</span></span><br><span class="line">    Color.values().size <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>enumValues&lt;T&gt;()</code>和<code>enumValueOf&lt;T&gt;()</code>函数以通用方式访问枚举类中的常量：</p>
<p><strong>todo</strong></p>
<h2 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h2><p><code>kotlin</code>中通过<code>object</code>关键字可声明一个单例对象。省去了私有化构造函数、创建对象的过程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建单例</span></span><br><span class="line"><span class="keyword">object</span> singleObject&#123;</span><br><span class="line">    <span class="keyword">val</span> name:String = <span class="string">&quot;魔力猫&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;喵&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用单例对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    singleObject.name</span><br><span class="line">    singleObject.cry()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>单例对象可以声明在顶级位置，也可以声明在类、接口等位置中</li>
</ul>
<h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>对象表达式用于创建匿名对象，在第一次使用时被初始化</p>
<h3 id="对象表达式定义"><a href="#对象表达式定义" class="headerlink" title="对象表达式定义"></a>对象表达式定义</h3><p>对象表达式以<code>object</code>关键字开头</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果没有任何非基本类型对象，可以直接object加&#123;&#125;</span></span><br><span class="line">    <span class="keyword">val</span> t1 = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> hello:String = <span class="string">&quot;hello&quot;</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;<span class="variable">$hello</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从超类型继承匿名对象</span></span><br><span class="line">    <span class="keyword">val</span> t2 = <span class="keyword">object</span> :TestClass&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;匿名内部类&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象类型：</p>
<ul>
<li>如果没有声明基类：<code>Any</code></li>
<li>如果只有声明一个基类：基类</li>
<li>如果声明多个基类：需要显式声明类型</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Any类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getObject</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">&quot;x&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//A类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getObjectA</span><span class="params">()</span></span> = <span class="keyword">object</span>: A &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funFromA</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">&quot;x&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//显式声明B类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getObjectB</span><span class="params">()</span></span>: B = <span class="keyword">object</span>: A, B &#123; </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">funFromA</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">&quot;x&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名对象做为返回值"><a href="#匿名对象做为返回值" class="headerlink" title="匿名对象做为返回值"></a>匿名对象做为返回值</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">&quot;x&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>对象声明在第一次访问时被初始化</p>
<h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><p><strong>声明方式</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> 类名:基类,... &#123;</span><br><span class="line">    属性声明</span><br><span class="line">    方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.属性</span><br><span class="line">类名.方法</span><br></pre></td></tr></table></figure>

<p><strong>举例如下</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnimalList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printAnimals</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> AnimalManager:AnimalList&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addAnimal</span><span class="params">(a: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> Animals: LinkedList&lt;String&gt; = LinkedList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">printAnimals</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(Animals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    AnimalManager.addAnimal(<span class="string">&quot;猫&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于使用<code>object</code>关键字声明一个类的同时创造一个对象，这个对象是单例的</p>
<h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>类中的对象声明可以使用<code>companion</code>关键字标记，这样就可以直接通过类名调用内部的对象声明中的成员，包括私有</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">    <span class="comment">//可省略伴生对象名称：AnimalManager</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> AnimalManager&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">addAnimal</span><span class="params">(a: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> Animals: LinkedList&lt;String&gt; = LinkedList&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//半生对象扩展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Animals.AnimalManager.<span class="title">printAnimals</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(Animals)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Animals.addAnimal(<span class="string">&quot;猫&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><p>函数、属性、类、对象和接口可以直接在包内的“顶级”声明</p>
<p><strong>顶级声明</strong>可见性修饰符如下：</p>
<ul>
<li><code>private</code>：只在同一文件中可见</li>
<li><code>protected</code>：不能用来修饰顶层声明</li>
<li><code>internal</code>：同一模块中可见</li>
<li><code>public</code>：默认可见性，在任何地方都可见</li>
</ul>
<p><strong>类成员</strong>可见性修饰符如下：</p>
<ul>
<li><code>private</code>：类内可见</li>
<li><code>protected</code>：类内和子类可见</li>
<li><code>internal</code>：同一模块中可见</li>
<li><code>public</code>：默认可见性，在任何地方都可见</li>
</ul>
<p><strong>覆盖类成员</strong>时规则：</p>
<ul>
<li>方法覆盖时未声明可见性，则覆盖成员与原始成员可见性相同</li>
<li><code>private</code>成员不可覆盖</li>
<li>子类覆盖父类方法可见性要相同或更大</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li>局部变量、函数和类不能有可见性修饰符</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>面向对象</p><p><a href="http://example.com/2020/10/18/技术栈/Kotlin/基础/面向对象/">http://example.com/2020/10/18/技术栈/Kotlin/基础/面向对象/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>路由器</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-01-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div></article></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Kotlin/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">类型系统</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/15/%E6%A1%86%E6%9E%B6/Java/Spring%20Boot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><span class="level-item">Spring Boot 源码解析（三）SpringApplication 初始化</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="路由器"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">路由器</p><p class="is-size-6 is-block">笔记</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>M78</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">114</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">29</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zcy626727" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zcy626727"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C#</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Elixir/"><span class="level-start"><span class="level-item">Elixir</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Elixir/Phoenix/"><span class="level-start"><span class="level-item">Phoenix</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">29</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Quarkus/"><span class="level-start"><span class="level-item">Quarkus</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Spring-Boot/"><span class="level-start"><span class="level-item">Spring Boot</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/Spring-MVC/"><span class="level-start"><span class="level-item">Spring MVC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Kubernetes/"><span class="level-start"><span class="level-item">Kubernetes</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Arch/"><span class="level-start"><span class="level-item">Arch</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Fedora/"><span class="level-start"><span class="level-item">Fedora</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Ubuntu/"><span class="level-start"><span class="level-item">Ubuntu</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Minio/"><span class="level-start"><span class="level-item">Minio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Scrapy/"><span class="level-start"><span class="level-item">Scrapy</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"><span class="level-start"><span class="level-item">MongoDB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Transformers/"><span class="level-start"><span class="level-item">Transformers</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"><span class="level-start"><span class="level-item">pytorch</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Controller/">Controller</a></p><p class="categories"><a href="/categories/Elixir/">Elixir</a> / <a href="/categories/Elixir/Phoenix/">Phoenix</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Plug/">Plug</a></p><p class="categories"><a href="/categories/Elixir/">Elixir</a> / <a href="/categories/Elixir/Phoenix/">Phoenix</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/Phoenix/Router/">Router</a></p><p class="categories"><a href="/categories/Elixir/">Elixir</a> / <a href="/categories/Elixir/Phoenix/">Phoenix</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">类型系统</a></p><p class="categories"><a href="/categories/Elixir/">Elixir</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/%E6%8A%80%E6%9C%AF%E6%A0%88/Elixir/%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/">集合</a></p><p class="categories"><a href="/categories/Elixir/">Elixir</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arch/"><span class="tag">Arch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker-%E5%91%BD%E4%BB%A4/"><span class="tag">Docker 命令</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fedora/"><span class="tag">Fedora</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Minio/"><span class="tag">Minio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/S3/"><span class="tag">S3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBootWeb%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90/"><span class="tag">SpringBootWeb框架集成</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90/"><span class="tag">SpringBoot数据库集成</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"><span class="tag">SpringBoot核心功能</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><span class="tag">SpringBoot源码解析</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"><span class="tag">Spring数据访问</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"><span class="tag">Spring核心功能</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring%E6%B3%A8%E8%A7%A3/"><span class="tag">Spring注解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ubuntu/"><span class="tag">Ubuntu</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fedora/"><span class="tag">fedora</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">分布式文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"><span class="tag">包管理器</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tag">大数据</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B5%8B%E8%AF%95/"><span class="tag">测试</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="tag">环境配置</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag">59</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%83%A8%E7%BD%B2/"><span class="tag">部署</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="路由器" height="28"></a><p class="is-size-7"><span>&copy; 2024 路由器</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>